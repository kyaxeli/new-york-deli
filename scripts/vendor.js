(window.webpackJsonp = window.webpackJsonp || []).push([[2], { "+aTx": function (t, e, r) { var n, i; i = this, void 0 === (n = function () { return i.svg4everybody = function () { function t(t, e, r) { if (r) { var n = document.createDocumentFragment(), i = !e.hasAttribute("viewBox") && r.getAttribute("viewBox"); i && e.setAttribute("viewBox", i); for (var o = r.cloneNode(!0); o.childNodes.length;)n.appendChild(o.firstChild); t.appendChild(n) } } function e(e) { e.onreadystatechange = function () { if (4 === e.readyState) { var r = e._cachedDocument; r || ((r = e._cachedDocument = document.implementation.createHTMLDocument("")).body.innerHTML = e.responseText, e._cachedTarget = {}), e._embeds.splice(0).map((function (n) { var i = e._cachedTarget[n.id]; i || (i = e._cachedTarget[n.id] = r.getElementById(n.id)), t(n.parent, n.svg, i) })) } }, e.onreadystatechange() } function r(t) { for (var e = t; "svg" !== e.nodeName.toLowerCase() && (e = e.parentNode);); return e } return function (n) { var i, o = Object(n), a = window.top !== window.self; i = "polyfill" in o ? o.polyfill : /\bTrident\/[567]\b|\bMSIE (?:9|10)\.0\b/.test(navigator.userAgent) || (navigator.userAgent.match(/\bEdge\/12\.(\d+)\b/) || [])[1] < 10547 || (navigator.userAgent.match(/\bAppleWebKit\/(\d+)\b/) || [])[1] < 537 || /\bEdge\/.(\d+)\b/.test(navigator.userAgent) && a; var s = {}, c = window.requestAnimationFrame || setTimeout, l = document.getElementsByTagName("use"), h = 0; i && function n() { for (var a = 0; a < l.length;) { var u = l[a], p = u.parentNode, d = r(p), f = u.getAttribute("xlink:href") || u.getAttribute("href"); if (!f && o.attributeName && (f = u.getAttribute(o.attributeName)), d && f) { if (i) if (!o.validate || o.validate(f, d, u)) { p.removeChild(u); var m = f.split("#"), v = m.shift(), g = m.join("#"); if (v.length) { var y = s[v]; y || ((y = s[v] = new XMLHttpRequest).open("GET", v), y.send(), y._embeds = []), y._embeds.push({ parent: p, svg: d, id: g }), e(y) } else t(p, d, document.getElementById(g)) } else ++a, ++h } else ++a } (!l.length || l.length - h > 0) && c(n, 67) }() } }() }.apply(e, [])) || (t.exports = n) }, "9/5/": function (t, e, r) { (function (e) { var r = "Expected a function", n = NaN, i = "[object Symbol]", o = /^\s+|\s+$/g, a = /^[-+]0x[0-9a-f]+$/i, s = /^0b[01]+$/i, c = /^0o[0-7]+$/i, l = parseInt, h = "object" == typeof e && e && e.Object === Object && e, u = "object" == typeof self && self && self.Object === Object && self, p = h || u || Function("return this")(), d = Object.prototype.toString, f = Math.max, m = Math.min, v = function () { return p.Date.now() }; function g(t) { var e = typeof t; return !!t && ("object" == e || "function" == e) } function y(t) { if ("number" == typeof t) return t; if (function (t) { return "symbol" == typeof t || function (t) { return !!t && "object" == typeof t }(t) && d.call(t) == i }(t)) return n; if (g(t)) { var e = "function" == typeof t.valueOf ? t.valueOf() : t; t = g(e) ? e + "" : e } if ("string" != typeof t) return 0 === t ? t : +t; t = t.replace(o, ""); var r = s.test(t); return r || c.test(t) ? l(t.slice(2), r ? 2 : 8) : a.test(t) ? n : +t } t.exports = function (t, e, n) { var i, o, a, s, c, l, h = 0, u = !1, p = !1, d = !0; if ("function" != typeof t) throw new TypeError(r); function x(e) { var r = i, n = o; return i = o = void 0, h = e, s = t.apply(n, r) } function b(t) { var r = t - l; return void 0 === l || r >= e || r < 0 || p && t - h >= a } function w() { var t = v(); if (b(t)) return _(t); c = setTimeout(w, function (t) { var r = e - (t - l); return p ? m(r, a - (t - h)) : r }(t)) } function _(t) { return c = void 0, d && i ? x(t) : (i = o = void 0, s) } function M() { var t = v(), r = b(t); if (i = arguments, o = this, l = t, r) { if (void 0 === c) return function (t) { return h = t, c = setTimeout(w, e), u ? x(t) : s }(l); if (p) return c = setTimeout(w, e), x(l) } return void 0 === c && (c = setTimeout(w, e)), s } return e = y(e) || 0, g(n) && (u = !!n.leading, a = (p = "maxWait" in n) ? f(y(n.maxWait) || 0, e) : a, d = "trailing" in n ? !!n.trailing : d), M.cancel = function () { void 0 !== c && clearTimeout(c), h = 0, i = l = o = c = void 0 }, M.flush = function () { return void 0 === c ? s : _(v()) }, M } }).call(this, r("yLpj")) }, "94FF": function (t, e, r) { r("+aTx")({}) }, "9CKC": function (t, e, r) { var n; window, n = function () { return function (t) { var e = {}; function r(n) { if (e[n]) return e[n].exports; var i = e[n] = { i: n, l: !1, exports: {} }; return t[n].call(i.exports, i, i.exports, r), i.l = !0, i.exports } return r.m = t, r.c = e, r.d = function (t, e, n) { r.o(t, e) || Object.defineProperty(t, e, { enumerable: !0, get: n }) }, r.r = function (t) { "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(t, "__esModule", { value: !0 }) }, r.t = function (t, e) { if (1 & e && (t = r(t)), 8 & e) return t; if (4 & e && "object" == typeof t && t && t.__esModule) return t; var n = Object.create(null); if (r.r(n), Object.defineProperty(n, "default", { enumerable: !0, value: t }), 2 & e && "string" != typeof t) for (var i in t) r.d(n, i, function (e) { return t[e] }.bind(null, i)); return n }, r.n = function (t) { var e = t && t.__esModule ? function () { return t.default } : function () { return t }; return r.d(e, "a", e), e }, r.o = function (t, e) { return Object.prototype.hasOwnProperty.call(t, e) }, r.p = "", r(r.s = 60) }([function (t, e) { var r = { html: document.documentElement, body: document.body, windowSize: { w: window.innerWidth, h: window.innerHeight } }; t.exports = r }, function (t, e, r) { (function (e) { var r = function (t) { return t && t.Math == Math && t }; t.exports = r("object" == typeof globalThis && globalThis) || r("object" == typeof window && window) || r("object" == typeof self && self) || r("object" == typeof e && e) || Function("return this")() }).call(this, r(38)) }, function (t, e) { t.exports = function (t) { try { return !!t() } catch (t) { return !0 } } }, function (t, e) { t.exports = function (t) { return "object" == typeof t ? null !== t : "function" == typeof t } }, function (t, e) { var r = {}.hasOwnProperty; t.exports = function (t, e) { return r.call(t, e) } }, function (t, e, r) { var n = r(2); t.exports = !n((function () { return 7 != Object.defineProperty({}, 1, { get: function () { return 7 } })[1] })) }, function (t, e, r) { var n = r(5), i = r(10), o = r(7); t.exports = n ? function (t, e, r) { return i.f(t, e, o(1, r)) } : function (t, e, r) { return t[e] = r, t } }, function (t, e) { t.exports = function (t, e) { return { enumerable: !(1 & t), configurable: !(2 & t), writable: !(4 & t), value: e } } }, function (t, e, r) { var n = r(17), i = r(19); t.exports = function (t) { return n(i(t)) } }, function (t, e, r) { var n = r(3); t.exports = function (t, e) { if (!n(t)) return t; var r, i; if (e && "function" == typeof (r = t.toString) && !n(i = r.call(t))) return i; if ("function" == typeof (r = t.valueOf) && !n(i = r.call(t))) return i; if (!e && "function" == typeof (r = t.toString) && !n(i = r.call(t))) return i; throw TypeError("Can't convert object to primitive value") } }, function (t, e, r) { var n = r(5), i = r(20), o = r(21), a = r(9), s = Object.defineProperty; e.f = n ? s : function (t, e, r) { if (o(t), e = a(e, !0), o(r), i) try { return s(t, e, r) } catch (t) { } if ("get" in r || "set" in r) throw TypeError("Accessors not supported"); return "value" in r && (t[e] = r.value), t } }, function (t, e, r) { var n = r(1), i = r(6); t.exports = function (t, e) { try { i(n, t, e) } catch (r) { n[t] = e } return e } }, function (t, e, r) { var n = r(1), i = r(24), o = r(4), a = r(25), s = r(35), c = r(54), l = i("wks"), h = n.Symbol, u = c ? h : h && h.withoutSetter || a; t.exports = function (t) { return o(l, t) || (s && o(h, t) ? l[t] = h[t] : l[t] = u("Symbol." + t)), l[t] } }, function (t, e, r) { "use strict"; var n = r(14), i = r(2), o = r(33), a = r(3), s = r(34), c = r(29), l = r(52), h = r(53), u = r(55), p = r(12), d = r(36), f = p("isConcatSpreadable"), m = d >= 51 || !i((function () { var t = []; return t[f] = !1, t.concat()[0] !== t })), v = u("concat"), g = function (t) { if (!a(t)) return !1; var e = t[f]; return void 0 !== e ? !!e : o(t) }; n({ target: "Array", proto: !0, forced: !m || !v }, { concat: function (t) { var e, r, n, i, o, a = s(this), u = h(a, 0), p = 0; for (e = -1, n = arguments.length; e < n; e++)if (o = -1 === e ? a : arguments[e], g(o)) { if (p + (i = c(o.length)) > 9007199254740991) throw TypeError("Maximum allowed index exceeded"); for (r = 0; r < i; r++, p++)r in o && l(u, p, o[r]) } else { if (p >= 9007199254740991) throw TypeError("Maximum allowed index exceeded"); l(u, p++, o) } return u.length = p, u } }) }, function (t, e, r) { var n = r(1), i = r(15).f, o = r(6), a = r(40), s = r(11), c = r(45), l = r(51); t.exports = function (t, e) { var r, h, u, p, d, f = t.target, m = t.global, v = t.stat; if (r = m ? n : v ? n[f] || s(f, {}) : (n[f] || {}).prototype) for (h in e) { if (p = e[h], u = t.noTargetGet ? (d = i(r, h)) && d.value : r[h], !l(m ? h : f + (v ? "." : "#") + h, t.forced) && void 0 !== u) { if (typeof p == typeof u) continue; c(p, u) } (t.sham || u && u.sham) && o(p, "sham", !0), a(r, h, p, t) } } }, function (t, e, r) { var n = r(5), i = r(16), o = r(7), a = r(8), s = r(9), c = r(4), l = r(20), h = Object.getOwnPropertyDescriptor; e.f = n ? h : function (t, e) { if (t = a(t), e = s(e, !0), l) try { return h(t, e) } catch (t) { } if (c(t, e)) return o(!i.f.call(t, e), t[e]) } }, function (t, e, r) { "use strict"; var n = {}.propertyIsEnumerable, i = Object.getOwnPropertyDescriptor, o = i && !n.call({ 1: 2 }, 1); e.f = o ? function (t) { var e = i(this, t); return !!e && e.enumerable } : n }, function (t, e, r) { var n = r(2), i = r(18), o = "".split; t.exports = n((function () { return !Object("z").propertyIsEnumerable(0) })) ? function (t) { return "String" == i(t) ? o.call(t, "") : Object(t) } : Object }, function (t, e) { var r = {}.toString; t.exports = function (t) { return r.call(t).slice(8, -1) } }, function (t, e) { t.exports = function (t) { if (null == t) throw TypeError("Can't call method on " + t); return t } }, function (t, e, r) { var n = r(5), i = r(2), o = r(39); t.exports = !n && !i((function () { return 7 != Object.defineProperty(o("div"), "a", { get: function () { return 7 } }).a })) }, function (t, e, r) { var n = r(3); t.exports = function (t) { if (!n(t)) throw TypeError(String(t) + " is not an object"); return t } }, function (t, e, r) { var n = r(23), i = Function.toString; "function" != typeof n.inspectSource && (n.inspectSource = function (t) { return i.call(t) }), t.exports = n.inspectSource }, function (t, e, r) { var n = r(1), i = r(11), o = n["__core-js_shared__"] || i("__core-js_shared__", {}); t.exports = o }, function (t, e, r) { var n = r(44), i = r(23); (t.exports = function (t, e) { return i[t] || (i[t] = void 0 !== e ? e : {}) })("versions", []).push({ version: "3.6.5", mode: n ? "pure" : "global", copyright: "Â© 2020 Denis Pushkarev (zloirock.ru)" }) }, function (t, e) { var r = 0, n = Math.random(); t.exports = function (t) { return "Symbol(" + String(void 0 === t ? "" : t) + ")_" + (++r + n).toString(36) } }, function (t, e) { t.exports = {} }, function (t, e, r) { var n = r(47), i = r(1), o = function (t) { return "function" == typeof t ? t : void 0 }; t.exports = function (t, e) { return arguments.length < 2 ? o(n[t]) || o(i[t]) : n[t] && n[t][e] || i[t] && i[t][e] } }, function (t, e, r) { var n = r(4), i = r(8), o = r(49).indexOf, a = r(26); t.exports = function (t, e) { var r, s = i(t), c = 0, l = []; for (r in s) !n(a, r) && n(s, r) && l.push(r); for (; e.length > c;)n(s, r = e[c++]) && (~o(l, r) || l.push(r)); return l } }, function (t, e, r) { var n = r(30), i = Math.min; t.exports = function (t) { return t > 0 ? i(n(t), 9007199254740991) : 0 } }, function (t, e) { var r = Math.ceil, n = Math.floor; t.exports = function (t) { return isNaN(t = +t) ? 0 : (t > 0 ? n : r)(t) } }, function (t, e) { t.exports = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"] }, function (t, e) { e.f = Object.getOwnPropertySymbols }, function (t, e, r) { var n = r(18); t.exports = Array.isArray || function (t) { return "Array" == n(t) } }, function (t, e, r) { var n = r(19); t.exports = function (t) { return Object(n(t)) } }, function (t, e, r) { var n = r(2); t.exports = !!Object.getOwnPropertySymbols && !n((function () { return !String(Symbol()) })) }, function (t, e, r) { var n, i, o = r(1), a = r(56), s = o.process, c = s && s.versions, l = c && c.v8; l ? i = (n = l.split("."))[0] + n[1] : a && (!(n = a.match(/Edge\/(\d+)/)) || n[1] >= 74) && (n = a.match(/Chrome\/(\d+)/)) && (i = n[1]), t.exports = i && +i }, function (t, e) { t.exports = function (t, e) { var r = null; return function () { clearTimeout(r); var n = arguments, i = this; r = setTimeout((function () { t.apply(i, n) }), e) } } }, function (t, e) { var r; r = function () { return this }(); try { r = r || new Function("return this")() } catch (t) { "object" == typeof window && (r = window) } t.exports = r }, function (t, e, r) { var n = r(1), i = r(3), o = n.document, a = i(o) && i(o.createElement); t.exports = function (t) { return a ? o.createElement(t) : {} } }, function (t, e, r) { var n = r(1), i = r(6), o = r(4), a = r(11), s = r(22), c = r(41), l = c.get, h = c.enforce, u = String(String).split("String"); (t.exports = function (t, e, r, s) { var c = !!s && !!s.unsafe, l = !!s && !!s.enumerable, p = !!s && !!s.noTargetGet; "function" == typeof r && ("string" != typeof e || o(r, "name") || i(r, "name", e), h(r).source = u.join("string" == typeof e ? e : "")), t !== n ? (c ? !p && t[e] && (l = !0) : delete t[e], l ? t[e] = r : i(t, e, r)) : l ? t[e] = r : a(e, r) })(Function.prototype, "toString", (function () { return "function" == typeof this && l(this).source || s(this) })) }, function (t, e, r) { var n, i, o, a = r(42), s = r(1), c = r(3), l = r(6), h = r(4), u = r(43), p = r(26), d = s.WeakMap; if (a) { var f = new d, m = f.get, v = f.has, g = f.set; n = function (t, e) { return g.call(f, t, e), e }, i = function (t) { return m.call(f, t) || {} }, o = function (t) { return v.call(f, t) } } else { var y = u("state"); p[y] = !0, n = function (t, e) { return l(t, y, e), e }, i = function (t) { return h(t, y) ? t[y] : {} }, o = function (t) { return h(t, y) } } t.exports = { set: n, get: i, has: o, enforce: function (t) { return o(t) ? i(t) : n(t, {}) }, getterFor: function (t) { return function (e) { var r; if (!c(e) || (r = i(e)).type !== t) throw TypeError("Incompatible receiver, " + t + " required"); return r } } } }, function (t, e, r) { var n = r(1), i = r(22), o = n.WeakMap; t.exports = "function" == typeof o && /native code/.test(i(o)) }, function (t, e, r) { var n = r(24), i = r(25), o = n("keys"); t.exports = function (t) { return o[t] || (o[t] = i(t)) } }, function (t, e) { t.exports = !1 }, function (t, e, r) { var n = r(4), i = r(46), o = r(15), a = r(10); t.exports = function (t, e) { for (var r = i(e), s = a.f, c = o.f, l = 0; l < r.length; l++) { var h = r[l]; n(t, h) || s(t, h, c(e, h)) } } }, function (t, e, r) { var n = r(27), i = r(48), o = r(32), a = r(21); t.exports = n("Reflect", "ownKeys") || function (t) { var e = i.f(a(t)), r = o.f; return r ? e.concat(r(t)) : e } }, function (t, e, r) { var n = r(1); t.exports = n }, function (t, e, r) { var n = r(28), i = r(31).concat("length", "prototype"); e.f = Object.getOwnPropertyNames || function (t) { return n(t, i) } }, function (t, e, r) { var n = r(8), i = r(29), o = r(50), a = function (t) { return function (e, r, a) { var s, c = n(e), l = i(c.length), h = o(a, l); if (t && r != r) { for (; l > h;)if ((s = c[h++]) != s) return !0 } else for (; l > h; h++)if ((t || h in c) && c[h] === r) return t || h || 0; return !t && -1 } }; t.exports = { includes: a(!0), indexOf: a(!1) } }, function (t, e, r) { var n = r(30), i = Math.max, o = Math.min; t.exports = function (t, e) { var r = n(t); return r < 0 ? i(r + e, 0) : o(r, e) } }, function (t, e, r) { var n = r(2), i = /#|\.prototype\./, o = function (t, e) { var r = s[a(t)]; return r == l || r != c && ("function" == typeof e ? n(e) : !!e) }, a = o.normalize = function (t) { return String(t).replace(i, ".").toLowerCase() }, s = o.data = {}, c = o.NATIVE = "N", l = o.POLYFILL = "P"; t.exports = o }, function (t, e, r) { "use strict"; var n = r(9), i = r(10), o = r(7); t.exports = function (t, e, r) { var a = n(e); a in t ? i.f(t, a, o(0, r)) : t[a] = r } }, function (t, e, r) { var n = r(3), i = r(33), o = r(12)("species"); t.exports = function (t, e) { var r; return i(t) && ("function" != typeof (r = t.constructor) || r !== Array && !i(r.prototype) ? n(r) && null === (r = r[o]) && (r = void 0) : r = void 0), new (void 0 === r ? Array : r)(0 === e ? 0 : e) } }, function (t, e, r) { var n = r(35); t.exports = n && !Symbol.sham && "symbol" == typeof Symbol.iterator }, function (t, e, r) { var n = r(2), i = r(12), o = r(36), a = i("species"); t.exports = function (t) { return o >= 51 || !n((function () { var e = []; return (e.constructor = {})[a] = function () { return { foo: 1 } }, 1 !== e[t](Boolean).foo })) } }, function (t, e, r) { var n = r(27); t.exports = n("navigator", "userAgent") || "" }, function (t, e, r) { var n = r(14), i = r(58); n({ target: "Object", stat: !0, forced: Object.assign !== i }, { assign: i }) }, function (t, e, r) { "use strict"; var n = r(5), i = r(2), o = r(59), a = r(32), s = r(16), c = r(34), l = r(17), h = Object.assign, u = Object.defineProperty; t.exports = !h || i((function () { if (n && 1 !== h({ b: 1 }, h(u({}, "a", { enumerable: !0, get: function () { u(this, "b", { value: 3, enumerable: !1 }) } }), { b: 2 })).b) return !0; var t = {}, e = {}, r = Symbol(); return t[r] = 7, "abcdefghijklmnopqrst".split("").forEach((function (t) { e[t] = t })), 7 != h({}, t)[r] || "abcdefghijklmnopqrst" != o(h({}, e)).join("") })) ? function (t, e) { for (var r = c(t), i = arguments.length, h = 1, u = a.f, p = s.f; i > h;)for (var d, f = l(arguments[h++]), m = u ? o(f).concat(u(f)) : o(f), v = m.length, g = 0; v > g;)d = m[g++], n && !p.call(f, d) || (r[d] = f[d]); return r } : h }, function (t, e, r) { var n = r(28), i = r(31); t.exports = Object.keys || function (t) { return n(t, i) } }, function (t, e, r) { "use strict"; r.r(e); var n = r(0), i = r.n(n), o = r(37), a = r.n(o); function s() { if (!(this instanceof s)) return new s; this.size = 0, this.uid = 0, this.selectors = [], this.selectorObjects = {}, this.indexes = Object.create(this.indexes), this.activeIndexes = [] } var c = window.document.documentElement, l = c.matches || c.webkitMatchesSelector || c.mozMatchesSelector || c.oMatchesSelector || c.msMatchesSelector; s.prototype.matchesSelector = function (t, e) { return l.call(t, e) }, s.prototype.querySelectorAll = function (t, e) { return e.querySelectorAll(t) }, s.prototype.indexes = []; var h = /^#((?:[\w\u00c0-\uFFFF\-]|\\.)+)/g; s.prototype.indexes.push({ name: "ID", selector: function (t) { var e; if (e = t.match(h)) return e[0].slice(1) }, element: function (t) { if (t.id) return [t.id] } }); var u = /^\.((?:[\w\u00c0-\uFFFF\-]|\\.)+)/g; s.prototype.indexes.push({ name: "CLASS", selector: function (t) { var e; if (e = t.match(u)) return e[0].slice(1) }, element: function (t) { var e = t.className; if (e) { if ("string" == typeof e) return e.split(/\s/); if ("object" == typeof e && "baseVal" in e) return e.baseVal.split(/\s/) } } }); var p, d = /^((?:[\w\u00c0-\uFFFF\-]|\\.)+)/g; s.prototype.indexes.push({ name: "TAG", selector: function (t) { var e; if (e = t.match(d)) return e[0].toUpperCase() }, element: function (t) { return [t.nodeName.toUpperCase()] } }), s.prototype.indexes.default = { name: "UNIVERSAL", selector: function () { return !0 }, element: function () { return [!0] } }, p = "function" == typeof window.Map ? window.Map : function () { function t() { this.map = {} } return t.prototype.get = function (t) { return this.map[t + " "] }, t.prototype.set = function (t, e) { this.map[t + " "] = e }, t }(); var f = /((?:\((?:\([^()]+\)|[^()]+)+\)|\[(?:\[[^\[\]]*\]|['"][^'"]*['"]|[^\[\]'"]+)+\]|\\.|[^ >+~,(\[\\]+)+|[>+~])(\s*,\s*)?((?:.|\r|\n)*)/g; function m(t, e) { var r, n, i, o, a, s, c = (t = t.slice(0).concat(t.default)).length, l = e, h = []; do { if (f.exec(""), (i = f.exec(l)) && (l = i[3], i[2] || !l)) for (r = 0; r < c; r++)if (a = (s = t[r]).selector(i[1])) { for (n = h.length, o = !1; n--;)if (h[n].index === s && h[n].key === a) { o = !0; break } o || h.push({ index: s, key: a }); break } } while (i); return h } function v(t, e) { var r, n, i; for (r = 0, n = t.length; r < n; r++)if (i = t[r], e.isPrototypeOf(i)) return i } function g(t, e) { return t.id - e.id } s.prototype.logDefaultIndexUsed = function () { }, s.prototype.add = function (t, e) { var r, n, i, o, a, s, c, l, h = this.activeIndexes, u = this.selectors, d = this.selectorObjects; if ("string" == typeof t) { for (d[(r = { id: this.uid++, selector: t, data: e }).id] = r, c = m(this.indexes, t), n = 0; n < c.length; n++)o = (l = c[n]).key, (a = v(h, i = l.index)) || ((a = Object.create(i)).map = new p, h.push(a)), i === this.indexes.default && this.logDefaultIndexUsed(r), (s = a.map.get(o)) || (s = [], a.map.set(o, s)), s.push(r); this.size++, u.push(t) } }, s.prototype.remove = function (t, e) { if ("string" == typeof t) { var r, n, i, o, a, s, c, l, h = this.activeIndexes, u = this.selectors = [], p = this.selectorObjects, d = {}, f = 1 === arguments.length; for (r = m(this.indexes, t), i = 0; i < r.length; i++)for (n = r[i], o = h.length; o--;)if (s = h[o], n.index.isPrototypeOf(s)) { if (c = s.map.get(n.key)) for (a = c.length; a--;)(l = c[a]).selector !== t || !f && l.data !== e || (c.splice(a, 1), d[l.id] = !0); break } for (i in d) delete p[i], this.size--; for (i in p) u.push(p[i].selector) } }, s.prototype.queryAll = function (t) { if (!this.selectors.length) return []; var e, r, n, i, o, a, s, c, l = {}, h = [], u = this.querySelectorAll(this.selectors.join(", "), t); for (e = 0, n = u.length; e < n; e++)for (o = u[e], r = 0, i = (a = this.matches(o)).length; r < i; r++)l[(c = a[r]).id] ? s = l[c.id] : (s = { id: c.id, selector: c.selector, data: c.data, elements: [] }, l[c.id] = s, h.push(s)), s.elements.push(o); return h.sort(g) }, s.prototype.matches = function (t) { if (!t) return []; var e, r, n, i, o, a, s, c, l, h, u, p = this.activeIndexes, d = {}, f = []; for (e = 0, i = p.length; e < i; e++)if (c = (s = p[e]).element(t)) for (r = 0, o = c.length; r < o; r++)if (l = s.map.get(c[r])) for (n = 0, a = l.length; n < a; n++)!d[u = (h = l[n]).id] && this.matchesSelector(t, h.selector) && (d[u] = !0, f.push(h)); return f.sort(g) }; const y = {}, x = {}, b = ["mouseenter", "mouseleave"]; function w(t) { void 0 === x[t] && (x[t] = []) } function _(t) { return "string" == typeof t ? document.querySelectorAll(t) : t } function M(t) { let e = function (t, e) { const r = []; let n = e; do { if (1 !== n.nodeType) break; const e = t.matches(n); e.length && r.push({ delegatedTarget: n, stack: e }) } while (n = n.parentElement); return r }(y[t.type], t.target); if (e.length) for (let r = 0; r < e.length; r++)for (let n = 0; n < e[r].stack.length; n++)-1 !== b.indexOf(t.type) ? (S(t, e[r].delegatedTarget), t.target === e[r].delegatedTarget && e[r].stack[n].data(t)) : (S(t, e[r].delegatedTarget), e[r].stack[n].data(t)) } function S(t, e) { Object.defineProperty(t, "currentTarget", { configurable: !0, enumerable: !0, value: e }) } function T(t) { return JSON.parse(JSON.stringify(t)) } var E = new class { bindAll(t, e) { void 0 === e && (e = Object.getOwnPropertyNames(Object.getPrototypeOf(t))); for (let r = 0; r < e.length; r++)t[e[r]] = t[e[r]].bind(t) } on(t, e, r, n) { if ("function" == typeof e && void 0 === r) return w(t), void x[t].push(e); const i = t.split(" "); for (let t = 0; t < i.length; t++)if (e.nodeType && 1 === e.nodeType || e === window || e === document) e.addEventListener(i[t], r, n); else { e = _(e); for (let o = 0; o < e.length; o++)e[o].addEventListener(i[t], r, n) } } delegate(t, e, r) { const n = t.split(" "); for (let t = 0; t < n.length; t++) { let i = y[n[t]]; void 0 === i && (i = new s, y[n[t]] = i, -1 !== b.indexOf(n[t]) ? document.addEventListener(n[t], M, !0) : document.addEventListener(n[t], M)), i.add(e, r) } } off(t, e, r) { if (void 0 === e) return void (x[t] = []); if ("function" == typeof e) { w(t); for (let r = 0; r < x[t].length; r++)x[t][r] === e && x[t].splice(r, 1); return } const n = t.split(" "); for (let t = 0; t < n.length; t++) { const i = y[n[t]]; if (void 0 === i || (i.remove(e, r), 0 !== i.size)) if (void 0 === e.removeEventListener) { e = _(e); for (let i = 0; i < e.length; i++)e[i].removeEventListener(n[t], r) } else e.removeEventListener(n[t], r); else delete y[n[t]], document.removeEventListener(n[t], M) } } emit(t, ...e) { !function (t, e) { if (x[t]) for (let r = 0; r < x[t].length; r++)x[t][r](...e) }(t, e) } debugDelegated() { return T(y) } debugBus() { return T(x) } }; function A(t, e) { for (var r = 0; r < e.length; r++) { var n = e[r]; n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(t, n.key, n) } } var L = function () { function t() { var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; !function (t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function") }(this, t), this.options = e, E.bindAll(this, ["onRaf"]), i.a.eventNames = { RAF: 1, EXTERNALRAF: 2, SCROLL: 3, WHEEL: 4, COMBOSCROLL: 5, RESIZE: 6, TOUCHMOUSE: 7, SCROLLEND: 8 }, this.addEvents() } var e, r, n; return e = t, (r = [{ key: "addEvents", value: function () { var t = this; this.options.disableRaf || requestAnimationFrame(this.onRaf), this.options.disableResize || E.on("resize", window, a()((function () { t.onResize() }), 150)), this.onScroll(), "ontouchstart" in document.documentElement && (i.a.isTouch = !0, this.detectMouse()) } }, { key: "onRaf", value: function () { E.emit(i.a.eventNames.RAF), this.options.disableRaf || requestAnimationFrame(this.onRaf) } }, { key: "onScroll", value: function () { E.on("wheel", window, (function (t) { E.emit(i.a.eventNames.WHEEL, { event: t }) }), { passive: !1 }), E.on("scroll", window, (function (t) { E.emit(i.a.eventNames.SCROLL, { event: t }) }), { passive: !0 }) } }, { key: "onResize", value: function (t, e) { i.a.windowSize.w = t || window.innerWidth, i.a.windowSize.h = e || window.innerHeight, E.emit(i.a.eventNames.RESIZE) } }, { key: "detectMouse", value: function () { window.addEventListener("mousemove", (function t(e) { (Math.abs(e.movementX) > 0 || Math.abs(e.movementY) > 0) && (i.a.isTouch = !1, E.emit(i.a.events.TOUCHMOUSE), window.removeEventListener("mousemove", t)) })) } }]) && A(e.prototype, r), n && A(e, n), t }(); function P(t, e) { for (var r = 0; r < e.length; r++) { var n = e[r]; n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(t, n.key, n) } } r(13), r(57); var R = function () { function t(e) { !function (t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function") }(this, t), E.bindAll(this, ["onMouseMove", "onMouseDown", "onMouseUp"]), this.smoothScroll = e, this.addHTML(), this.el = document.querySelector(this.smoothScroll.options.scrollbarEl), this.handle = document.querySelector(this.smoothScroll.options.scrollbarHandleEl), this.addStyles(), this.addEvents() } var e, r, n; return e = t, (r = [{ key: "addEvents", value: function () { E.on("mousedown", this.handle, this.onMouseDown), E.on("mousemove", window, this.onMouseMove), E.on("mouseup", window, this.onMouseUp) } }, { key: "onResize", value: function () { this.scale = (-this.smoothScroll.maxScroll + i.a.windowSize.h) / i.a.windowSize.h, this.scale <= 1 ? this.handle.style.height = 0 : (this.trueSize = i.a.windowSize.h / this.scale, this.handleHeight = Math.max(this.trueSize, 40), this.handle.style.height = "".concat(this.handleHeight, "px")) } }, { key: "transform", value: function () { var t = -this.smoothScroll.scrollPos / -this.smoothScroll.maxScroll * (i.a.windowSize.h - this.handleHeight); this.handle.style.transform = "translate3d(0, ".concat(t, "px, 0)") } }, { key: "show", value: function () { this.el.classList.add("show") } }, { key: "hide", value: function () { this.el.classList.remove("show") } }, { key: "onMouseMove", value: function (t) { if (this.mouseDown) { var e = i.a.windowSize.h + (this.trueSize - this.handleHeight); this.smoothScroll.scrollPos = t.clientY / e * this.smoothScroll.maxScroll, this.smoothScroll.clamp(), this.smoothScroll.syncScroll = !0, E.emit(i.a.eventNames.COMBOSCROLL, this.smoothScroll.scrollPos) } } }, { key: "onMouseDown", value: function () { this.mouseDown = !0, i.a.body.style.userSelect = "none", i.a.body.style["-ms-user-select"] = "none", this.el.classList.add("active") } }, { key: "onMouseUp", value: function () { this.mouseDown = !1, i.a.body.style.removeProperty("user-select"), i.a.body.style.removeProperty("-ms-user-select"), this.el.classList.remove("active") } }, { key: "addHTML", value: function () { if (!document.querySelector(this.smoothScroll.options.scrollbarEl)) { var t = document.createElement("div"); t.classList.add(this.smoothScroll.options.scrollbarEl.substring(1)), t.innerHTML = '<div class="'.concat(this.smoothScroll.options.scrollbarHandleEl.substring(1), '"><div></div></div>'), document.body.appendChild(t) } } }, { key: "addStyles", value: function () { if (this.smoothScroll.options.disableNativeScrollbar || this.smoothScroll.options.scrollbarStyles) { var t = ""; this.smoothScroll.options.disableNativeScrollbar && (t += "html{scrollbar-width:none;}body{-ms-overflow-style:none;}body::-webkit-scrollbar{width:0;height:0;}"), this.smoothScroll.options.scrollbarStyles && (t += "".concat(this.smoothScroll.options.scrollbarEl, " {position: fixed;top: 0;right: 0;width: 20px;height: 100%;z-index: 900;}.is-touch ").concat(this.smoothScroll.options.scrollbarEl, " {display: none;}").concat(this.smoothScroll.options.scrollbarEl, " > div {padding: 6px 0;width: 10px;height: 0;margin: 0 auto;visibility: hidden;}").concat(this.smoothScroll.options.scrollbarEl, " > div > div {width: 100%;height: 100%;border-radius: 10px;opacity: 0.3;background-color: #000000;}").concat(this.smoothScroll.options.scrollbarEl, " > div > div:hover {opacity: 0.9;}").concat(this.smoothScroll.options.scrollbarEl, ":hover > div, ").concat(this.smoothScroll.options.scrollbarEl, ".show > div, ").concat(this.smoothScroll.options.scrollbarEl, ".active > div {visibility: visible;}").concat(this.smoothScroll.options.scrollbarEl, ".active > div > div {opacity: 0.9;}")); var e = document.createElement("style"); e.type = "text/css", e.styleSheet ? e.styleSheet.cssText = t : e.appendChild(document.createTextNode(t)), document.getElementsByTagName("head")[0].appendChild(e) } } }, { key: "destroy", value: function () { E.off("mousedown", this.handle, this.onMouseDown), window.removeEventListener("mousemove", this.onMouseMove), window.removeEventListener("mouseup", this.onMouseUp) } }]) && P(e.prototype, r), n && P(e, n), t }(); function C(t, e) { for (var r = 0; r < e.length; r++) { var n = e[r]; n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(t, n.key, n) } } var O = function () { function t() { var e = this, r = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; !function (t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function") }(this, t), this.options = r, this.scrollbarCheck = this.options.customScrollbar, E.bindAll(this, ["onScroll", "onRAF", "onResize", "toggleFixedContainer"]), this.scrollContainer = document.querySelector(this.options.element); var n = this.scrollContainer.querySelectorAll(this.options.innerElement); this.scrollTargets = n.length ? n : [this.scrollContainer.firstElementChild], this.scrollTargetsLength = this.scrollTargets.length, this.scrollPos = this.smoothScrollPos = this.prevScrollPos = this.maxScroll = 0, this.enabled = !1, this.render = !1, this.scrolling = !1, this.syncScroll = !1, this.deltaY = 0, this.horizontalScroll = !1, this.touchScroll = !1, this.firstResize = !0, this.preventResizeScroll = !1, this.ease = i.a.isTouch ? this.options.touchEase : this.options.ease, this.delta = 1, this.time = this.startTime = performance.now(), i.a.isTouch && this.options.disableOnTouch ? (this.touchScroll = !0, document.documentElement.classList.add("asscroll-touch"), this.options.customScrollbar = !1, E.on("scroll", this.scrollContainer, (function (t) { E.emit(i.a.eventNames.SCROLL, { event: t }) }), { passive: !0 })) : (i.a.isTouch && (this.options.customScrollbar = !1), this.smoothSetup()), E.on(i.a.eventNames.TOUCHMOUSE, (function () { e.options.disableOnTouch && (e.touchScroll = !1, e.options.customScrollbar = e.scrollbarCheck, e.smoothSetup(), e.onResize()) })), E.on("mouseleave", document, (function () { window.scrollTo(0, -e.scrollPos) })), E.on("keydown", window, (function (t) { "ArrowUp" !== t.key && "ArrowDown" !== t.key && "PageUp" !== t.key && "PageDown" !== t.key && "Home" !== t.key && "End" !== t.key && "Tab" !== t.key || window.scrollTo(0, -e.scrollPos), "Tab" === t.key && e.toggleFixedContainer() })), E.delegate("click", 'a[href^="#"]', this.toggleFixedContainer), E.delegate("wheel", this.options.blockScrollClass, this.blockScrollEvent) } var e, r, n; return e = t, (r = [{ key: "smoothSetup", value: function () { Object.assign(this.scrollContainer.style, { position: "fixed", top: "0px", left: "0px", width: "100%", height: "100%", contain: "content" }), this.options.customScrollbar && (this.scrollbar = new R(this)), E.on(i.a.eventNames.RAF, this.onRAF), E.on(i.a.eventNames.RESIZE, this.onResize) } }, { key: "onScroll", value: function (t) { var e = t.event; if (this.scrolling || (this.options.customScrollbar && this.scrollbar.show(), this.toggleIframes(), this.scrolling = !0), !i.a.isTouch && "wheel" === e.type) return e.preventDefault(), this.deltaY = e.deltaY, this.syncScroll = !0, this.scrollPos += -1 * this.deltaY, this.clamp(), void E.emit(i.a.eventNames.COMBOSCROLL, this.scrollPos); this.preventResizeScroll ? this.preventResizeScroll = !1 : (this.touchScroll ? this.scrollPos = this.horizontalScroll ? -this.scrollContainer.scrollLeft : -this.scrollContainer.scrollTop : this.scrollPos = -window.scrollY, i.a.isTouch && this.options.disableOnTouch && (this.smoothScrollPos = this.scrollPos), this.clamp(), E.emit(i.a.eventNames.COMBOSCROLL, this.scrollPos)) } }, { key: "onRAF", value: function () { if (this.render) { this.options.limitLerpRate && (this.time = .001 * performance.now(), this.delta = Math.min(60 * (this.time - this.startTime), 1), this.startTime = this.time), Math.abs(this.scrollPos - this.smoothScrollPos) < .5 ? (this.smoothScrollPos = this.scrollPos, this.syncScroll && (this.syncScroll = !1, window.scrollTo(0, -this.scrollPos), E.emit(i.a.eventNames.SCROLLEND, this.scrollPos)), this.scrolling && (this.scrolling = !1, this.options.customScrollbar && this.scrollbar.hide(), this.toggleIframes(!0))) : this.smoothScrollPos += (this.scrollPos - this.smoothScrollPos) * this.ease * this.delta; var t = this.horizontalScroll ? this.smoothScrollPos : 0, e = this.horizontalScroll ? 0 : this.smoothScrollPos; this.applyTransform(t, e), this.options.customScrollbar && this.scrollbar.transform(), E.emit(i.a.eventNames.EXTERNALRAF, { scrollPos: this.scrollPos, smoothScrollPos: this.smoothScrollPos }) } } }, { key: "applyTransform", value: function (t, e) { for (var r = 0; r < this.scrollTargetsLength; r++)this.scrollTargets[r].style.transform = "translate3d(".concat(t, "px, ").concat(e, "px, 0px)") } }, { key: "enable", value: function () { var t = arguments.length > 0 && void 0 !== arguments[0] && arguments[0], e = arguments.length > 1 && void 0 !== arguments[1] && arguments[1], r = arguments.length > 2 && void 0 !== arguments[2] && arguments[2], n = arguments.length > 3 && void 0 !== arguments[3] && arguments[3]; this.enabled || (this.enabled = !0, this.render = !0, this.horizontalScroll = n, r && (this.scrollTargets = r.length ? r : [r], this.scrollTargetsLength = this.scrollTargets.length), this.iframes = this.scrollContainer.querySelectorAll("iframe"), i.a.isTouch && this.options.disableOnTouch ? (i.a.body.style.removeProperty("height"), e && (this.scrollPos = this.smoothScrollPos = 0, this.scrollTo(0, !1))) : (this.firstResize = !0, e && (this.scrollPos = this.smoothScrollPos = 0, this.applyTransform(0, 0)), this.onResize()), t && this.scrollTo(this.prevScrollPos, !1), E.on(i.a.eventNames.WHEEL, this.onScroll), E.on(i.a.eventNames.SCROLL, this.onScroll)) } }, { key: "disable", value: function () { var t = arguments.length > 0 && void 0 !== arguments[0] && arguments[0]; this.enabled && (this.enabled = !1, t || (this.render = !1), E.off(i.a.eventNames.WHEEL, this.onScroll), E.off(i.a.eventNames.SCROLL, this.onScroll), this.prevScrollPos = this.scrollPos, i.a.body.style.height = "0px") } }, { key: "clamp", value: function () { this.scrollPos = Math.max(Math.min(this.scrollPos, 0), this.maxScroll) } }, { key: "scrollTo", value: function (t) { var e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1]; this.scrollPos = t, i.a.isTouch && this.options.disableOnTouch && (this.horizontalScroll ? this.scrollContainer.scrollTo(-this.scrollPos, 0) : this.scrollContainer.scrollTo(0, -this.scrollPos)), this.clamp(), this.syncScroll = !0, e && E.emit(i.a.eventNames.COMBOSCROLL, this.scrollPos) } }, { key: "onResize", value: function () { if (this.scrollTargetsLength > 1) { var t = this.scrollTargets[this.scrollTargetsLength - 1], e = window.getComputedStyle(t), r = parseFloat(this.horizontalScroll ? e.marginRight : e.marginBottom), n = t.getBoundingClientRect(), o = this.horizontalScroll ? n.right : n.bottom; this.scrollLength = o + r - this.smoothScrollPos } else this.scrollLength = this.horizontalScroll ? this.scrollTargets[0].scrollWidth : this.scrollTargets[0].scrollHeight; var a = this.horizontalScroll ? i.a.windowSize.w : i.a.windowSize.h; this.maxScroll = this.scrollLength > a ? -(this.scrollLength - a) : 0, this.firstResize || (this.preventResizeScroll = !0), i.a.body.style.height = this.scrollLength + "px", this.options.customScrollbar && this.scrollbar.onResize(), this.firstResize = !1 } }, { key: "toggleIframes", value: function (t) { for (var e = 0; e < this.iframes.length; e++)this.iframes[e].style.pointerEvents = t ? "auto" : "none" } }, { key: "blockScrollEvent", value: function (t) { t.stopPropagation() } }, { key: "toggleFixedContainer", value: function () { var t = this; this.scrollContainer.style.position = "static"; var e = this.smoothScrollPos; this.applyTransform(0, 0), requestAnimationFrame((function () { t.scrollContainer.style.position = "fixed"; var r = t.horizontalScroll ? e : 0, n = t.horizontalScroll ? 0 : e; t.applyTransform(r, n) })) } }]) && C(e.prototype, r), n && C(e, n), t }(); function I(t, e) { for (var r = 0; r < e.length; r++) { var n = e[r]; n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(t, n.key, n) } } r.d(e, "default", (function () { return N })); var N = function () { function t() { var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, r = e.element, n = void 0 === r ? ".asscroll-container" : r, i = e.innerElement, o = void 0 === i ? "[data-asscroll]" : i, a = e.ease, s = void 0 === a ? .075 : a, c = e.touchEase, l = void 0 === c ? 1 : c, h = e.customScrollbar, u = void 0 === h || h, p = e.scrollbarEl, d = void 0 === p ? ".asscrollbar" : p, f = e.scrollbarHandleEl, m = void 0 === f ? ".asscrollbar__handle" : f, v = e.scrollbarStyles, g = void 0 === v || v, y = e.disableNativeScrollbar, x = void 0 === y || y, b = e.disableOnTouch, w = void 0 === b || b, _ = e.disableRaf, M = void 0 !== _ && _, S = e.disableResize, T = void 0 !== S && S, A = e.limitLerpRate, P = void 0 === A || A, R = e.blockScrollClass, C = void 0 === R ? ".asscroll-block" : R; !function (t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function") }(this, t), E.bindAll(this, ["enable", "disable", "on", "scrollTo", "onRaf", "onResize"]), this.Events = new L({ disableRaf: M, disableResize: T }), this.Scroll = new O({ element: n, innerElement: o, ease: s, touchEase: l, customScrollbar: u, scrollbarEl: d, scrollbarHandleEl: m, scrollbarStyles: g, disableNativeScrollbar: x, disableOnTouch: w, limitLerpRate: P, blockScrollClass: C }) } var e, r, n; return e = t, (r = [{ key: "enable", value: function () { var t; (t = this.Scroll).enable.apply(t, arguments) } }, { key: "disable", value: function () { var t; (t = this.Scroll).disable.apply(t, arguments) } }, { key: "onRaf", value: function () { this.Events.onRaf() } }, { key: "onResize", value: function () { var t; (t = this.Events).onResize.apply(t, arguments) } }, { key: "on", value: function (t, e) { "scroll" === t && E.on(i.a.eventNames.COMBOSCROLL, e), "raf" === t && E.on(i.a.eventNames.EXTERNALRAF, e), "scrollEnd" === t && E.on(i.a.eventNames.SCROLLEND, e) } }, { key: "off", value: function (t, e) { "scroll" === t && E.off(i.a.eventNames.COMBOSCROLL, e), "raf" === t && E.off(i.a.eventNames.EXTERNALRAF, e), "scrollEnd" === t && E.off(i.a.eventNames.SCROLLEND, e) } }, { key: "scrollTo", value: function (t) { var e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1]; this.Scroll.scrollTo(-t, e) } }, { key: "scrollPos", get: function () { return this.Scroll.scrollPos } }, { key: "smoothScrollPos", get: function () { return this.Scroll.smoothScrollPos } }]) && I(e.prototype, r), n && I(e, n), t }() }]) }, t.exports = n() }, M3au: function (t, e, r) { "use strict"; var n = r("mNyV"); function i() { var t = navigator.userAgent.toLowerCase(), e = navigator.appVersion.toLowerCase(), r = /windows phone|iemobile|wpdesktop/.test(t), n = !r && /android.*mobile/.test(t), i = !r && !n && /android/i.test(t), o = n || i, a = !r && /ip(hone|od|ad)/i.test(t) && !window.MSStream, s = !r && /ipad/i.test(t) && a, c = i || s, l = n || a && !s || r, h = l || c, u = t.indexOf("firefox") > -1, p = !!t.match(/version\/[\d\.]+.*safari/), d = t.indexOf("opr") > -1, f = !window.ActiveXObject && "ActiveXObject" in window, m = e.indexOf("msie") > -1 || f || e.indexOf("edge") > -1, v = t.indexOf("edge") > -1, g = null !== window.chrome && void 0 !== window.chrome && "google inc." == navigator.vendor.toLowerCase() && !d && !v; this.infos = { isDroid: o, isDroidPhone: n, isDroidTablet: i, isWindowsPhone: r, isIos: a, isIpad: s, isDevice: h, isEdge: v, isIE: m, isIE11: f, isPhone: l, isTablet: c, isFirefox: u, isSafari: p, isOpera: d, isChrome: g, isDesktop: !l && !c }, Object.keys(this.infos).forEach((function (t) { Object.defineProperty(this, t, { get: function () { return this.infos[t] } }) }), this), Object.freeze(this) } t.exports = new i, i.prototype.addClasses = function (t) { Object.keys(this.infos).forEach((function (e) { this.infos[e] && function (t, e) { t.addClass ? t.addClass(e) : t.classList ? t.classList.add(e) : t.className += " " + e }(t, n(e)) }), this) }, i.prototype.getInfos = function () { return t = this.infos, JSON.parse(JSON.stringify(t)); var t } }, Womt: function (t, e, r) { "use strict"; r.d(e, "a", (function () { return sh })), r.d(e, "b", (function () { return fl })), r.d(e, "c", (function () { return ns })), r.d(e, "d", (function () { return Pr })), r.d(e, "e", (function () { return fn })), r.d(e, "f", (function () { return In })), r.d(e, "g", (function () { return ct })), r.d(e, "h", (function () { return Ih })), r.d(e, "i", (function () { return an })), r.d(e, "j", (function () { return Ll })), r.d(e, "k", (function () { return ah })), r.d(e, "l", (function () { return u })), r.d(e, "m", (function () { return rt })), r.d(e, "n", (function () { return $e })), r.d(e, "o", (function () { return wl })), r.d(e, "p", (function () { return _n })), r.d(e, "q", (function () { return _a })), r.d(e, "r", (function () { return ms })), r.d(e, "s", (function () { return ls })), r.d(e, "t", (function () { return dt })), r.d(e, "u", (function () { return xl })), r.d(e, "v", (function () { return hh })), r.d(e, "w", (function () { return Le })), r.d(e, "x", (function () { return ze })), r.d(e, "y", (function () { return Je })), r.d(e, "z", (function () { return Kn })), r.d(e, "A", (function () { return Kc })), r.d(e, "B", (function () { return Yc })), r.d(e, "C", (function () { return ll })), r.d(e, "D", (function () { return fr })), r.d(e, "E", (function () { return ih })), r.d(e, "F", (function () { return pi })), r.d(e, "G", (function () { return Ai })), r.d(e, "H", (function () { return Ei })), r.d(e, "I", (function () { return nh })), r.d(e, "J", (function () { return ru })), r.d(e, "K", (function () { return Re })), r.d(e, "L", (function () { return ul })), r.d(e, "M", (function () { return Pt })), r.d(e, "N", (function () { return st })), r.d(e, "O", (function () { return mr })), r.d(e, "P", (function () { return hi })), r.d(e, "Q", (function () { return rs })), r.d(e, "R", (function () { return $a })), r.d(e, "S", (function () { return eh })), r.d(e, "T", (function () { return Be })), r.d(e, "U", (function () { return Al })), r.d(e, "V", (function () { return xn })), r.d(e, "W", (function () { return Ie })), r.d(e, "X", (function () { return ke })), r.d(e, "Y", (function () { return dl })), r.d(e, "Z", (function () { return f })), r.d(e, "ab", (function () { return Ra })), r.d(e, "bb", (function () { return ue })), void 0 === Number.EPSILON && (Number.EPSILON = Math.pow(2, -52)), void 0 === Number.isInteger && (Number.isInteger = function (t) { return "number" == typeof t && isFinite(t) && Math.floor(t) === t }), void 0 === Math.sign && (Math.sign = function (t) { return t < 0 ? -1 : t > 0 ? 1 : +t }), "name" in Function.prototype == !1 && Object.defineProperty(Function.prototype, "name", { get: function () { return this.toString().match(/^\s*function\s*([^\(\s]*)/)[1] } }), void 0 === Object.assign && (Object.assign = function (t) { if (null == t) throw new TypeError("Cannot convert undefined or null to object"); for (var e = Object(t), r = 1; r < arguments.length; r++) { var n = arguments[r]; if (null != n) for (var i in n) Object.prototype.hasOwnProperty.call(n, i) && (e[i] = n[i]) } return e }); var n = 0, i = 1, o = 2, a = 1, s = 2, c = 3, l = 0, h = 1, u = 2, p = 0, d = 1, f = 2, m = 0, v = 1, g = 2, y = 3, x = 4, b = 5, w = 100, _ = 101, M = 102, S = 103, T = 104, E = 200, A = 201, L = 202, P = 203, R = 204, C = 205, O = 206, I = 207, N = 208, D = 209, z = 210, F = 0, U = 1, B = 2, k = 3, j = 4, G = 5, V = 6, H = 7, W = 0, q = 1, X = 2, Y = 0, Z = 1, J = 2, K = 3, Q = 4, $ = 5, tt = 301, et = 302, rt = 303, nt = 304, it = 305, ot = 306, at = 307, st = 1e3, ct = 1001, lt = 1002, ht = 1003, ut = 1004, pt = 1005, dt = 1006, ft = 1007, mt = 1008, vt = 1009, gt = 1010, yt = 1011, xt = 1012, bt = 1013, wt = 1014, _t = 1015, Mt = 1016, St = 1017, Tt = 1018, Et = 1019, At = 1020, Lt = 1021, Pt = 1022, Rt = 1023, Ct = 1024, Ot = 1025, It = 1026, Nt = 1027, Dt = 1028, zt = 33776, Ft = 33777, Ut = 33778, Bt = 33779, kt = 35840, jt = 35841, Gt = 35842, Vt = 35843, Ht = 36196, Wt = 37808, qt = 37809, Xt = 37810, Yt = 37811, Zt = 37812, Jt = 37813, Kt = 37814, Qt = 37815, $t = 37816, te = 37817, ee = 37818, re = 37819, ne = 37820, ie = 37821, oe = 2201, ae = 2400, se = 0, ce = 1, le = 2, he = 3e3, ue = 3001, pe = 3007, de = 3002, fe = 3003, me = 3004, ve = 3005, ge = 3006, ye = 3200, xe = 3201, be = 0, we = 1, _e = 7680, Me = 519, Se = 35044; function Te() { } Object.assign(Te.prototype, { addEventListener: function (t, e) { void 0 === this._listeners && (this._listeners = {}); var r = this._listeners; void 0 === r[t] && (r[t] = []), -1 === r[t].indexOf(e) && r[t].push(e) }, hasEventListener: function (t, e) { if (void 0 === this._listeners) return !1; var r = this._listeners; return void 0 !== r[t] && -1 !== r[t].indexOf(e) }, removeEventListener: function (t, e) { if (void 0 !== this._listeners) { var r = this._listeners[t]; if (void 0 !== r) { var n = r.indexOf(e); -1 !== n && r.splice(n, 1) } } }, dispatchEvent: function (t) { if (void 0 !== this._listeners) { var e = this._listeners[t.type]; if (void 0 !== e) { t.target = this; for (var r = e.slice(0), n = 0, i = r.length; n < i; n++)r[n].call(this, t) } } } }); for (var Ee = [], Ae = 0; Ae < 256; Ae++)Ee[Ae] = (Ae < 16 ? "0" : "") + Ae.toString(16); var Le = { DEG2RAD: Math.PI / 180, RAD2DEG: 180 / Math.PI, generateUUID: function () { var t = 4294967295 * Math.random() | 0, e = 4294967295 * Math.random() | 0, r = 4294967295 * Math.random() | 0, n = 4294967295 * Math.random() | 0; return (Ee[255 & t] + Ee[t >> 8 & 255] + Ee[t >> 16 & 255] + Ee[t >> 24 & 255] + "-" + Ee[255 & e] + Ee[e >> 8 & 255] + "-" + Ee[e >> 16 & 15 | 64] + Ee[e >> 24 & 255] + "-" + Ee[63 & r | 128] + Ee[r >> 8 & 255] + "-" + Ee[r >> 16 & 255] + Ee[r >> 24 & 255] + Ee[255 & n] + Ee[n >> 8 & 255] + Ee[n >> 16 & 255] + Ee[n >> 24 & 255]).toUpperCase() }, clamp: function (t, e, r) { return Math.max(e, Math.min(r, t)) }, euclideanModulo: function (t, e) { return (t % e + e) % e }, mapLinear: function (t, e, r, n, i) { return n + (t - e) * (i - n) / (r - e) }, lerp: function (t, e, r) { return (1 - r) * t + r * e }, smoothstep: function (t, e, r) { return t <= e ? 0 : t >= r ? 1 : (t = (t - e) / (r - e)) * t * (3 - 2 * t) }, smootherstep: function (t, e, r) { return t <= e ? 0 : t >= r ? 1 : (t = (t - e) / (r - e)) * t * t * (t * (6 * t - 15) + 10) }, randInt: function (t, e) { return t + Math.floor(Math.random() * (e - t + 1)) }, randFloat: function (t, e) { return t + Math.random() * (e - t) }, randFloatSpread: function (t) { return t * (.5 - Math.random()) }, degToRad: function (t) { return t * Le.DEG2RAD }, radToDeg: function (t) { return t * Le.RAD2DEG }, isPowerOfTwo: function (t) { return 0 == (t & t - 1) && 0 !== t }, ceilPowerOfTwo: function (t) { return Math.pow(2, Math.ceil(Math.log(t) / Math.LN2)) }, floorPowerOfTwo: function (t) { return Math.pow(2, Math.floor(Math.log(t) / Math.LN2)) } }; function Pe(t, e) { this.x = t || 0, this.y = e || 0 } function Re(t, e, r, n) { this._x = t || 0, this._y = e || 0, this._z = r || 0, this._w = void 0 !== n ? n : 1 } Object.defineProperties(Pe.prototype, { width: { get: function () { return this.x }, set: function (t) { this.x = t } }, height: { get: function () { return this.y }, set: function (t) { this.y = t } } }), Object.assign(Pe.prototype, { isVector2: !0, set: function (t, e) { return this.x = t, this.y = e, this }, setScalar: function (t) { return this.x = t, this.y = t, this }, setX: function (t) { return this.x = t, this }, setY: function (t) { return this.y = t, this }, setComponent: function (t, e) { switch (t) { case 0: this.x = e; break; case 1: this.y = e; break; default: throw new Error("index is out of range: " + t) }return this }, getComponent: function (t) { switch (t) { case 0: return this.x; case 1: return this.y; default: throw new Error("index is out of range: " + t) } }, clone: function () { return new this.constructor(this.x, this.y) }, copy: function (t) { return this.x = t.x, this.y = t.y, this }, add: function (t, e) { return void 0 !== e ? (console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this) }, addScalar: function (t) { return this.x += t, this.y += t, this }, addVectors: function (t, e) { return this.x = t.x + e.x, this.y = t.y + e.y, this }, addScaledVector: function (t, e) { return this.x += t.x * e, this.y += t.y * e, this }, sub: function (t, e) { return void 0 !== e ? (console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this) }, subScalar: function (t) { return this.x -= t, this.y -= t, this }, subVectors: function (t, e) { return this.x = t.x - e.x, this.y = t.y - e.y, this }, multiply: function (t) { return this.x *= t.x, this.y *= t.y, this }, multiplyScalar: function (t) { return this.x *= t, this.y *= t, this }, divide: function (t) { return this.x /= t.x, this.y /= t.y, this }, divideScalar: function (t) { return this.multiplyScalar(1 / t) }, applyMatrix3: function (t) { var e = this.x, r = this.y, n = t.elements; return this.x = n[0] * e + n[3] * r + n[6], this.y = n[1] * e + n[4] * r + n[7], this }, min: function (t) { return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this }, max: function (t) { return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this }, clamp: function (t, e) { return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this }, clampScalar: function (t, e) { return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this }, clampLength: function (t, e) { var r = this.length(); return this.divideScalar(r || 1).multiplyScalar(Math.max(t, Math.min(e, r))) }, floor: function () { return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this }, ceil: function () { return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this }, round: function () { return this.x = Math.round(this.x), this.y = Math.round(this.y), this }, roundToZero: function () { return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this }, negate: function () { return this.x = -this.x, this.y = -this.y, this }, dot: function (t) { return this.x * t.x + this.y * t.y }, cross: function (t) { return this.x * t.y - this.y * t.x }, lengthSq: function () { return this.x * this.x + this.y * this.y }, length: function () { return Math.sqrt(this.x * this.x + this.y * this.y) }, manhattanLength: function () { return Math.abs(this.x) + Math.abs(this.y) }, normalize: function () { return this.divideScalar(this.length() || 1) }, angle: function () { var t = Math.atan2(this.y, this.x); return t < 0 && (t += 2 * Math.PI), t }, distanceTo: function (t) { return Math.sqrt(this.distanceToSquared(t)) }, distanceToSquared: function (t) { var e = this.x - t.x, r = this.y - t.y; return e * e + r * r }, manhattanDistanceTo: function (t) { return Math.abs(this.x - t.x) + Math.abs(this.y - t.y) }, setLength: function (t) { return this.normalize().multiplyScalar(t) }, lerp: function (t, e) { return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this }, lerpVectors: function (t, e, r) { return this.subVectors(e, t).multiplyScalar(r).add(t) }, equals: function (t) { return t.x === this.x && t.y === this.y }, fromArray: function (t, e) { return void 0 === e && (e = 0), this.x = t[e], this.y = t[e + 1], this }, toArray: function (t, e) { return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this.x, t[e + 1] = this.y, t }, fromBufferAttribute: function (t, e, r) { return void 0 !== r && console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."), this.x = t.getX(e), this.y = t.getY(e), this }, rotateAround: function (t, e) { var r = Math.cos(e), n = Math.sin(e), i = this.x - t.x, o = this.y - t.y; return this.x = i * r - o * n + t.x, this.y = i * n + o * r + t.y, this } }), Object.assign(Re, { slerp: function (t, e, r, n) { return r.copy(t).slerp(e, n) }, slerpFlat: function (t, e, r, n, i, o, a) { var s = r[n + 0], c = r[n + 1], l = r[n + 2], h = r[n + 3], u = i[o + 0], p = i[o + 1], d = i[o + 2], f = i[o + 3]; if (h !== f || s !== u || c !== p || l !== d) { var m = 1 - a, v = s * u + c * p + l * d + h * f, g = v >= 0 ? 1 : -1, y = 1 - v * v; if (y > Number.EPSILON) { var x = Math.sqrt(y), b = Math.atan2(x, v * g); m = Math.sin(m * b) / x, a = Math.sin(a * b) / x } var w = a * g; if (s = s * m + u * w, c = c * m + p * w, l = l * m + d * w, h = h * m + f * w, m === 1 - a) { var _ = 1 / Math.sqrt(s * s + c * c + l * l + h * h); s *= _, c *= _, l *= _, h *= _ } } t[e] = s, t[e + 1] = c, t[e + 2] = l, t[e + 3] = h } }), Object.defineProperties(Re.prototype, { x: { get: function () { return this._x }, set: function (t) { this._x = t, this._onChangeCallback() } }, y: { get: function () { return this._y }, set: function (t) { this._y = t, this._onChangeCallback() } }, z: { get: function () { return this._z }, set: function (t) { this._z = t, this._onChangeCallback() } }, w: { get: function () { return this._w }, set: function (t) { this._w = t, this._onChangeCallback() } } }), Object.assign(Re.prototype, { isQuaternion: !0, set: function (t, e, r, n) { return this._x = t, this._y = e, this._z = r, this._w = n, this._onChangeCallback(), this }, clone: function () { return new this.constructor(this._x, this._y, this._z, this._w) }, copy: function (t) { return this._x = t.x, this._y = t.y, this._z = t.z, this._w = t.w, this._onChangeCallback(), this }, setFromEuler: function (t, e) { if (!t || !t.isEuler) throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order."); var r = t._x, n = t._y, i = t._z, o = t.order, a = Math.cos, s = Math.sin, c = a(r / 2), l = a(n / 2), h = a(i / 2), u = s(r / 2), p = s(n / 2), d = s(i / 2); return "XYZ" === o ? (this._x = u * l * h + c * p * d, this._y = c * p * h - u * l * d, this._z = c * l * d + u * p * h, this._w = c * l * h - u * p * d) : "YXZ" === o ? (this._x = u * l * h + c * p * d, this._y = c * p * h - u * l * d, this._z = c * l * d - u * p * h, this._w = c * l * h + u * p * d) : "ZXY" === o ? (this._x = u * l * h - c * p * d, this._y = c * p * h + u * l * d, this._z = c * l * d + u * p * h, this._w = c * l * h - u * p * d) : "ZYX" === o ? (this._x = u * l * h - c * p * d, this._y = c * p * h + u * l * d, this._z = c * l * d - u * p * h, this._w = c * l * h + u * p * d) : "YZX" === o ? (this._x = u * l * h + c * p * d, this._y = c * p * h + u * l * d, this._z = c * l * d - u * p * h, this._w = c * l * h - u * p * d) : "XZY" === o && (this._x = u * l * h - c * p * d, this._y = c * p * h - u * l * d, this._z = c * l * d + u * p * h, this._w = c * l * h + u * p * d), !1 !== e && this._onChangeCallback(), this }, setFromAxisAngle: function (t, e) { var r = e / 2, n = Math.sin(r); return this._x = t.x * n, this._y = t.y * n, this._z = t.z * n, this._w = Math.cos(r), this._onChangeCallback(), this }, setFromRotationMatrix: function (t) { var e, r = t.elements, n = r[0], i = r[4], o = r[8], a = r[1], s = r[5], c = r[9], l = r[2], h = r[6], u = r[10], p = n + s + u; return p > 0 ? (e = .5 / Math.sqrt(p + 1), this._w = .25 / e, this._x = (h - c) * e, this._y = (o - l) * e, this._z = (a - i) * e) : n > s && n > u ? (e = 2 * Math.sqrt(1 + n - s - u), this._w = (h - c) / e, this._x = .25 * e, this._y = (i + a) / e, this._z = (o + l) / e) : s > u ? (e = 2 * Math.sqrt(1 + s - n - u), this._w = (o - l) / e, this._x = (i + a) / e, this._y = .25 * e, this._z = (c + h) / e) : (e = 2 * Math.sqrt(1 + u - n - s), this._w = (a - i) / e, this._x = (o + l) / e, this._y = (c + h) / e, this._z = .25 * e), this._onChangeCallback(), this }, setFromUnitVectors: function (t, e) { var r = t.dot(e) + 1; return r < 1e-6 ? (r = 0, Math.abs(t.x) > Math.abs(t.z) ? (this._x = -t.y, this._y = t.x, this._z = 0, this._w = r) : (this._x = 0, this._y = -t.z, this._z = t.y, this._w = r)) : (this._x = t.y * e.z - t.z * e.y, this._y = t.z * e.x - t.x * e.z, this._z = t.x * e.y - t.y * e.x, this._w = r), this.normalize() }, angleTo: function (t) { return 2 * Math.acos(Math.abs(Le.clamp(this.dot(t), -1, 1))) }, rotateTowards: function (t, e) { var r = this.angleTo(t); if (0 === r) return this; var n = Math.min(1, e / r); return this.slerp(t, n), this }, inverse: function () { return this.conjugate() }, conjugate: function () { return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this }, dot: function (t) { return this._x * t._x + this._y * t._y + this._z * t._z + this._w * t._w }, lengthSq: function () { return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w }, length: function () { return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w) }, normalize: function () { var t = this.length(); return 0 === t ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (t = 1 / t, this._x = this._x * t, this._y = this._y * t, this._z = this._z * t, this._w = this._w * t), this._onChangeCallback(), this }, multiply: function (t, e) { return void 0 !== e ? (console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."), this.multiplyQuaternions(t, e)) : this.multiplyQuaternions(this, t) }, premultiply: function (t) { return this.multiplyQuaternions(t, this) }, multiplyQuaternions: function (t, e) { var r = t._x, n = t._y, i = t._z, o = t._w, a = e._x, s = e._y, c = e._z, l = e._w; return this._x = r * l + o * a + n * c - i * s, this._y = n * l + o * s + i * a - r * c, this._z = i * l + o * c + r * s - n * a, this._w = o * l - r * a - n * s - i * c, this._onChangeCallback(), this }, slerp: function (t, e) { if (0 === e) return this; if (1 === e) return this.copy(t); var r = this._x, n = this._y, i = this._z, o = this._w, a = o * t._w + r * t._x + n * t._y + i * t._z; if (a < 0 ? (this._w = -t._w, this._x = -t._x, this._y = -t._y, this._z = -t._z, a = -a) : this.copy(t), a >= 1) return this._w = o, this._x = r, this._y = n, this._z = i, this; var s = 1 - a * a; if (s <= Number.EPSILON) { var c = 1 - e; return this._w = c * o + e * this._w, this._x = c * r + e * this._x, this._y = c * n + e * this._y, this._z = c * i + e * this._z, this.normalize(), this._onChangeCallback(), this } var l = Math.sqrt(s), h = Math.atan2(l, a), u = Math.sin((1 - e) * h) / l, p = Math.sin(e * h) / l; return this._w = o * u + this._w * p, this._x = r * u + this._x * p, this._y = n * u + this._y * p, this._z = i * u + this._z * p, this._onChangeCallback(), this }, equals: function (t) { return t._x === this._x && t._y === this._y && t._z === this._z && t._w === this._w }, fromArray: function (t, e) { return void 0 === e && (e = 0), this._x = t[e], this._y = t[e + 1], this._z = t[e + 2], this._w = t[e + 3], this._onChangeCallback(), this }, toArray: function (t, e) { return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._w, t }, _onChange: function (t) { return this._onChangeCallback = t, this }, _onChangeCallback: function () { } }); var Ce = new Ie, Oe = new Re; function Ie(t, e, r) { this.x = t || 0, this.y = e || 0, this.z = r || 0 } Object.assign(Ie.prototype, { isVector3: !0, set: function (t, e, r) { return this.x = t, this.y = e, this.z = r, this }, setScalar: function (t) { return this.x = t, this.y = t, this.z = t, this }, setX: function (t) { return this.x = t, this }, setY: function (t) { return this.y = t, this }, setZ: function (t) { return this.z = t, this }, setComponent: function (t, e) { switch (t) { case 0: this.x = e; break; case 1: this.y = e; break; case 2: this.z = e; break; default: throw new Error("index is out of range: " + t) }return this }, getComponent: function (t) { switch (t) { case 0: return this.x; case 1: return this.y; case 2: return this.z; default: throw new Error("index is out of range: " + t) } }, clone: function () { return new this.constructor(this.x, this.y, this.z) }, copy: function (t) { return this.x = t.x, this.y = t.y, this.z = t.z, this }, add: function (t, e) { return void 0 !== e ? (console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this.z += t.z, this) }, addScalar: function (t) { return this.x += t, this.y += t, this.z += t, this }, addVectors: function (t, e) { return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this }, addScaledVector: function (t, e) { return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this }, sub: function (t, e) { return void 0 !== e ? (console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this.z -= t.z, this) }, subScalar: function (t) { return this.x -= t, this.y -= t, this.z -= t, this }, subVectors: function (t, e) { return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this }, multiply: function (t, e) { return void 0 !== e ? (console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."), this.multiplyVectors(t, e)) : (this.x *= t.x, this.y *= t.y, this.z *= t.z, this) }, multiplyScalar: function (t) { return this.x *= t, this.y *= t, this.z *= t, this }, multiplyVectors: function (t, e) { return this.x = t.x * e.x, this.y = t.y * e.y, this.z = t.z * e.z, this }, applyEuler: function (t) { return t && t.isEuler || console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."), this.applyQuaternion(Oe.setFromEuler(t)) }, applyAxisAngle: function (t, e) { return this.applyQuaternion(Oe.setFromAxisAngle(t, e)) }, applyMatrix3: function (t) { var e = this.x, r = this.y, n = this.z, i = t.elements; return this.x = i[0] * e + i[3] * r + i[6] * n, this.y = i[1] * e + i[4] * r + i[7] * n, this.z = i[2] * e + i[5] * r + i[8] * n, this }, applyNormalMatrix: function (t) { return this.applyMatrix3(t).normalize() }, applyMatrix4: function (t) { var e = this.x, r = this.y, n = this.z, i = t.elements, o = 1 / (i[3] * e + i[7] * r + i[11] * n + i[15]); return this.x = (i[0] * e + i[4] * r + i[8] * n + i[12]) * o, this.y = (i[1] * e + i[5] * r + i[9] * n + i[13]) * o, this.z = (i[2] * e + i[6] * r + i[10] * n + i[14]) * o, this }, applyQuaternion: function (t) { var e = this.x, r = this.y, n = this.z, i = t.x, o = t.y, a = t.z, s = t.w, c = s * e + o * n - a * r, l = s * r + a * e - i * n, h = s * n + i * r - o * e, u = -i * e - o * r - a * n; return this.x = c * s + u * -i + l * -a - h * -o, this.y = l * s + u * -o + h * -i - c * -a, this.z = h * s + u * -a + c * -o - l * -i, this }, project: function (t) { return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix) }, unproject: function (t) { return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(t.matrixWorld) }, transformDirection: function (t) { var e = this.x, r = this.y, n = this.z, i = t.elements; return this.x = i[0] * e + i[4] * r + i[8] * n, this.y = i[1] * e + i[5] * r + i[9] * n, this.z = i[2] * e + i[6] * r + i[10] * n, this.normalize() }, divide: function (t) { return this.x /= t.x, this.y /= t.y, this.z /= t.z, this }, divideScalar: function (t) { return this.multiplyScalar(1 / t) }, min: function (t) { return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this }, max: function (t) { return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this }, clamp: function (t, e) { return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this }, clampScalar: function (t, e) { return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this.z = Math.max(t, Math.min(e, this.z)), this }, clampLength: function (t, e) { var r = this.length(); return this.divideScalar(r || 1).multiplyScalar(Math.max(t, Math.min(e, r))) }, floor: function () { return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this }, ceil: function () { return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this }, round: function () { return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this }, roundToZero: function () { return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this }, negate: function () { return this.x = -this.x, this.y = -this.y, this.z = -this.z, this }, dot: function (t) { return this.x * t.x + this.y * t.y + this.z * t.z }, lengthSq: function () { return this.x * this.x + this.y * this.y + this.z * this.z }, length: function () { return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z) }, manhattanLength: function () { return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) }, normalize: function () { return this.divideScalar(this.length() || 1) }, setLength: function (t) { return this.normalize().multiplyScalar(t) }, lerp: function (t, e) { return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this }, lerpVectors: function (t, e, r) { return this.subVectors(e, t).multiplyScalar(r).add(t) }, cross: function (t, e) { return void 0 !== e ? (console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."), this.crossVectors(t, e)) : this.crossVectors(this, t) }, crossVectors: function (t, e) { var r = t.x, n = t.y, i = t.z, o = e.x, a = e.y, s = e.z; return this.x = n * s - i * a, this.y = i * o - r * s, this.z = r * a - n * o, this }, projectOnVector: function (t) { var e = t.dot(this) / t.lengthSq(); return this.copy(t).multiplyScalar(e) }, projectOnPlane: function (t) { return Ce.copy(this).projectOnVector(t), this.sub(Ce) }, reflect: function (t) { return this.sub(Ce.copy(t).multiplyScalar(2 * this.dot(t))) }, angleTo: function (t) { var e = Math.sqrt(this.lengthSq() * t.lengthSq()); 0 === e && console.error("THREE.Vector3: angleTo() can't handle zero length vectors."); var r = this.dot(t) / e; return Math.acos(Le.clamp(r, -1, 1)) }, distanceTo: function (t) { return Math.sqrt(this.distanceToSquared(t)) }, distanceToSquared: function (t) { var e = this.x - t.x, r = this.y - t.y, n = this.z - t.z; return e * e + r * r + n * n }, manhattanDistanceTo: function (t) { return Math.abs(this.x - t.x) + Math.abs(this.y - t.y) + Math.abs(this.z - t.z) }, setFromSpherical: function (t) { return this.setFromSphericalCoords(t.radius, t.phi, t.theta) }, setFromSphericalCoords: function (t, e, r) { var n = Math.sin(e) * t; return this.x = n * Math.sin(r), this.y = Math.cos(e) * t, this.z = n * Math.cos(r), this }, setFromCylindrical: function (t) { return this.setFromCylindricalCoords(t.radius, t.theta, t.y) }, setFromCylindricalCoords: function (t, e, r) { return this.x = t * Math.sin(e), this.y = r, this.z = t * Math.cos(e), this }, setFromMatrixPosition: function (t) { var e = t.elements; return this.x = e[12], this.y = e[13], this.z = e[14], this }, setFromMatrixScale: function (t) { var e = this.setFromMatrixColumn(t, 0).length(), r = this.setFromMatrixColumn(t, 1).length(), n = this.setFromMatrixColumn(t, 2).length(); return this.x = e, this.y = r, this.z = n, this }, setFromMatrixColumn: function (t, e) { return this.fromArray(t.elements, 4 * e) }, equals: function (t) { return t.x === this.x && t.y === this.y && t.z === this.z }, fromArray: function (t, e) { return void 0 === e && (e = 0), this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this }, toArray: function (t, e) { return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t }, fromBufferAttribute: function (t, e, r) { return void 0 !== r && console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."), this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this } }); var Ne, De = new Ie; function ze() { this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1], arguments.length > 0 && console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.") } Object.assign(ze.prototype, { isMatrix3: !0, set: function (t, e, r, n, i, o, a, s, c) { var l = this.elements; return l[0] = t, l[1] = n, l[2] = a, l[3] = e, l[4] = i, l[5] = s, l[6] = r, l[7] = o, l[8] = c, this }, identity: function () { return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this }, clone: function () { return (new this.constructor).fromArray(this.elements) }, copy: function (t) { var e = this.elements, r = t.elements; return e[0] = r[0], e[1] = r[1], e[2] = r[2], e[3] = r[3], e[4] = r[4], e[5] = r[5], e[6] = r[6], e[7] = r[7], e[8] = r[8], this }, setFromMatrix4: function (t) { var e = t.elements; return this.set(e[0], e[4], e[8], e[1], e[5], e[9], e[2], e[6], e[10]), this }, applyToBufferAttribute: function (t) { for (var e = 0, r = t.count; e < r; e++)De.x = t.getX(e), De.y = t.getY(e), De.z = t.getZ(e), De.applyMatrix3(this), t.setXYZ(e, De.x, De.y, De.z); return t }, multiply: function (t) { return this.multiplyMatrices(this, t) }, premultiply: function (t) { return this.multiplyMatrices(t, this) }, multiplyMatrices: function (t, e) { var r = t.elements, n = e.elements, i = this.elements, o = r[0], a = r[3], s = r[6], c = r[1], l = r[4], h = r[7], u = r[2], p = r[5], d = r[8], f = n[0], m = n[3], v = n[6], g = n[1], y = n[4], x = n[7], b = n[2], w = n[5], _ = n[8]; return i[0] = o * f + a * g + s * b, i[3] = o * m + a * y + s * w, i[6] = o * v + a * x + s * _, i[1] = c * f + l * g + h * b, i[4] = c * m + l * y + h * w, i[7] = c * v + l * x + h * _, i[2] = u * f + p * g + d * b, i[5] = u * m + p * y + d * w, i[8] = u * v + p * x + d * _, this }, multiplyScalar: function (t) { var e = this.elements; return e[0] *= t, e[3] *= t, e[6] *= t, e[1] *= t, e[4] *= t, e[7] *= t, e[2] *= t, e[5] *= t, e[8] *= t, this }, determinant: function () { var t = this.elements, e = t[0], r = t[1], n = t[2], i = t[3], o = t[4], a = t[5], s = t[6], c = t[7], l = t[8]; return e * o * l - e * a * c - r * i * l + r * a * s + n * i * c - n * o * s }, getInverse: function (t, e) { t && t.isMatrix4 && console.error("THREE.Matrix3: .getInverse() no longer takes a Matrix4 argument."); var r = t.elements, n = this.elements, i = r[0], o = r[1], a = r[2], s = r[3], c = r[4], l = r[5], h = r[6], u = r[7], p = r[8], d = p * c - l * u, f = l * h - p * s, m = u * s - c * h, v = i * d + o * f + a * m; if (0 === v) { var g = "THREE.Matrix3: .getInverse() can't invert matrix, determinant is 0"; if (!0 === e) throw new Error(g); return console.warn(g), this.identity() } var y = 1 / v; return n[0] = d * y, n[1] = (a * u - p * o) * y, n[2] = (l * o - a * c) * y, n[3] = f * y, n[4] = (p * i - a * h) * y, n[5] = (a * s - l * i) * y, n[6] = m * y, n[7] = (o * h - u * i) * y, n[8] = (c * i - o * s) * y, this }, transpose: function () { var t, e = this.elements; return t = e[1], e[1] = e[3], e[3] = t, t = e[2], e[2] = e[6], e[6] = t, t = e[5], e[5] = e[7], e[7] = t, this }, getNormalMatrix: function (t) { return this.setFromMatrix4(t).getInverse(this).transpose() }, transposeIntoArray: function (t) { var e = this.elements; return t[0] = e[0], t[1] = e[3], t[2] = e[6], t[3] = e[1], t[4] = e[4], t[5] = e[7], t[6] = e[2], t[7] = e[5], t[8] = e[8], this }, setUvTransform: function (t, e, r, n, i, o, a) { var s = Math.cos(i), c = Math.sin(i); this.set(r * s, r * c, -r * (s * o + c * a) + o + t, -n * c, n * s, -n * (-c * o + s * a) + a + e, 0, 0, 1) }, scale: function (t, e) { var r = this.elements; return r[0] *= t, r[3] *= t, r[6] *= t, r[1] *= e, r[4] *= e, r[7] *= e, this }, rotate: function (t) { var e = Math.cos(t), r = Math.sin(t), n = this.elements, i = n[0], o = n[3], a = n[6], s = n[1], c = n[4], l = n[7]; return n[0] = e * i + r * s, n[3] = e * o + r * c, n[6] = e * a + r * l, n[1] = -r * i + e * s, n[4] = -r * o + e * c, n[7] = -r * a + e * l, this }, translate: function (t, e) { var r = this.elements; return r[0] += t * r[2], r[3] += t * r[5], r[6] += t * r[8], r[1] += e * r[2], r[4] += e * r[5], r[7] += e * r[8], this }, equals: function (t) { for (var e = this.elements, r = t.elements, n = 0; n < 9; n++)if (e[n] !== r[n]) return !1; return !0 }, fromArray: function (t, e) { void 0 === e && (e = 0); for (var r = 0; r < 9; r++)this.elements[r] = t[r + e]; return this }, toArray: function (t, e) { void 0 === t && (t = []), void 0 === e && (e = 0); var r = this.elements; return t[e] = r[0], t[e + 1] = r[1], t[e + 2] = r[2], t[e + 3] = r[3], t[e + 4] = r[4], t[e + 5] = r[5], t[e + 6] = r[6], t[e + 7] = r[7], t[e + 8] = r[8], t } }); var Fe = { getDataURL: function (t) { var e; if ("undefined" == typeof HTMLCanvasElement) return t.src; if (t instanceof HTMLCanvasElement) e = t; else { void 0 === Ne && (Ne = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")), Ne.width = t.width, Ne.height = t.height; var r = Ne.getContext("2d"); t instanceof ImageData ? r.putImageData(t, 0, 0) : r.drawImage(t, 0, 0, t.width, t.height), e = Ne } return e.width > 2048 || e.height > 2048 ? e.toDataURL("image/jpeg", .6) : e.toDataURL("image/png") } }, Ue = 0; function Be(t, e, r, n, i, o, a, s, c, l) { Object.defineProperty(this, "id", { value: Ue++ }), this.uuid = Le.generateUUID(), this.name = "", this.image = void 0 !== t ? t : Be.DEFAULT_IMAGE, this.mipmaps = [], this.mapping = void 0 !== e ? e : Be.DEFAULT_MAPPING, this.wrapS = void 0 !== r ? r : ct, this.wrapT = void 0 !== n ? n : ct, this.magFilter = void 0 !== i ? i : dt, this.minFilter = void 0 !== o ? o : mt, this.anisotropy = void 0 !== c ? c : 1, this.format = void 0 !== a ? a : Rt, this.type = void 0 !== s ? s : vt, this.offset = new Pe(0, 0), this.repeat = new Pe(1, 1), this.center = new Pe(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new ze, this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.encoding = void 0 !== l ? l : he, this.version = 0, this.onUpdate = null } function ke(t, e, r, n) { this.x = t || 0, this.y = e || 0, this.z = r || 0, this.w = void 0 !== n ? n : 1 } function je(t, e, r) { this.width = t, this.height = e, this.scissor = new ke(0, 0, t, e), this.scissorTest = !1, this.viewport = new ke(0, 0, t, e), r = r || {}, this.texture = new Be(void 0, void 0, r.wrapS, r.wrapT, r.magFilter, r.minFilter, r.format, r.type, r.anisotropy, r.encoding), this.texture.image = {}, this.texture.image.width = t, this.texture.image.height = e, this.texture.generateMipmaps = void 0 !== r.generateMipmaps && r.generateMipmaps, this.texture.minFilter = void 0 !== r.minFilter ? r.minFilter : dt, this.depthBuffer = void 0 === r.depthBuffer || r.depthBuffer, this.stencilBuffer = void 0 === r.stencilBuffer || r.stencilBuffer, this.depthTexture = void 0 !== r.depthTexture ? r.depthTexture : null } function Ge(t, e, r) { je.call(this, t, e, r), this.samples = 4 } Be.DEFAULT_IMAGE = void 0, Be.DEFAULT_MAPPING = 300, Be.prototype = Object.assign(Object.create(Te.prototype), { constructor: Be, isTexture: !0, updateMatrix: function () { this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y) }, clone: function () { return (new this.constructor).copy(this) }, copy: function (t) { return this.name = t.name, this.image = t.image, this.mipmaps = t.mipmaps.slice(0), this.mapping = t.mapping, this.wrapS = t.wrapS, this.wrapT = t.wrapT, this.magFilter = t.magFilter, this.minFilter = t.minFilter, this.anisotropy = t.anisotropy, this.format = t.format, this.type = t.type, this.offset.copy(t.offset), this.repeat.copy(t.repeat), this.center.copy(t.center), this.rotation = t.rotation, this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrix.copy(t.matrix), this.generateMipmaps = t.generateMipmaps, this.premultiplyAlpha = t.premultiplyAlpha, this.flipY = t.flipY, this.unpackAlignment = t.unpackAlignment, this.encoding = t.encoding, this }, toJSON: function (t) { var e = void 0 === t || "string" == typeof t; if (!e && void 0 !== t.textures[this.uuid]) return t.textures[this.uuid]; var r = { metadata: { version: 4.5, type: "Texture", generator: "Texture.toJSON" }, uuid: this.uuid, name: this.name, mapping: this.mapping, repeat: [this.repeat.x, this.repeat.y], offset: [this.offset.x, this.offset.y], center: [this.center.x, this.center.y], rotation: this.rotation, wrap: [this.wrapS, this.wrapT], format: this.format, type: this.type, encoding: this.encoding, minFilter: this.minFilter, magFilter: this.magFilter, anisotropy: this.anisotropy, flipY: this.flipY, premultiplyAlpha: this.premultiplyAlpha, unpackAlignment: this.unpackAlignment }; if (void 0 !== this.image) { var n = this.image; if (void 0 === n.uuid && (n.uuid = Le.generateUUID()), !e && void 0 === t.images[n.uuid]) { var i; if (Array.isArray(n)) { i = []; for (var o = 0, a = n.length; o < a; o++)i.push(Fe.getDataURL(n[o])) } else i = Fe.getDataURL(n); t.images[n.uuid] = { uuid: n.uuid, url: i } } r.image = n.uuid } return e || (t.textures[this.uuid] = r), r }, dispose: function () { this.dispatchEvent({ type: "dispose" }) }, transformUv: function (t) { if (300 !== this.mapping) return t; if (t.applyMatrix3(this.matrix), t.x < 0 || t.x > 1) switch (this.wrapS) { case st: t.x = t.x - Math.floor(t.x); break; case ct: t.x = t.x < 0 ? 0 : 1; break; case lt: 1 === Math.abs(Math.floor(t.x) % 2) ? t.x = Math.ceil(t.x) - t.x : t.x = t.x - Math.floor(t.x) }if (t.y < 0 || t.y > 1) switch (this.wrapT) { case st: t.y = t.y - Math.floor(t.y); break; case ct: t.y = t.y < 0 ? 0 : 1; break; case lt: 1 === Math.abs(Math.floor(t.y) % 2) ? t.y = Math.ceil(t.y) - t.y : t.y = t.y - Math.floor(t.y) }return this.flipY && (t.y = 1 - t.y), t } }), Object.defineProperty(Be.prototype, "needsUpdate", { set: function (t) { !0 === t && this.version++ } }), Object.defineProperties(ke.prototype, { width: { get: function () { return this.z }, set: function (t) { this.z = t } }, height: { get: function () { return this.w }, set: function (t) { this.w = t } } }), Object.assign(ke.prototype, { isVector4: !0, set: function (t, e, r, n) { return this.x = t, this.y = e, this.z = r, this.w = n, this }, setScalar: function (t) { return this.x = t, this.y = t, this.z = t, this.w = t, this }, setX: function (t) { return this.x = t, this }, setY: function (t) { return this.y = t, this }, setZ: function (t) { return this.z = t, this }, setW: function (t) { return this.w = t, this }, setComponent: function (t, e) { switch (t) { case 0: this.x = e; break; case 1: this.y = e; break; case 2: this.z = e; break; case 3: this.w = e; break; default: throw new Error("index is out of range: " + t) }return this }, getComponent: function (t) { switch (t) { case 0: return this.x; case 1: return this.y; case 2: return this.z; case 3: return this.w; default: throw new Error("index is out of range: " + t) } }, clone: function () { return new this.constructor(this.x, this.y, this.z, this.w) }, copy: function (t) { return this.x = t.x, this.y = t.y, this.z = t.z, this.w = void 0 !== t.w ? t.w : 1, this }, add: function (t, e) { return void 0 !== e ? (console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this.z += t.z, this.w += t.w, this) }, addScalar: function (t) { return this.x += t, this.y += t, this.z += t, this.w += t, this }, addVectors: function (t, e) { return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this.w = t.w + e.w, this }, addScaledVector: function (t, e) { return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this.w += t.w * e, this }, sub: function (t, e) { return void 0 !== e ? (console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this.z -= t.z, this.w -= t.w, this) }, subScalar: function (t) { return this.x -= t, this.y -= t, this.z -= t, this.w -= t, this }, subVectors: function (t, e) { return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this.w = t.w - e.w, this }, multiplyScalar: function (t) { return this.x *= t, this.y *= t, this.z *= t, this.w *= t, this }, applyMatrix4: function (t) { var e = this.x, r = this.y, n = this.z, i = this.w, o = t.elements; return this.x = o[0] * e + o[4] * r + o[8] * n + o[12] * i, this.y = o[1] * e + o[5] * r + o[9] * n + o[13] * i, this.z = o[2] * e + o[6] * r + o[10] * n + o[14] * i, this.w = o[3] * e + o[7] * r + o[11] * n + o[15] * i, this }, divideScalar: function (t) { return this.multiplyScalar(1 / t) }, setAxisAngleFromQuaternion: function (t) { this.w = 2 * Math.acos(t.w); var e = Math.sqrt(1 - t.w * t.w); return e < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = t.x / e, this.y = t.y / e, this.z = t.z / e), this }, setAxisAngleFromRotationMatrix: function (t) { var e, r, n, i, o = t.elements, a = o[0], s = o[4], c = o[8], l = o[1], h = o[5], u = o[9], p = o[2], d = o[6], f = o[10]; if (Math.abs(s - l) < .01 && Math.abs(c - p) < .01 && Math.abs(u - d) < .01) { if (Math.abs(s + l) < .1 && Math.abs(c + p) < .1 && Math.abs(u + d) < .1 && Math.abs(a + h + f - 3) < .1) return this.set(1, 0, 0, 0), this; e = Math.PI; var m = (a + 1) / 2, v = (h + 1) / 2, g = (f + 1) / 2, y = (s + l) / 4, x = (c + p) / 4, b = (u + d) / 4; return m > v && m > g ? m < .01 ? (r = 0, n = .707106781, i = .707106781) : (n = y / (r = Math.sqrt(m)), i = x / r) : v > g ? v < .01 ? (r = .707106781, n = 0, i = .707106781) : (r = y / (n = Math.sqrt(v)), i = b / n) : g < .01 ? (r = .707106781, n = .707106781, i = 0) : (r = x / (i = Math.sqrt(g)), n = b / i), this.set(r, n, i, e), this } var w = Math.sqrt((d - u) * (d - u) + (c - p) * (c - p) + (l - s) * (l - s)); return Math.abs(w) < .001 && (w = 1), this.x = (d - u) / w, this.y = (c - p) / w, this.z = (l - s) / w, this.w = Math.acos((a + h + f - 1) / 2), this }, min: function (t) { return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this.w = Math.min(this.w, t.w), this }, max: function (t) { return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this.w = Math.max(this.w, t.w), this }, clamp: function (t, e) { return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this.w = Math.max(t.w, Math.min(e.w, this.w)), this }, clampScalar: function (t, e) { return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this.z = Math.max(t, Math.min(e, this.z)), this.w = Math.max(t, Math.min(e, this.w)), this }, clampLength: function (t, e) { var r = this.length(); return this.divideScalar(r || 1).multiplyScalar(Math.max(t, Math.min(e, r))) }, floor: function () { return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this }, ceil: function () { return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this }, round: function () { return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this }, roundToZero: function () { return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w), this }, negate: function () { return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this }, dot: function (t) { return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w }, lengthSq: function () { return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w }, length: function () { return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w) }, manhattanLength: function () { return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w) }, normalize: function () { return this.divideScalar(this.length() || 1) }, setLength: function (t) { return this.normalize().multiplyScalar(t) }, lerp: function (t, e) { return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this.w += (t.w - this.w) * e, this }, lerpVectors: function (t, e, r) { return this.subVectors(e, t).multiplyScalar(r).add(t) }, equals: function (t) { return t.x === this.x && t.y === this.y && t.z === this.z && t.w === this.w }, fromArray: function (t, e) { return void 0 === e && (e = 0), this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this.w = t[e + 3], this }, toArray: function (t, e) { return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t[e + 3] = this.w, t }, fromBufferAttribute: function (t, e, r) { return void 0 !== r && console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."), this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this.w = t.getW(e), this } }), je.prototype = Object.assign(Object.create(Te.prototype), { constructor: je, isWebGLRenderTarget: !0, setSize: function (t, e) { this.width === t && this.height === e || (this.width = t, this.height = e, this.texture.image.width = t, this.texture.image.height = e, this.dispose()), this.viewport.set(0, 0, t, e), this.scissor.set(0, 0, t, e) }, clone: function () { return (new this.constructor).copy(this) }, copy: function (t) { return this.width = t.width, this.height = t.height, this.viewport.copy(t.viewport), this.texture = t.texture.clone(), this.depthBuffer = t.depthBuffer, this.stencilBuffer = t.stencilBuffer, this.depthTexture = t.depthTexture, this }, dispose: function () { this.dispatchEvent({ type: "dispose" }) } }), Ge.prototype = Object.assign(Object.create(je.prototype), { constructor: Ge, isWebGLMultisampleRenderTarget: !0, copy: function (t) { return je.prototype.copy.call(this, t), this.samples = t.samples, this } }); var Ve = new Ie, He = new Je, We = new Ie(0, 0, 0), qe = new Ie(1, 1, 1), Xe = new Ie, Ye = new Ie, Ze = new Ie; function Je() { this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], arguments.length > 0 && console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.") } Object.assign(Je.prototype, { isMatrix4: !0, set: function (t, e, r, n, i, o, a, s, c, l, h, u, p, d, f, m) { var v = this.elements; return v[0] = t, v[4] = e, v[8] = r, v[12] = n, v[1] = i, v[5] = o, v[9] = a, v[13] = s, v[2] = c, v[6] = l, v[10] = h, v[14] = u, v[3] = p, v[7] = d, v[11] = f, v[15] = m, this }, identity: function () { return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this }, clone: function () { return (new Je).fromArray(this.elements) }, copy: function (t) { var e = this.elements, r = t.elements; return e[0] = r[0], e[1] = r[1], e[2] = r[2], e[3] = r[3], e[4] = r[4], e[5] = r[5], e[6] = r[6], e[7] = r[7], e[8] = r[8], e[9] = r[9], e[10] = r[10], e[11] = r[11], e[12] = r[12], e[13] = r[13], e[14] = r[14], e[15] = r[15], this }, copyPosition: function (t) { var e = this.elements, r = t.elements; return e[12] = r[12], e[13] = r[13], e[14] = r[14], this }, extractBasis: function (t, e, r) { return t.setFromMatrixColumn(this, 0), e.setFromMatrixColumn(this, 1), r.setFromMatrixColumn(this, 2), this }, makeBasis: function (t, e, r) { return this.set(t.x, e.x, r.x, 0, t.y, e.y, r.y, 0, t.z, e.z, r.z, 0, 0, 0, 0, 1), this }, extractRotation: function (t) { var e = this.elements, r = t.elements, n = 1 / Ve.setFromMatrixColumn(t, 0).length(), i = 1 / Ve.setFromMatrixColumn(t, 1).length(), o = 1 / Ve.setFromMatrixColumn(t, 2).length(); return e[0] = r[0] * n, e[1] = r[1] * n, e[2] = r[2] * n, e[3] = 0, e[4] = r[4] * i, e[5] = r[5] * i, e[6] = r[6] * i, e[7] = 0, e[8] = r[8] * o, e[9] = r[9] * o, e[10] = r[10] * o, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this }, makeRotationFromEuler: function (t) { t && t.isEuler || console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order."); var e = this.elements, r = t.x, n = t.y, i = t.z, o = Math.cos(r), a = Math.sin(r), s = Math.cos(n), c = Math.sin(n), l = Math.cos(i), h = Math.sin(i); if ("XYZ" === t.order) { var u = o * l, p = o * h, d = a * l, f = a * h; e[0] = s * l, e[4] = -s * h, e[8] = c, e[1] = p + d * c, e[5] = u - f * c, e[9] = -a * s, e[2] = f - u * c, e[6] = d + p * c, e[10] = o * s } else if ("YXZ" === t.order) { var m = s * l, v = s * h, g = c * l, y = c * h; e[0] = m + y * a, e[4] = g * a - v, e[8] = o * c, e[1] = o * h, e[5] = o * l, e[9] = -a, e[2] = v * a - g, e[6] = y + m * a, e[10] = o * s } else if ("ZXY" === t.order) { m = s * l, v = s * h, g = c * l, y = c * h; e[0] = m - y * a, e[4] = -o * h, e[8] = g + v * a, e[1] = v + g * a, e[5] = o * l, e[9] = y - m * a, e[2] = -o * c, e[6] = a, e[10] = o * s } else if ("ZYX" === t.order) { u = o * l, p = o * h, d = a * l, f = a * h; e[0] = s * l, e[4] = d * c - p, e[8] = u * c + f, e[1] = s * h, e[5] = f * c + u, e[9] = p * c - d, e[2] = -c, e[6] = a * s, e[10] = o * s } else if ("YZX" === t.order) { var x = o * s, b = o * c, w = a * s, _ = a * c; e[0] = s * l, e[4] = _ - x * h, e[8] = w * h + b, e[1] = h, e[5] = o * l, e[9] = -a * l, e[2] = -c * l, e[6] = b * h + w, e[10] = x - _ * h } else if ("XZY" === t.order) { x = o * s, b = o * c, w = a * s, _ = a * c; e[0] = s * l, e[4] = -h, e[8] = c * l, e[1] = x * h + _, e[5] = o * l, e[9] = b * h - w, e[2] = w * h - b, e[6] = a * l, e[10] = _ * h + x } return e[3] = 0, e[7] = 0, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this }, makeRotationFromQuaternion: function (t) { return this.compose(We, t, qe) }, lookAt: function (t, e, r) { var n = this.elements; return Ze.subVectors(t, e), 0 === Ze.lengthSq() && (Ze.z = 1), Ze.normalize(), Xe.crossVectors(r, Ze), 0 === Xe.lengthSq() && (1 === Math.abs(r.z) ? Ze.x += 1e-4 : Ze.z += 1e-4, Ze.normalize(), Xe.crossVectors(r, Ze)), Xe.normalize(), Ye.crossVectors(Ze, Xe), n[0] = Xe.x, n[4] = Ye.x, n[8] = Ze.x, n[1] = Xe.y, n[5] = Ye.y, n[9] = Ze.y, n[2] = Xe.z, n[6] = Ye.z, n[10] = Ze.z, this }, multiply: function (t, e) { return void 0 !== e ? (console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."), this.multiplyMatrices(t, e)) : this.multiplyMatrices(this, t) }, premultiply: function (t) { return this.multiplyMatrices(t, this) }, multiplyMatrices: function (t, e) { var r = t.elements, n = e.elements, i = this.elements, o = r[0], a = r[4], s = r[8], c = r[12], l = r[1], h = r[5], u = r[9], p = r[13], d = r[2], f = r[6], m = r[10], v = r[14], g = r[3], y = r[7], x = r[11], b = r[15], w = n[0], _ = n[4], M = n[8], S = n[12], T = n[1], E = n[5], A = n[9], L = n[13], P = n[2], R = n[6], C = n[10], O = n[14], I = n[3], N = n[7], D = n[11], z = n[15]; return i[0] = o * w + a * T + s * P + c * I, i[4] = o * _ + a * E + s * R + c * N, i[8] = o * M + a * A + s * C + c * D, i[12] = o * S + a * L + s * O + c * z, i[1] = l * w + h * T + u * P + p * I, i[5] = l * _ + h * E + u * R + p * N, i[9] = l * M + h * A + u * C + p * D, i[13] = l * S + h * L + u * O + p * z, i[2] = d * w + f * T + m * P + v * I, i[6] = d * _ + f * E + m * R + v * N, i[10] = d * M + f * A + m * C + v * D, i[14] = d * S + f * L + m * O + v * z, i[3] = g * w + y * T + x * P + b * I, i[7] = g * _ + y * E + x * R + b * N, i[11] = g * M + y * A + x * C + b * D, i[15] = g * S + y * L + x * O + b * z, this }, multiplyScalar: function (t) { var e = this.elements; return e[0] *= t, e[4] *= t, e[8] *= t, e[12] *= t, e[1] *= t, e[5] *= t, e[9] *= t, e[13] *= t, e[2] *= t, e[6] *= t, e[10] *= t, e[14] *= t, e[3] *= t, e[7] *= t, e[11] *= t, e[15] *= t, this }, applyToBufferAttribute: function (t) { for (var e = 0, r = t.count; e < r; e++)Ve.x = t.getX(e), Ve.y = t.getY(e), Ve.z = t.getZ(e), Ve.applyMatrix4(this), t.setXYZ(e, Ve.x, Ve.y, Ve.z); return t }, determinant: function () { var t = this.elements, e = t[0], r = t[4], n = t[8], i = t[12], o = t[1], a = t[5], s = t[9], c = t[13], l = t[2], h = t[6], u = t[10], p = t[14]; return t[3] * (+i * s * h - n * c * h - i * a * u + r * c * u + n * a * p - r * s * p) + t[7] * (+e * s * p - e * c * u + i * o * u - n * o * p + n * c * l - i * s * l) + t[11] * (+e * c * h - e * a * p - i * o * h + r * o * p + i * a * l - r * c * l) + t[15] * (-n * a * l - e * s * h + e * a * u + n * o * h - r * o * u + r * s * l) }, transpose: function () { var t, e = this.elements; return t = e[1], e[1] = e[4], e[4] = t, t = e[2], e[2] = e[8], e[8] = t, t = e[6], e[6] = e[9], e[9] = t, t = e[3], e[3] = e[12], e[12] = t, t = e[7], e[7] = e[13], e[13] = t, t = e[11], e[11] = e[14], e[14] = t, this }, setPosition: function (t, e, r) { var n = this.elements; return t.isVector3 ? (n[12] = t.x, n[13] = t.y, n[14] = t.z) : (n[12] = t, n[13] = e, n[14] = r), this }, getInverse: function (t, e) { var r = this.elements, n = t.elements, i = n[0], o = n[1], a = n[2], s = n[3], c = n[4], l = n[5], h = n[6], u = n[7], p = n[8], d = n[9], f = n[10], m = n[11], v = n[12], g = n[13], y = n[14], x = n[15], b = d * y * u - g * f * u + g * h * m - l * y * m - d * h * x + l * f * x, w = v * f * u - p * y * u - v * h * m + c * y * m + p * h * x - c * f * x, _ = p * g * u - v * d * u + v * l * m - c * g * m - p * l * x + c * d * x, M = v * d * h - p * g * h - v * l * f + c * g * f + p * l * y - c * d * y, S = i * b + o * w + a * _ + s * M; if (0 === S) { var T = "THREE.Matrix4: .getInverse() can't invert matrix, determinant is 0"; if (!0 === e) throw new Error(T); return console.warn(T), this.identity() } var E = 1 / S; return r[0] = b * E, r[1] = (g * f * s - d * y * s - g * a * m + o * y * m + d * a * x - o * f * x) * E, r[2] = (l * y * s - g * h * s + g * a * u - o * y * u - l * a * x + o * h * x) * E, r[3] = (d * h * s - l * f * s - d * a * u + o * f * u + l * a * m - o * h * m) * E, r[4] = w * E, r[5] = (p * y * s - v * f * s + v * a * m - i * y * m - p * a * x + i * f * x) * E, r[6] = (v * h * s - c * y * s - v * a * u + i * y * u + c * a * x - i * h * x) * E, r[7] = (c * f * s - p * h * s + p * a * u - i * f * u - c * a * m + i * h * m) * E, r[8] = _ * E, r[9] = (v * d * s - p * g * s - v * o * m + i * g * m + p * o * x - i * d * x) * E, r[10] = (c * g * s - v * l * s + v * o * u - i * g * u - c * o * x + i * l * x) * E, r[11] = (p * l * s - c * d * s - p * o * u + i * d * u + c * o * m - i * l * m) * E, r[12] = M * E, r[13] = (p * g * a - v * d * a + v * o * f - i * g * f - p * o * y + i * d * y) * E, r[14] = (v * l * a - c * g * a - v * o * h + i * g * h + c * o * y - i * l * y) * E, r[15] = (c * d * a - p * l * a + p * o * h - i * d * h - c * o * f + i * l * f) * E, this }, scale: function (t) { var e = this.elements, r = t.x, n = t.y, i = t.z; return e[0] *= r, e[4] *= n, e[8] *= i, e[1] *= r, e[5] *= n, e[9] *= i, e[2] *= r, e[6] *= n, e[10] *= i, e[3] *= r, e[7] *= n, e[11] *= i, this }, getMaxScaleOnAxis: function () { var t = this.elements, e = t[0] * t[0] + t[1] * t[1] + t[2] * t[2], r = t[4] * t[4] + t[5] * t[5] + t[6] * t[6], n = t[8] * t[8] + t[9] * t[9] + t[10] * t[10]; return Math.sqrt(Math.max(e, r, n)) }, makeTranslation: function (t, e, r) { return this.set(1, 0, 0, t, 0, 1, 0, e, 0, 0, 1, r, 0, 0, 0, 1), this }, makeRotationX: function (t) { var e = Math.cos(t), r = Math.sin(t); return this.set(1, 0, 0, 0, 0, e, -r, 0, 0, r, e, 0, 0, 0, 0, 1), this }, makeRotationY: function (t) { var e = Math.cos(t), r = Math.sin(t); return this.set(e, 0, r, 0, 0, 1, 0, 0, -r, 0, e, 0, 0, 0, 0, 1), this }, makeRotationZ: function (t) { var e = Math.cos(t), r = Math.sin(t); return this.set(e, -r, 0, 0, r, e, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this }, makeRotationAxis: function (t, e) { var r = Math.cos(e), n = Math.sin(e), i = 1 - r, o = t.x, a = t.y, s = t.z, c = i * o, l = i * a; return this.set(c * o + r, c * a - n * s, c * s + n * a, 0, c * a + n * s, l * a + r, l * s - n * o, 0, c * s - n * a, l * s + n * o, i * s * s + r, 0, 0, 0, 0, 1), this }, makeScale: function (t, e, r) { return this.set(t, 0, 0, 0, 0, e, 0, 0, 0, 0, r, 0, 0, 0, 0, 1), this }, makeShear: function (t, e, r) { return this.set(1, e, r, 0, t, 1, r, 0, t, e, 1, 0, 0, 0, 0, 1), this }, compose: function (t, e, r) { var n = this.elements, i = e._x, o = e._y, a = e._z, s = e._w, c = i + i, l = o + o, h = a + a, u = i * c, p = i * l, d = i * h, f = o * l, m = o * h, v = a * h, g = s * c, y = s * l, x = s * h, b = r.x, w = r.y, _ = r.z; return n[0] = (1 - (f + v)) * b, n[1] = (p + x) * b, n[2] = (d - y) * b, n[3] = 0, n[4] = (p - x) * w, n[5] = (1 - (u + v)) * w, n[6] = (m + g) * w, n[7] = 0, n[8] = (d + y) * _, n[9] = (m - g) * _, n[10] = (1 - (u + f)) * _, n[11] = 0, n[12] = t.x, n[13] = t.y, n[14] = t.z, n[15] = 1, this }, decompose: function (t, e, r) { var n = this.elements, i = Ve.set(n[0], n[1], n[2]).length(), o = Ve.set(n[4], n[5], n[6]).length(), a = Ve.set(n[8], n[9], n[10]).length(); this.determinant() < 0 && (i = -i), t.x = n[12], t.y = n[13], t.z = n[14], He.copy(this); var s = 1 / i, c = 1 / o, l = 1 / a; return He.elements[0] *= s, He.elements[1] *= s, He.elements[2] *= s, He.elements[4] *= c, He.elements[5] *= c, He.elements[6] *= c, He.elements[8] *= l, He.elements[9] *= l, He.elements[10] *= l, e.setFromRotationMatrix(He), r.x = i, r.y = o, r.z = a, this }, makePerspective: function (t, e, r, n, i, o) { void 0 === o && console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs."); var a = this.elements, s = 2 * i / (e - t), c = 2 * i / (r - n), l = (e + t) / (e - t), h = (r + n) / (r - n), u = -(o + i) / (o - i), p = -2 * o * i / (o - i); return a[0] = s, a[4] = 0, a[8] = l, a[12] = 0, a[1] = 0, a[5] = c, a[9] = h, a[13] = 0, a[2] = 0, a[6] = 0, a[10] = u, a[14] = p, a[3] = 0, a[7] = 0, a[11] = -1, a[15] = 0, this }, makeOrthographic: function (t, e, r, n, i, o) { var a = this.elements, s = 1 / (e - t), c = 1 / (r - n), l = 1 / (o - i), h = (e + t) * s, u = (r + n) * c, p = (o + i) * l; return a[0] = 2 * s, a[4] = 0, a[8] = 0, a[12] = -h, a[1] = 0, a[5] = 2 * c, a[9] = 0, a[13] = -u, a[2] = 0, a[6] = 0, a[10] = -2 * l, a[14] = -p, a[3] = 0, a[7] = 0, a[11] = 0, a[15] = 1, this }, equals: function (t) { for (var e = this.elements, r = t.elements, n = 0; n < 16; n++)if (e[n] !== r[n]) return !1; return !0 }, fromArray: function (t, e) { void 0 === e && (e = 0); for (var r = 0; r < 16; r++)this.elements[r] = t[r + e]; return this }, toArray: function (t, e) { void 0 === t && (t = []), void 0 === e && (e = 0); var r = this.elements; return t[e] = r[0], t[e + 1] = r[1], t[e + 2] = r[2], t[e + 3] = r[3], t[e + 4] = r[4], t[e + 5] = r[5], t[e + 6] = r[6], t[e + 7] = r[7], t[e + 8] = r[8], t[e + 9] = r[9], t[e + 10] = r[10], t[e + 11] = r[11], t[e + 12] = r[12], t[e + 13] = r[13], t[e + 14] = r[14], t[e + 15] = r[15], t } }); var Ke = new Je, Qe = new Re; function $e(t, e, r, n) { this._x = t || 0, this._y = e || 0, this._z = r || 0, this._order = n || $e.DefaultOrder } function tr() { this.mask = 1 } $e.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"], $e.DefaultOrder = "XYZ", Object.defineProperties($e.prototype, { x: { get: function () { return this._x }, set: function (t) { this._x = t, this._onChangeCallback() } }, y: { get: function () { return this._y }, set: function (t) { this._y = t, this._onChangeCallback() } }, z: { get: function () { return this._z }, set: function (t) { this._z = t, this._onChangeCallback() } }, order: { get: function () { return this._order }, set: function (t) { this._order = t, this._onChangeCallback() } } }), Object.assign($e.prototype, { isEuler: !0, set: function (t, e, r, n) { return this._x = t, this._y = e, this._z = r, this._order = n || this._order, this._onChangeCallback(), this }, clone: function () { return new this.constructor(this._x, this._y, this._z, this._order) }, copy: function (t) { return this._x = t._x, this._y = t._y, this._z = t._z, this._order = t._order, this._onChangeCallback(), this }, setFromRotationMatrix: function (t, e, r) { var n = Le.clamp, i = t.elements, o = i[0], a = i[4], s = i[8], c = i[1], l = i[5], h = i[9], u = i[2], p = i[6], d = i[10]; return "XYZ" === (e = e || this._order) ? (this._y = Math.asin(n(s, -1, 1)), Math.abs(s) < .9999999 ? (this._x = Math.atan2(-h, d), this._z = Math.atan2(-a, o)) : (this._x = Math.atan2(p, l), this._z = 0)) : "YXZ" === e ? (this._x = Math.asin(-n(h, -1, 1)), Math.abs(h) < .9999999 ? (this._y = Math.atan2(s, d), this._z = Math.atan2(c, l)) : (this._y = Math.atan2(-u, o), this._z = 0)) : "ZXY" === e ? (this._x = Math.asin(n(p, -1, 1)), Math.abs(p) < .9999999 ? (this._y = Math.atan2(-u, d), this._z = Math.atan2(-a, l)) : (this._y = 0, this._z = Math.atan2(c, o))) : "ZYX" === e ? (this._y = Math.asin(-n(u, -1, 1)), Math.abs(u) < .9999999 ? (this._x = Math.atan2(p, d), this._z = Math.atan2(c, o)) : (this._x = 0, this._z = Math.atan2(-a, l))) : "YZX" === e ? (this._z = Math.asin(n(c, -1, 1)), Math.abs(c) < .9999999 ? (this._x = Math.atan2(-h, l), this._y = Math.atan2(-u, o)) : (this._x = 0, this._y = Math.atan2(s, d))) : "XZY" === e ? (this._z = Math.asin(-n(a, -1, 1)), Math.abs(a) < .9999999 ? (this._x = Math.atan2(p, l), this._y = Math.atan2(s, o)) : (this._x = Math.atan2(-h, d), this._y = 0)) : console.warn("THREE.Euler: .setFromRotationMatrix() given unsupported order: " + e), this._order = e, !1 !== r && this._onChangeCallback(), this }, setFromQuaternion: function (t, e, r) { return Ke.makeRotationFromQuaternion(t), this.setFromRotationMatrix(Ke, e, r) }, setFromVector3: function (t, e) { return this.set(t.x, t.y, t.z, e || this._order) }, reorder: function (t) { return Qe.setFromEuler(this), this.setFromQuaternion(Qe, t) }, equals: function (t) { return t._x === this._x && t._y === this._y && t._z === this._z && t._order === this._order }, fromArray: function (t) { return this._x = t[0], this._y = t[1], this._z = t[2], void 0 !== t[3] && (this._order = t[3]), this._onChangeCallback(), this }, toArray: function (t, e) { return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._order, t }, toVector3: function (t) { return t ? t.set(this._x, this._y, this._z) : new Ie(this._x, this._y, this._z) }, _onChange: function (t) { return this._onChangeCallback = t, this }, _onChangeCallback: function () { } }), Object.assign(tr.prototype, { set: function (t) { this.mask = 1 << t | 0 }, enable: function (t) { this.mask |= 1 << t | 0 }, enableAll: function () { this.mask = -1 }, toggle: function (t) { this.mask ^= 1 << t | 0 }, disable: function (t) { this.mask &= ~(1 << t | 0) }, disableAll: function () { this.mask = 0 }, test: function (t) { return 0 != (this.mask & t.mask) } }); var er = 0, rr = new Ie, nr = new Re, ir = new Je, or = new Ie, ar = new Ie, sr = new Ie, cr = new Re, lr = new Ie(1, 0, 0), hr = new Ie(0, 1, 0), ur = new Ie(0, 0, 1), pr = { type: "added" }, dr = { type: "removed" }; function fr() { Object.defineProperty(this, "id", { value: er++ }), this.uuid = Le.generateUUID(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = fr.DefaultUp.clone(); var t = new Ie, e = new $e, r = new Re, n = new Ie(1, 1, 1); e._onChange((function () { r.setFromEuler(e, !1) })), r._onChange((function () { e.setFromQuaternion(r, void 0, !1) })), Object.defineProperties(this, { position: { configurable: !0, enumerable: !0, value: t }, rotation: { configurable: !0, enumerable: !0, value: e }, quaternion: { configurable: !0, enumerable: !0, value: r }, scale: { configurable: !0, enumerable: !0, value: n }, modelViewMatrix: { value: new Je }, normalMatrix: { value: new ze } }), this.matrix = new Je, this.matrixWorld = new Je, this.matrixAutoUpdate = fr.DefaultMatrixAutoUpdate, this.matrixWorldNeedsUpdate = !1, this.layers = new tr, this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.userData = {} } function mr() { fr.call(this), this.type = "Scene", this.background = null, this.fog = null, this.overrideMaterial = null, this.autoUpdate = !0, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this })) } fr.DefaultUp = new Ie(0, 1, 0), fr.DefaultMatrixAutoUpdate = !0, fr.prototype = Object.assign(Object.create(Te.prototype), { constructor: fr, isObject3D: !0, onBeforeRender: function () { }, onAfterRender: function () { }, applyMatrix: function (t) { this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(t), this.matrix.decompose(this.position, this.quaternion, this.scale) }, applyQuaternion: function (t) { return this.quaternion.premultiply(t), this }, setRotationFromAxisAngle: function (t, e) { this.quaternion.setFromAxisAngle(t, e) }, setRotationFromEuler: function (t) { this.quaternion.setFromEuler(t, !0) }, setRotationFromMatrix: function (t) { this.quaternion.setFromRotationMatrix(t) }, setRotationFromQuaternion: function (t) { this.quaternion.copy(t) }, rotateOnAxis: function (t, e) { return nr.setFromAxisAngle(t, e), this.quaternion.multiply(nr), this }, rotateOnWorldAxis: function (t, e) { return nr.setFromAxisAngle(t, e), this.quaternion.premultiply(nr), this }, rotateX: function (t) { return this.rotateOnAxis(lr, t) }, rotateY: function (t) { return this.rotateOnAxis(hr, t) }, rotateZ: function (t) { return this.rotateOnAxis(ur, t) }, translateOnAxis: function (t, e) { return rr.copy(t).applyQuaternion(this.quaternion), this.position.add(rr.multiplyScalar(e)), this }, translateX: function (t) { return this.translateOnAxis(lr, t) }, translateY: function (t) { return this.translateOnAxis(hr, t) }, translateZ: function (t) { return this.translateOnAxis(ur, t) }, localToWorld: function (t) { return t.applyMatrix4(this.matrixWorld) }, worldToLocal: function (t) { return t.applyMatrix4(ir.getInverse(this.matrixWorld)) }, lookAt: function (t, e, r) { t.isVector3 ? or.copy(t) : or.set(t, e, r); var n = this.parent; this.updateWorldMatrix(!0, !1), ar.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? ir.lookAt(ar, or, this.up) : ir.lookAt(or, ar, this.up), this.quaternion.setFromRotationMatrix(ir), n && (ir.extractRotation(n.matrixWorld), nr.setFromRotationMatrix(ir), this.quaternion.premultiply(nr.inverse())) }, add: function (t) { if (arguments.length > 1) { for (var e = 0; e < arguments.length; e++)this.add(arguments[e]); return this } return t === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", t), this) : (t && t.isObject3D ? (null !== t.parent && t.parent.remove(t), t.parent = this, this.children.push(t), t.dispatchEvent(pr)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", t), this) }, remove: function (t) { if (arguments.length > 1) { for (var e = 0; e < arguments.length; e++)this.remove(arguments[e]); return this } var r = this.children.indexOf(t); return -1 !== r && (t.parent = null, this.children.splice(r, 1), t.dispatchEvent(dr)), this }, attach: function (t) { return this.updateWorldMatrix(!0, !1), ir.getInverse(this.matrixWorld), null !== t.parent && (t.parent.updateWorldMatrix(!0, !1), ir.multiply(t.parent.matrixWorld)), t.applyMatrix(ir), t.updateWorldMatrix(!1, !1), this.add(t), this }, getObjectById: function (t) { return this.getObjectByProperty("id", t) }, getObjectByName: function (t) { return this.getObjectByProperty("name", t) }, getObjectByProperty: function (t, e) { if (this[t] === e) return this; for (var r = 0, n = this.children.length; r < n; r++) { var i = this.children[r].getObjectByProperty(t, e); if (void 0 !== i) return i } }, getWorldPosition: function (t) { return void 0 === t && (console.warn("THREE.Object3D: .getWorldPosition() target is now required"), t = new Ie), this.updateMatrixWorld(!0), t.setFromMatrixPosition(this.matrixWorld) }, getWorldQuaternion: function (t) { return void 0 === t && (console.warn("THREE.Object3D: .getWorldQuaternion() target is now required"), t = new Re), this.updateMatrixWorld(!0), this.matrixWorld.decompose(ar, t, sr), t }, getWorldScale: function (t) { return void 0 === t && (console.warn("THREE.Object3D: .getWorldScale() target is now required"), t = new Ie), this.updateMatrixWorld(!0), this.matrixWorld.decompose(ar, cr, t), t }, getWorldDirection: function (t) { void 0 === t && (console.warn("THREE.Object3D: .getWorldDirection() target is now required"), t = new Ie), this.updateMatrixWorld(!0); var e = this.matrixWorld.elements; return t.set(e[8], e[9], e[10]).normalize() }, raycast: function () { }, traverse: function (t) { t(this); for (var e = this.children, r = 0, n = e.length; r < n; r++)e[r].traverse(t) }, traverseVisible: function (t) { if (!1 !== this.visible) { t(this); for (var e = this.children, r = 0, n = e.length; r < n; r++)e[r].traverseVisible(t) } }, traverseAncestors: function (t) { var e = this.parent; null !== e && (t(e), e.traverseAncestors(t)) }, updateMatrix: function () { this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0 }, updateMatrixWorld: function (t) { this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || t) && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, t = !0); for (var e = this.children, r = 0, n = e.length; r < n; r++)e[r].updateMatrixWorld(t) }, updateWorldMatrix: function (t, e) { var r = this.parent; if (!0 === t && null !== r && r.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), !0 === e) for (var n = this.children, i = 0, o = n.length; i < o; i++)n[i].updateWorldMatrix(!1, !0) }, toJSON: function (t) { var e = void 0 === t || "string" == typeof t, r = {}; e && (t = { geometries: {}, materials: {}, textures: {}, images: {}, shapes: {} }, r.metadata = { version: 4.5, type: "Object", generator: "Object3D.toJSON" }); var n = {}; function i(e, r) { return void 0 === e[r.uuid] && (e[r.uuid] = r.toJSON(t)), r.uuid } if (n.uuid = this.uuid, n.type = this.type, "" !== this.name && (n.name = this.name), !0 === this.castShadow && (n.castShadow = !0), !0 === this.receiveShadow && (n.receiveShadow = !0), !1 === this.visible && (n.visible = !1), !1 === this.frustumCulled && (n.frustumCulled = !1), 0 !== this.renderOrder && (n.renderOrder = this.renderOrder), "{}" !== JSON.stringify(this.userData) && (n.userData = this.userData), n.layers = this.layers.mask, n.matrix = this.matrix.toArray(), !1 === this.matrixAutoUpdate && (n.matrixAutoUpdate = !1), this.isMesh && this.drawMode !== se && (n.drawMode = this.drawMode), this.isInstancedMesh && (n.type = "InstancedMesh", n.count = this.count, n.instanceMatrix = this.instanceMatrix.toJSON()), this.isMesh || this.isLine || this.isPoints) { n.geometry = i(t.geometries, this.geometry); var o = this.geometry.parameters; if (void 0 !== o && void 0 !== o.shapes) { var a = o.shapes; if (Array.isArray(a)) for (var s = 0, c = a.length; s < c; s++) { var l = a[s]; i(t.shapes, l) } else i(t.shapes, a) } } if (void 0 !== this.material) if (Array.isArray(this.material)) { var h = []; for (s = 0, c = this.material.length; s < c; s++)h.push(i(t.materials, this.material[s])); n.material = h } else n.material = i(t.materials, this.material); if (this.children.length > 0) { n.children = []; for (s = 0; s < this.children.length; s++)n.children.push(this.children[s].toJSON(t).object) } if (e) { var u = m(t.geometries), p = m(t.materials), d = m(t.textures), f = m(t.images); a = m(t.shapes); u.length > 0 && (r.geometries = u), p.length > 0 && (r.materials = p), d.length > 0 && (r.textures = d), f.length > 0 && (r.images = f), a.length > 0 && (r.shapes = a) } return r.object = n, r; function m(t) { var e = []; for (var r in t) { var n = t[r]; delete n.metadata, e.push(n) } return e } }, clone: function (t) { return (new this.constructor).copy(this, t) }, copy: function (t, e) { if (void 0 === e && (e = !0), this.name = t.name, this.up.copy(t.up), this.position.copy(t.position), this.quaternion.copy(t.quaternion), this.scale.copy(t.scale), this.matrix.copy(t.matrix), this.matrixWorld.copy(t.matrixWorld), this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrixWorldNeedsUpdate = t.matrixWorldNeedsUpdate, this.layers.mask = t.layers.mask, this.visible = t.visible, this.castShadow = t.castShadow, this.receiveShadow = t.receiveShadow, this.frustumCulled = t.frustumCulled, this.renderOrder = t.renderOrder, this.userData = JSON.parse(JSON.stringify(t.userData)), !0 === e) for (var r = 0; r < t.children.length; r++) { var n = t.children[r]; this.add(n.clone()) } return this } }), mr.prototype = Object.assign(Object.create(fr.prototype), { constructor: mr, isScene: !0, copy: function (t, e) { return fr.prototype.copy.call(this, t, e), null !== t.background && (this.background = t.background.clone()), null !== t.fog && (this.fog = t.fog.clone()), null !== t.overrideMaterial && (this.overrideMaterial = t.overrideMaterial.clone()), this.autoUpdate = t.autoUpdate, this.matrixAutoUpdate = t.matrixAutoUpdate, this }, toJSON: function (t) { var e = fr.prototype.toJSON.call(this, t); return null !== this.background && (e.object.background = this.background.toJSON(t)), null !== this.fog && (e.object.fog = this.fog.toJSON()), e }, dispose: function () { this.dispatchEvent({ type: "dispose" }) } }); var vr = [new Ie, new Ie, new Ie, new Ie, new Ie, new Ie, new Ie, new Ie], gr = new Ie, yr = new Pr, xr = new Ie, br = new Ie, wr = new Ie, _r = new Ie, Mr = new Ie, Sr = new Ie, Tr = new Ie, Er = new Ie, Ar = new Ie, Lr = new Ie; function Pr(t, e) { this.min = void 0 !== t ? t : new Ie(1 / 0, 1 / 0, 1 / 0), this.max = void 0 !== e ? e : new Ie(-1 / 0, -1 / 0, -1 / 0) } function Rr(t, e, r, n, i) { var o, a; for (o = 0, a = t.length - 3; o <= a; o += 3) { Lr.fromArray(t, o); var s = i.x * Math.abs(Lr.x) + i.y * Math.abs(Lr.y) + i.z * Math.abs(Lr.z), c = e.dot(Lr), l = r.dot(Lr), h = n.dot(Lr); if (Math.max(-Math.max(c, l, h), Math.min(c, l, h)) > s) return !1 } return !0 } Object.assign(Pr.prototype, { isBox3: !0, set: function (t, e) { return this.min.copy(t), this.max.copy(e), this }, setFromArray: function (t) { for (var e = 1 / 0, r = 1 / 0, n = 1 / 0, i = -1 / 0, o = -1 / 0, a = -1 / 0, s = 0, c = t.length; s < c; s += 3) { var l = t[s], h = t[s + 1], u = t[s + 2]; l < e && (e = l), h < r && (r = h), u < n && (n = u), l > i && (i = l), h > o && (o = h), u > a && (a = u) } return this.min.set(e, r, n), this.max.set(i, o, a), this }, setFromBufferAttribute: function (t) { for (var e = 1 / 0, r = 1 / 0, n = 1 / 0, i = -1 / 0, o = -1 / 0, a = -1 / 0, s = 0, c = t.count; s < c; s++) { var l = t.getX(s), h = t.getY(s), u = t.getZ(s); l < e && (e = l), h < r && (r = h), u < n && (n = u), l > i && (i = l), h > o && (o = h), u > a && (a = u) } return this.min.set(e, r, n), this.max.set(i, o, a), this }, setFromPoints: function (t) { this.makeEmpty(); for (var e = 0, r = t.length; e < r; e++)this.expandByPoint(t[e]); return this }, setFromCenterAndSize: function (t, e) { var r = gr.copy(e).multiplyScalar(.5); return this.min.copy(t).sub(r), this.max.copy(t).add(r), this }, setFromObject: function (t) { return this.makeEmpty(), this.expandByObject(t) }, clone: function () { return (new this.constructor).copy(this) }, copy: function (t) { return this.min.copy(t.min), this.max.copy(t.max), this }, makeEmpty: function () { return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this }, isEmpty: function () { return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z }, getCenter: function (t) { return void 0 === t && (console.warn("THREE.Box3: .getCenter() target is now required"), t = new Ie), this.isEmpty() ? t.set(0, 0, 0) : t.addVectors(this.min, this.max).multiplyScalar(.5) }, getSize: function (t) { return void 0 === t && (console.warn("THREE.Box3: .getSize() target is now required"), t = new Ie), this.isEmpty() ? t.set(0, 0, 0) : t.subVectors(this.max, this.min) }, expandByPoint: function (t) { return this.min.min(t), this.max.max(t), this }, expandByVector: function (t) { return this.min.sub(t), this.max.add(t), this }, expandByScalar: function (t) { return this.min.addScalar(-t), this.max.addScalar(t), this }, expandByObject: function (t) { t.updateWorldMatrix(!1, !1); var e = t.geometry; void 0 !== e && (null === e.boundingBox && e.computeBoundingBox(), yr.copy(e.boundingBox), yr.applyMatrix4(t.matrixWorld), this.expandByPoint(yr.min), this.expandByPoint(yr.max)); for (var r = t.children, n = 0, i = r.length; n < i; n++)this.expandByObject(r[n]); return this }, containsPoint: function (t) { return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y || t.z < this.min.z || t.z > this.max.z) }, containsBox: function (t) { return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y && this.min.z <= t.min.z && t.max.z <= this.max.z }, getParameter: function (t, e) { return void 0 === e && (console.warn("THREE.Box3: .getParameter() target is now required"), e = new Ie), e.set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y), (t.z - this.min.z) / (this.max.z - this.min.z)) }, intersectsBox: function (t) { return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y || t.max.z < this.min.z || t.min.z > this.max.z) }, intersectsSphere: function (t) { return this.clampPoint(t.center, gr), gr.distanceToSquared(t.center) <= t.radius * t.radius }, intersectsPlane: function (t) { var e, r; return t.normal.x > 0 ? (e = t.normal.x * this.min.x, r = t.normal.x * this.max.x) : (e = t.normal.x * this.max.x, r = t.normal.x * this.min.x), t.normal.y > 0 ? (e += t.normal.y * this.min.y, r += t.normal.y * this.max.y) : (e += t.normal.y * this.max.y, r += t.normal.y * this.min.y), t.normal.z > 0 ? (e += t.normal.z * this.min.z, r += t.normal.z * this.max.z) : (e += t.normal.z * this.max.z, r += t.normal.z * this.min.z), e <= -t.constant && r >= -t.constant }, intersectsTriangle: function (t) { if (this.isEmpty()) return !1; this.getCenter(Tr), Er.subVectors(this.max, Tr), xr.subVectors(t.a, Tr), br.subVectors(t.b, Tr), wr.subVectors(t.c, Tr), _r.subVectors(br, xr), Mr.subVectors(wr, br), Sr.subVectors(xr, wr); var e = [0, -_r.z, _r.y, 0, -Mr.z, Mr.y, 0, -Sr.z, Sr.y, _r.z, 0, -_r.x, Mr.z, 0, -Mr.x, Sr.z, 0, -Sr.x, -_r.y, _r.x, 0, -Mr.y, Mr.x, 0, -Sr.y, Sr.x, 0]; return !!Rr(e, xr, br, wr, Er) && (!!Rr(e = [1, 0, 0, 0, 1, 0, 0, 0, 1], xr, br, wr, Er) && (Ar.crossVectors(_r, Mr), Rr(e = [Ar.x, Ar.y, Ar.z], xr, br, wr, Er))) }, clampPoint: function (t, e) { return void 0 === e && (console.warn("THREE.Box3: .clampPoint() target is now required"), e = new Ie), e.copy(t).clamp(this.min, this.max) }, distanceToPoint: function (t) { return gr.copy(t).clamp(this.min, this.max).sub(t).length() }, getBoundingSphere: function (t) { return void 0 === t && console.error("THREE.Box3: .getBoundingSphere() target is now required"), this.getCenter(t.center), t.radius = .5 * this.getSize(gr).length(), t }, intersect: function (t) { return this.min.max(t.min), this.max.min(t.max), this.isEmpty() && this.makeEmpty(), this }, union: function (t) { return this.min.min(t.min), this.max.max(t.max), this }, applyMatrix4: function (t) { return this.isEmpty() ? this : (vr[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(t), vr[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(t), vr[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(t), vr[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(t), vr[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(t), vr[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(t), vr[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(t), vr[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(t), this.setFromPoints(vr), this) }, translate: function (t) { return this.min.add(t), this.max.add(t), this }, equals: function (t) { return t.min.equals(this.min) && t.max.equals(this.max) } }); var Cr = new Pr; function Or(t, e) { this.center = void 0 !== t ? t : new Ie, this.radius = void 0 !== e ? e : 0 } Object.assign(Or.prototype, { set: function (t, e) { return this.center.copy(t), this.radius = e, this }, setFromPoints: function (t, e) { var r = this.center; void 0 !== e ? r.copy(e) : Cr.setFromPoints(t).getCenter(r); for (var n = 0, i = 0, o = t.length; i < o; i++)n = Math.max(n, r.distanceToSquared(t[i])); return this.radius = Math.sqrt(n), this }, clone: function () { return (new this.constructor).copy(this) }, copy: function (t) { return this.center.copy(t.center), this.radius = t.radius, this }, empty: function () { return this.radius <= 0 }, containsPoint: function (t) { return t.distanceToSquared(this.center) <= this.radius * this.radius }, distanceToPoint: function (t) { return t.distanceTo(this.center) - this.radius }, intersectsSphere: function (t) { var e = this.radius + t.radius; return t.center.distanceToSquared(this.center) <= e * e }, intersectsBox: function (t) { return t.intersectsSphere(this) }, intersectsPlane: function (t) { return Math.abs(t.distanceToPoint(this.center)) <= this.radius }, clampPoint: function (t, e) { var r = this.center.distanceToSquared(t); return void 0 === e && (console.warn("THREE.Sphere: .clampPoint() target is now required"), e = new Ie), e.copy(t), r > this.radius * this.radius && (e.sub(this.center).normalize(), e.multiplyScalar(this.radius).add(this.center)), e }, getBoundingBox: function (t) { return void 0 === t && (console.warn("THREE.Sphere: .getBoundingBox() target is now required"), t = new Pr), t.set(this.center, this.center), t.expandByScalar(this.radius), t }, applyMatrix4: function (t) { return this.center.applyMatrix4(t), this.radius = this.radius * t.getMaxScaleOnAxis(), this }, translate: function (t) { return this.center.add(t), this }, equals: function (t) { return t.center.equals(this.center) && t.radius === this.radius } }); var Ir = new Ie, Nr = new Ie, Dr = new Ie, zr = new Ie, Fr = new Ie, Ur = new Ie, Br = new Ie; function kr(t, e) { this.origin = void 0 !== t ? t : new Ie, this.direction = void 0 !== e ? e : new Ie(0, 0, -1) } Object.assign(kr.prototype, { set: function (t, e) { return this.origin.copy(t), this.direction.copy(e), this }, clone: function () { return (new this.constructor).copy(this) }, copy: function (t) { return this.origin.copy(t.origin), this.direction.copy(t.direction), this }, at: function (t, e) { return void 0 === e && (console.warn("THREE.Ray: .at() target is now required"), e = new Ie), e.copy(this.direction).multiplyScalar(t).add(this.origin) }, lookAt: function (t) { return this.direction.copy(t).sub(this.origin).normalize(), this }, recast: function (t) { return this.origin.copy(this.at(t, Ir)), this }, closestPointToPoint: function (t, e) { void 0 === e && (console.warn("THREE.Ray: .closestPointToPoint() target is now required"), e = new Ie), e.subVectors(t, this.origin); var r = e.dot(this.direction); return r < 0 ? e.copy(this.origin) : e.copy(this.direction).multiplyScalar(r).add(this.origin) }, distanceToPoint: function (t) { return Math.sqrt(this.distanceSqToPoint(t)) }, distanceSqToPoint: function (t) { var e = Ir.subVectors(t, this.origin).dot(this.direction); return e < 0 ? this.origin.distanceToSquared(t) : (Ir.copy(this.direction).multiplyScalar(e).add(this.origin), Ir.distanceToSquared(t)) }, distanceSqToSegment: function (t, e, r, n) { Nr.copy(t).add(e).multiplyScalar(.5), Dr.copy(e).sub(t).normalize(), zr.copy(this.origin).sub(Nr); var i, o, a, s, c = .5 * t.distanceTo(e), l = -this.direction.dot(Dr), h = zr.dot(this.direction), u = -zr.dot(Dr), p = zr.lengthSq(), d = Math.abs(1 - l * l); if (d > 0) if (o = l * h - u, s = c * d, (i = l * u - h) >= 0) if (o >= -s) if (o <= s) { var f = 1 / d; a = (i *= f) * (i + l * (o *= f) + 2 * h) + o * (l * i + o + 2 * u) + p } else o = c, a = -(i = Math.max(0, -(l * o + h))) * i + o * (o + 2 * u) + p; else o = -c, a = -(i = Math.max(0, -(l * o + h))) * i + o * (o + 2 * u) + p; else o <= -s ? a = -(i = Math.max(0, -(-l * c + h))) * i + (o = i > 0 ? -c : Math.min(Math.max(-c, -u), c)) * (o + 2 * u) + p : o <= s ? (i = 0, a = (o = Math.min(Math.max(-c, -u), c)) * (o + 2 * u) + p) : a = -(i = Math.max(0, -(l * c + h))) * i + (o = i > 0 ? c : Math.min(Math.max(-c, -u), c)) * (o + 2 * u) + p; else o = l > 0 ? -c : c, a = -(i = Math.max(0, -(l * o + h))) * i + o * (o + 2 * u) + p; return r && r.copy(this.direction).multiplyScalar(i).add(this.origin), n && n.copy(Dr).multiplyScalar(o).add(Nr), a }, intersectSphere: function (t, e) { Ir.subVectors(t.center, this.origin); var r = Ir.dot(this.direction), n = Ir.dot(Ir) - r * r, i = t.radius * t.radius; if (n > i) return null; var o = Math.sqrt(i - n), a = r - o, s = r + o; return a < 0 && s < 0 ? null : a < 0 ? this.at(s, e) : this.at(a, e) }, intersectsSphere: function (t) { return this.distanceSqToPoint(t.center) <= t.radius * t.radius }, distanceToPlane: function (t) { var e = t.normal.dot(this.direction); if (0 === e) return 0 === t.distanceToPoint(this.origin) ? 0 : null; var r = -(this.origin.dot(t.normal) + t.constant) / e; return r >= 0 ? r : null }, intersectPlane: function (t, e) { var r = this.distanceToPlane(t); return null === r ? null : this.at(r, e) }, intersectsPlane: function (t) { var e = t.distanceToPoint(this.origin); return 0 === e || t.normal.dot(this.direction) * e < 0 }, intersectBox: function (t, e) { var r, n, i, o, a, s, c = 1 / this.direction.x, l = 1 / this.direction.y, h = 1 / this.direction.z, u = this.origin; return c >= 0 ? (r = (t.min.x - u.x) * c, n = (t.max.x - u.x) * c) : (r = (t.max.x - u.x) * c, n = (t.min.x - u.x) * c), l >= 0 ? (i = (t.min.y - u.y) * l, o = (t.max.y - u.y) * l) : (i = (t.max.y - u.y) * l, o = (t.min.y - u.y) * l), r > o || i > n ? null : ((i > r || r != r) && (r = i), (o < n || n != n) && (n = o), h >= 0 ? (a = (t.min.z - u.z) * h, s = (t.max.z - u.z) * h) : (a = (t.max.z - u.z) * h, s = (t.min.z - u.z) * h), r > s || a > n ? null : ((a > r || r != r) && (r = a), (s < n || n != n) && (n = s), n < 0 ? null : this.at(r >= 0 ? r : n, e))) }, intersectsBox: function (t) { return null !== this.intersectBox(t, Ir) }, intersectTriangle: function (t, e, r, n, i) { Fr.subVectors(e, t), Ur.subVectors(r, t), Br.crossVectors(Fr, Ur); var o, a = this.direction.dot(Br); if (a > 0) { if (n) return null; o = 1 } else { if (!(a < 0)) return null; o = -1, a = -a } zr.subVectors(this.origin, t); var s = o * this.direction.dot(Ur.crossVectors(zr, Ur)); if (s < 0) return null; var c = o * this.direction.dot(Fr.cross(zr)); if (c < 0) return null; if (s + c > a) return null; var l = -o * zr.dot(Br); return l < 0 ? null : this.at(l / a, i) }, applyMatrix4: function (t) { return this.origin.applyMatrix4(t), this.direction.transformDirection(t), this }, equals: function (t) { return t.origin.equals(this.origin) && t.direction.equals(this.direction) } }); var jr = new Ie, Gr = new Ie, Vr = new ze; function Hr(t, e) { this.normal = void 0 !== t ? t : new Ie(1, 0, 0), this.constant = void 0 !== e ? e : 0 } Object.assign(Hr.prototype, { isPlane: !0, set: function (t, e) { return this.normal.copy(t), this.constant = e, this }, setComponents: function (t, e, r, n) { return this.normal.set(t, e, r), this.constant = n, this }, setFromNormalAndCoplanarPoint: function (t, e) { return this.normal.copy(t), this.constant = -e.dot(this.normal), this }, setFromCoplanarPoints: function (t, e, r) { var n = jr.subVectors(r, e).cross(Gr.subVectors(t, e)).normalize(); return this.setFromNormalAndCoplanarPoint(n, t), this }, clone: function () { return (new this.constructor).copy(this) }, copy: function (t) { return this.normal.copy(t.normal), this.constant = t.constant, this }, normalize: function () { var t = 1 / this.normal.length(); return this.normal.multiplyScalar(t), this.constant *= t, this }, negate: function () { return this.constant *= -1, this.normal.negate(), this }, distanceToPoint: function (t) { return this.normal.dot(t) + this.constant }, distanceToSphere: function (t) { return this.distanceToPoint(t.center) - t.radius }, projectPoint: function (t, e) { return void 0 === e && (console.warn("THREE.Plane: .projectPoint() target is now required"), e = new Ie), e.copy(this.normal).multiplyScalar(-this.distanceToPoint(t)).add(t) }, intersectLine: function (t, e) { void 0 === e && (console.warn("THREE.Plane: .intersectLine() target is now required"), e = new Ie); var r = t.delta(jr), n = this.normal.dot(r); if (0 === n) return 0 === this.distanceToPoint(t.start) ? e.copy(t.start) : void 0; var i = -(t.start.dot(this.normal) + this.constant) / n; return i < 0 || i > 1 ? void 0 : e.copy(r).multiplyScalar(i).add(t.start) }, intersectsLine: function (t) { var e = this.distanceToPoint(t.start), r = this.distanceToPoint(t.end); return e < 0 && r > 0 || r < 0 && e > 0 }, intersectsBox: function (t) { return t.intersectsPlane(this) }, intersectsSphere: function (t) { return t.intersectsPlane(this) }, coplanarPoint: function (t) { return void 0 === t && (console.warn("THREE.Plane: .coplanarPoint() target is now required"), t = new Ie), t.copy(this.normal).multiplyScalar(-this.constant) }, applyMatrix4: function (t, e) { var r = e || Vr.getNormalMatrix(t), n = this.coplanarPoint(jr).applyMatrix4(t), i = this.normal.applyMatrix3(r).normalize(); return this.constant = -n.dot(i), this }, translate: function (t) { return this.constant -= t.dot(this.normal), this }, equals: function (t) { return t.normal.equals(this.normal) && t.constant === this.constant } }); var Wr = new Ie, qr = new Ie, Xr = new Ie, Yr = new Ie, Zr = new Ie, Jr = new Ie, Kr = new Ie, Qr = new Ie, $r = new Ie, tn = new Ie; function en(t, e, r) { this.a = void 0 !== t ? t : new Ie, this.b = void 0 !== e ? e : new Ie, this.c = void 0 !== r ? r : new Ie } Object.assign(en, { getNormal: function (t, e, r, n) { void 0 === n && (console.warn("THREE.Triangle: .getNormal() target is now required"), n = new Ie), n.subVectors(r, e), Wr.subVectors(t, e), n.cross(Wr); var i = n.lengthSq(); return i > 0 ? n.multiplyScalar(1 / Math.sqrt(i)) : n.set(0, 0, 0) }, getBarycoord: function (t, e, r, n, i) { Wr.subVectors(n, e), qr.subVectors(r, e), Xr.subVectors(t, e); var o = Wr.dot(Wr), a = Wr.dot(qr), s = Wr.dot(Xr), c = qr.dot(qr), l = qr.dot(Xr), h = o * c - a * a; if (void 0 === i && (console.warn("THREE.Triangle: .getBarycoord() target is now required"), i = new Ie), 0 === h) return i.set(-2, -1, -1); var u = 1 / h, p = (c * s - a * l) * u, d = (o * l - a * s) * u; return i.set(1 - p - d, d, p) }, containsPoint: function (t, e, r, n) { return en.getBarycoord(t, e, r, n, Yr), Yr.x >= 0 && Yr.y >= 0 && Yr.x + Yr.y <= 1 }, getUV: function (t, e, r, n, i, o, a, s) { return this.getBarycoord(t, e, r, n, Yr), s.set(0, 0), s.addScaledVector(i, Yr.x), s.addScaledVector(o, Yr.y), s.addScaledVector(a, Yr.z), s }, isFrontFacing: function (t, e, r, n) { return Wr.subVectors(r, e), qr.subVectors(t, e), Wr.cross(qr).dot(n) < 0 } }), Object.assign(en.prototype, { set: function (t, e, r) { return this.a.copy(t), this.b.copy(e), this.c.copy(r), this }, setFromPointsAndIndices: function (t, e, r, n) { return this.a.copy(t[e]), this.b.copy(t[r]), this.c.copy(t[n]), this }, clone: function () { return (new this.constructor).copy(this) }, copy: function (t) { return this.a.copy(t.a), this.b.copy(t.b), this.c.copy(t.c), this }, getArea: function () { return Wr.subVectors(this.c, this.b), qr.subVectors(this.a, this.b), .5 * Wr.cross(qr).length() }, getMidpoint: function (t) { return void 0 === t && (console.warn("THREE.Triangle: .getMidpoint() target is now required"), t = new Ie), t.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3) }, getNormal: function (t) { return en.getNormal(this.a, this.b, this.c, t) }, getPlane: function (t) { return void 0 === t && (console.warn("THREE.Triangle: .getPlane() target is now required"), t = new Hr), t.setFromCoplanarPoints(this.a, this.b, this.c) }, getBarycoord: function (t, e) { return en.getBarycoord(t, this.a, this.b, this.c, e) }, getUV: function (t, e, r, n, i) { return en.getUV(t, this.a, this.b, this.c, e, r, n, i) }, containsPoint: function (t) { return en.containsPoint(t, this.a, this.b, this.c) }, isFrontFacing: function (t) { return en.isFrontFacing(this.a, this.b, this.c, t) }, intersectsBox: function (t) { return t.intersectsTriangle(this) }, closestPointToPoint: function (t, e) { void 0 === e && (console.warn("THREE.Triangle: .closestPointToPoint() target is now required"), e = new Ie); var r, n, i = this.a, o = this.b, a = this.c; Zr.subVectors(o, i), Jr.subVectors(a, i), Qr.subVectors(t, i); var s = Zr.dot(Qr), c = Jr.dot(Qr); if (s <= 0 && c <= 0) return e.copy(i); $r.subVectors(t, o); var l = Zr.dot($r), h = Jr.dot($r); if (l >= 0 && h <= l) return e.copy(o); var u = s * h - l * c; if (u <= 0 && s >= 0 && l <= 0) return r = s / (s - l), e.copy(i).addScaledVector(Zr, r); tn.subVectors(t, a); var p = Zr.dot(tn), d = Jr.dot(tn); if (d >= 0 && p <= d) return e.copy(a); var f = p * c - s * d; if (f <= 0 && c >= 0 && d <= 0) return n = c / (c - d), e.copy(i).addScaledVector(Jr, n); var m = l * d - p * h; if (m <= 0 && h - l >= 0 && p - d >= 0) return Kr.subVectors(a, o), n = (h - l) / (h - l + (p - d)), e.copy(o).addScaledVector(Kr, n); var v = 1 / (m + f + u); return r = f * v, n = u * v, e.copy(i).addScaledVector(Zr, r).addScaledVector(Jr, n) }, equals: function (t) { return t.a.equals(this.a) && t.b.equals(this.b) && t.c.equals(this.c) } }); var rn = { aliceblue: 15792383, antiquewhite: 16444375, aqua: 65535, aquamarine: 8388564, azure: 15794175, beige: 16119260, bisque: 16770244, black: 0, blanchedalmond: 16772045, blue: 255, blueviolet: 9055202, brown: 10824234, burlywood: 14596231, cadetblue: 6266528, chartreuse: 8388352, chocolate: 13789470, coral: 16744272, cornflowerblue: 6591981, cornsilk: 16775388, crimson: 14423100, cyan: 65535, darkblue: 139, darkcyan: 35723, darkgoldenrod: 12092939, darkgray: 11119017, darkgreen: 25600, darkgrey: 11119017, darkkhaki: 12433259, darkmagenta: 9109643, darkolivegreen: 5597999, darkorange: 16747520, darkorchid: 10040012, darkred: 9109504, darksalmon: 15308410, darkseagreen: 9419919, darkslateblue: 4734347, darkslategray: 3100495, darkslategrey: 3100495, darkturquoise: 52945, darkviolet: 9699539, deeppink: 16716947, deepskyblue: 49151, dimgray: 6908265, dimgrey: 6908265, dodgerblue: 2003199, firebrick: 11674146, floralwhite: 16775920, forestgreen: 2263842, fuchsia: 16711935, gainsboro: 14474460, ghostwhite: 16316671, gold: 16766720, goldenrod: 14329120, gray: 8421504, green: 32768, greenyellow: 11403055, grey: 8421504, honeydew: 15794160, hotpink: 16738740, indianred: 13458524, indigo: 4915330, ivory: 16777200, khaki: 15787660, lavender: 15132410, lavenderblush: 16773365, lawngreen: 8190976, lemonchiffon: 16775885, lightblue: 11393254, lightcoral: 15761536, lightcyan: 14745599, lightgoldenrodyellow: 16448210, lightgray: 13882323, lightgreen: 9498256, lightgrey: 13882323, lightpink: 16758465, lightsalmon: 16752762, lightseagreen: 2142890, lightskyblue: 8900346, lightslategray: 7833753, lightslategrey: 7833753, lightsteelblue: 11584734, lightyellow: 16777184, lime: 65280, limegreen: 3329330, linen: 16445670, magenta: 16711935, maroon: 8388608, mediumaquamarine: 6737322, mediumblue: 205, mediumorchid: 12211667, mediumpurple: 9662683, mediumseagreen: 3978097, mediumslateblue: 8087790, mediumspringgreen: 64154, mediumturquoise: 4772300, mediumvioletred: 13047173, midnightblue: 1644912, mintcream: 16121850, mistyrose: 16770273, moccasin: 16770229, navajowhite: 16768685, navy: 128, oldlace: 16643558, olive: 8421376, olivedrab: 7048739, orange: 16753920, orangered: 16729344, orchid: 14315734, palegoldenrod: 15657130, palegreen: 10025880, paleturquoise: 11529966, palevioletred: 14381203, papayawhip: 16773077, peachpuff: 16767673, peru: 13468991, pink: 16761035, plum: 14524637, powderblue: 11591910, purple: 8388736, rebeccapurple: 6697881, red: 16711680, rosybrown: 12357519, royalblue: 4286945, saddlebrown: 9127187, salmon: 16416882, sandybrown: 16032864, seagreen: 3050327, seashell: 16774638, sienna: 10506797, silver: 12632256, skyblue: 8900331, slateblue: 6970061, slategray: 7372944, slategrey: 7372944, snow: 16775930, springgreen: 65407, steelblue: 4620980, tan: 13808780, teal: 32896, thistle: 14204888, tomato: 16737095, turquoise: 4251856, violet: 15631086, wheat: 16113331, white: 16777215, whitesmoke: 16119285, yellow: 16776960, yellowgreen: 10145074 }, nn = { h: 0, s: 0, l: 0 }, on = { h: 0, s: 0, l: 0 }; function an(t, e, r) { return void 0 === e && void 0 === r ? this.set(t) : this.setRGB(t, e, r) } function sn(t, e, r) { return r < 0 && (r += 1), r > 1 && (r -= 1), r < 1 / 6 ? t + 6 * (e - t) * r : r < .5 ? e : r < 2 / 3 ? t + 6 * (e - t) * (2 / 3 - r) : t } function cn(t) { return t < .04045 ? .0773993808 * t : Math.pow(.9478672986 * t + .0521327014, 2.4) } function ln(t) { return t < .0031308 ? 12.92 * t : 1.055 * Math.pow(t, .41666) - .055 } function hn(t, e, r, n, i, o) { this.a = t, this.b = e, this.c = r, this.normal = n && n.isVector3 ? n : new Ie, this.vertexNormals = Array.isArray(n) ? n : [], this.color = i && i.isColor ? i : new an, this.vertexColors = Array.isArray(i) ? i : [], this.materialIndex = void 0 !== o ? o : 0 } Object.assign(an.prototype, { isColor: !0, r: 1, g: 1, b: 1, set: function (t) { return t && t.isColor ? this.copy(t) : "number" == typeof t ? this.setHex(t) : "string" == typeof t && this.setStyle(t), this }, setScalar: function (t) { return this.r = t, this.g = t, this.b = t, this }, setHex: function (t) { return t = Math.floor(t), this.r = (t >> 16 & 255) / 255, this.g = (t >> 8 & 255) / 255, this.b = (255 & t) / 255, this }, setRGB: function (t, e, r) { return this.r = t, this.g = e, this.b = r, this }, setHSL: function (t, e, r) { if (t = Le.euclideanModulo(t, 1), e = Le.clamp(e, 0, 1), r = Le.clamp(r, 0, 1), 0 === e) this.r = this.g = this.b = r; else { var n = r <= .5 ? r * (1 + e) : r + e - r * e, i = 2 * r - n; this.r = sn(i, n, t + 1 / 3), this.g = sn(i, n, t), this.b = sn(i, n, t - 1 / 3) } return this }, setStyle: function (t) { function e(e) { void 0 !== e && parseFloat(e) < 1 && console.warn("THREE.Color: Alpha component of " + t + " will be ignored.") } var r; if (r = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(t)) { var n, i = r[1], o = r[2]; switch (i) { case "rgb": case "rgba": if (n = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(o)) return this.r = Math.min(255, parseInt(n[1], 10)) / 255, this.g = Math.min(255, parseInt(n[2], 10)) / 255, this.b = Math.min(255, parseInt(n[3], 10)) / 255, e(n[5]), this; if (n = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(o)) return this.r = Math.min(100, parseInt(n[1], 10)) / 100, this.g = Math.min(100, parseInt(n[2], 10)) / 100, this.b = Math.min(100, parseInt(n[3], 10)) / 100, e(n[5]), this; break; case "hsl": case "hsla": if (n = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(o)) { var a = parseFloat(n[1]) / 360, s = parseInt(n[2], 10) / 100, c = parseInt(n[3], 10) / 100; return e(n[5]), this.setHSL(a, s, c) } } } else if (r = /^\#([A-Fa-f0-9]+)$/.exec(t)) { var l = r[1], h = l.length; if (3 === h) return this.r = parseInt(l.charAt(0) + l.charAt(0), 16) / 255, this.g = parseInt(l.charAt(1) + l.charAt(1), 16) / 255, this.b = parseInt(l.charAt(2) + l.charAt(2), 16) / 255, this; if (6 === h) return this.r = parseInt(l.charAt(0) + l.charAt(1), 16) / 255, this.g = parseInt(l.charAt(2) + l.charAt(3), 16) / 255, this.b = parseInt(l.charAt(4) + l.charAt(5), 16) / 255, this } return t && t.length > 0 ? this.setColorName(t) : this }, setColorName: function (t) { var e = rn[t]; return void 0 !== e ? this.setHex(e) : console.warn("THREE.Color: Unknown color " + t), this }, clone: function () { return new this.constructor(this.r, this.g, this.b) }, copy: function (t) { return this.r = t.r, this.g = t.g, this.b = t.b, this }, copyGammaToLinear: function (t, e) { return void 0 === e && (e = 2), this.r = Math.pow(t.r, e), this.g = Math.pow(t.g, e), this.b = Math.pow(t.b, e), this }, copyLinearToGamma: function (t, e) { void 0 === e && (e = 2); var r = e > 0 ? 1 / e : 1; return this.r = Math.pow(t.r, r), this.g = Math.pow(t.g, r), this.b = Math.pow(t.b, r), this }, convertGammaToLinear: function (t) { return this.copyGammaToLinear(this, t), this }, convertLinearToGamma: function (t) { return this.copyLinearToGamma(this, t), this }, copySRGBToLinear: function (t) { return this.r = cn(t.r), this.g = cn(t.g), this.b = cn(t.b), this }, copyLinearToSRGB: function (t) { return this.r = ln(t.r), this.g = ln(t.g), this.b = ln(t.b), this }, convertSRGBToLinear: function () { return this.copySRGBToLinear(this), this }, convertLinearToSRGB: function () { return this.copyLinearToSRGB(this), this }, getHex: function () { return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0 }, getHexString: function () { return ("000000" + this.getHex().toString(16)).slice(-6) }, getHSL: function (t) { void 0 === t && (console.warn("THREE.Color: .getHSL() target is now required"), t = { h: 0, s: 0, l: 0 }); var e, r, n = this.r, i = this.g, o = this.b, a = Math.max(n, i, o), s = Math.min(n, i, o), c = (s + a) / 2; if (s === a) e = 0, r = 0; else { var l = a - s; switch (r = c <= .5 ? l / (a + s) : l / (2 - a - s), a) { case n: e = (i - o) / l + (i < o ? 6 : 0); break; case i: e = (o - n) / l + 2; break; case o: e = (n - i) / l + 4 }e /= 6 } return t.h = e, t.s = r, t.l = c, t }, getStyle: function () { return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")" }, offsetHSL: function (t, e, r) { return this.getHSL(nn), nn.h += t, nn.s += e, nn.l += r, this.setHSL(nn.h, nn.s, nn.l), this }, add: function (t) { return this.r += t.r, this.g += t.g, this.b += t.b, this }, addColors: function (t, e) { return this.r = t.r + e.r, this.g = t.g + e.g, this.b = t.b + e.b, this }, addScalar: function (t) { return this.r += t, this.g += t, this.b += t, this }, sub: function (t) { return this.r = Math.max(0, this.r - t.r), this.g = Math.max(0, this.g - t.g), this.b = Math.max(0, this.b - t.b), this }, multiply: function (t) { return this.r *= t.r, this.g *= t.g, this.b *= t.b, this }, multiplyScalar: function (t) { return this.r *= t, this.g *= t, this.b *= t, this }, lerp: function (t, e) { return this.r += (t.r - this.r) * e, this.g += (t.g - this.g) * e, this.b += (t.b - this.b) * e, this }, lerpHSL: function (t, e) { this.getHSL(nn), t.getHSL(on); var r = Le.lerp(nn.h, on.h, e), n = Le.lerp(nn.s, on.s, e), i = Le.lerp(nn.l, on.l, e); return this.setHSL(r, n, i), this }, equals: function (t) { return t.r === this.r && t.g === this.g && t.b === this.b }, fromArray: function (t, e) { return void 0 === e && (e = 0), this.r = t[e], this.g = t[e + 1], this.b = t[e + 2], this }, toArray: function (t, e) { return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this.r, t[e + 1] = this.g, t[e + 2] = this.b, t }, toJSON: function () { return this.getHex() } }), an.NAMES = rn, Object.assign(hn.prototype, { clone: function () { return (new this.constructor).copy(this) }, copy: function (t) { this.a = t.a, this.b = t.b, this.c = t.c, this.normal.copy(t.normal), this.color.copy(t.color), this.materialIndex = t.materialIndex; for (var e = 0, r = t.vertexNormals.length; e < r; e++)this.vertexNormals[e] = t.vertexNormals[e].clone(); for (e = 0, r = t.vertexColors.length; e < r; e++)this.vertexColors[e] = t.vertexColors[e].clone(); return this } }); var un = 0; function pn() { Object.defineProperty(this, "id", { value: un++ }), this.uuid = Le.generateUUID(), this.name = "", this.type = "Material", this.fog = !0, this.blending = v, this.side = l, this.flatShading = !1, this.vertexTangents = !1, this.vertexColors = p, this.opacity = 1, this.transparent = !1, this.blendSrc = R, this.blendDst = C, this.blendEquation = w, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.depthFunc = k, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = Me, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = _e, this.stencilZFail = _e, this.stencilZPass = _e, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaTest = 0, this.premultipliedAlpha = !1, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.version = 0 } function dn(t) { pn.call(this), this.type = "MeshBasicMaterial", this.color = new an(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = W, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.setValues(t) } function fn(t, e, r) { if (Array.isArray(t)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array."); this.name = "", this.array = t, this.itemSize = e, this.count = void 0 !== t ? t.length / e : 0, this.normalized = !0 === r, this.usage = Se, this.updateRange = { offset: 0, count: -1 }, this.version = 0 } function mn(t, e, r) { fn.call(this, new Int8Array(t), e, r) } function vn(t, e, r) { fn.call(this, new Uint8Array(t), e, r) } function gn(t, e, r) { fn.call(this, new Uint8ClampedArray(t), e, r) } function yn(t, e, r) { fn.call(this, new Int16Array(t), e, r) } function xn(t, e, r) { fn.call(this, new Uint16Array(t), e, r) } function bn(t, e, r) { fn.call(this, new Int32Array(t), e, r) } function wn(t, e, r) { fn.call(this, new Uint32Array(t), e, r) } function _n(t, e, r) { fn.call(this, new Float32Array(t), e, r) } function Mn(t, e, r) { fn.call(this, new Float64Array(t), e, r) } function Sn() { this.vertices = [], this.normals = [], this.colors = [], this.uvs = [], this.uvs2 = [], this.groups = [], this.morphTargets = {}, this.skinWeights = [], this.skinIndices = [], this.boundingBox = null, this.boundingSphere = null, this.verticesNeedUpdate = !1, this.normalsNeedUpdate = !1, this.colorsNeedUpdate = !1, this.uvsNeedUpdate = !1, this.groupsNeedUpdate = !1 } function Tn(t) { if (0 === t.length) return -1 / 0; for (var e = t[0], r = 1, n = t.length; r < n; ++r)t[r] > e && (e = t[r]); return e } pn.prototype = Object.assign(Object.create(Te.prototype), { constructor: pn, isMaterial: !0, onBeforeCompile: function () { }, setValues: function (t) { if (void 0 !== t) for (var e in t) { var r = t[e]; if (void 0 !== r) if ("shading" !== e) { var n = this[e]; void 0 !== n ? n && n.isColor ? n.set(r) : n && n.isVector3 && r && r.isVector3 ? n.copy(r) : this[e] = r : console.warn("THREE." + this.type + ": '" + e + "' is not a property of this material.") } else console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = 1 === r; else console.warn("THREE.Material: '" + e + "' parameter is undefined.") } }, toJSON: function (t) { var e = void 0 === t || "string" == typeof t; e && (t = { textures: {}, images: {} }); var r = { metadata: { version: 4.5, type: "Material", generator: "Material.toJSON" } }; function n(t) { var e = []; for (var r in t) { var n = t[r]; delete n.metadata, e.push(n) } return e } if (r.uuid = this.uuid, r.type = this.type, "" !== this.name && (r.name = this.name), this.color && this.color.isColor && (r.color = this.color.getHex()), void 0 !== this.roughness && (r.roughness = this.roughness), void 0 !== this.metalness && (r.metalness = this.metalness), this.sheen && this.sheen.isColor && (r.sheen = this.sheen.getHex()), this.emissive && this.emissive.isColor && (r.emissive = this.emissive.getHex()), this.emissiveIntensity && 1 !== this.emissiveIntensity && (r.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (r.specular = this.specular.getHex()), void 0 !== this.shininess && (r.shininess = this.shininess), void 0 !== this.clearcoat && (r.clearcoat = this.clearcoat), void 0 !== this.clearcoatRoughness && (r.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (r.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(t).uuid, r.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.map && this.map.isTexture && (r.map = this.map.toJSON(t).uuid), this.matcap && this.matcap.isTexture && (r.matcap = this.matcap.toJSON(t).uuid), this.alphaMap && this.alphaMap.isTexture && (r.alphaMap = this.alphaMap.toJSON(t).uuid), this.lightMap && this.lightMap.isTexture && (r.lightMap = this.lightMap.toJSON(t).uuid), this.aoMap && this.aoMap.isTexture && (r.aoMap = this.aoMap.toJSON(t).uuid, r.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (r.bumpMap = this.bumpMap.toJSON(t).uuid, r.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (r.normalMap = this.normalMap.toJSON(t).uuid, r.normalMapType = this.normalMapType, r.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (r.displacementMap = this.displacementMap.toJSON(t).uuid, r.displacementScale = this.displacementScale, r.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (r.roughnessMap = this.roughnessMap.toJSON(t).uuid), this.metalnessMap && this.metalnessMap.isTexture && (r.metalnessMap = this.metalnessMap.toJSON(t).uuid), this.emissiveMap && this.emissiveMap.isTexture && (r.emissiveMap = this.emissiveMap.toJSON(t).uuid), this.specularMap && this.specularMap.isTexture && (r.specularMap = this.specularMap.toJSON(t).uuid), this.envMap && this.envMap.isTexture && (r.envMap = this.envMap.toJSON(t).uuid, r.reflectivity = this.reflectivity, r.refractionRatio = this.refractionRatio, void 0 !== this.combine && (r.combine = this.combine), void 0 !== this.envMapIntensity && (r.envMapIntensity = this.envMapIntensity)), this.gradientMap && this.gradientMap.isTexture && (r.gradientMap = this.gradientMap.toJSON(t).uuid), void 0 !== this.size && (r.size = this.size), void 0 !== this.sizeAttenuation && (r.sizeAttenuation = this.sizeAttenuation), this.blending !== v && (r.blending = this.blending), !0 === this.flatShading && (r.flatShading = this.flatShading), this.side !== l && (r.side = this.side), this.vertexColors !== p && (r.vertexColors = this.vertexColors), this.opacity < 1 && (r.opacity = this.opacity), !0 === this.transparent && (r.transparent = this.transparent), r.depthFunc = this.depthFunc, r.depthTest = this.depthTest, r.depthWrite = this.depthWrite, r.stencilWrite = this.stencilWrite, r.stencilWriteMask = this.stencilWriteMask, r.stencilFunc = this.stencilFunc, r.stencilRef = this.stencilRef, r.stencilFuncMask = this.stencilFuncMask, r.stencilFail = this.stencilFail, r.stencilZFail = this.stencilZFail, r.stencilZPass = this.stencilZPass, this.rotation && 0 !== this.rotation && (r.rotation = this.rotation), !0 === this.polygonOffset && (r.polygonOffset = !0), 0 !== this.polygonOffsetFactor && (r.polygonOffsetFactor = this.polygonOffsetFactor), 0 !== this.polygonOffsetUnits && (r.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth && 1 !== this.linewidth && (r.linewidth = this.linewidth), void 0 !== this.dashSize && (r.dashSize = this.dashSize), void 0 !== this.gapSize && (r.gapSize = this.gapSize), void 0 !== this.scale && (r.scale = this.scale), !0 === this.dithering && (r.dithering = !0), this.alphaTest > 0 && (r.alphaTest = this.alphaTest), !0 === this.premultipliedAlpha && (r.premultipliedAlpha = this.premultipliedAlpha), !0 === this.wireframe && (r.wireframe = this.wireframe), this.wireframeLinewidth > 1 && (r.wireframeLinewidth = this.wireframeLinewidth), "round" !== this.wireframeLinecap && (r.wireframeLinecap = this.wireframeLinecap), "round" !== this.wireframeLinejoin && (r.wireframeLinejoin = this.wireframeLinejoin), !0 === this.morphTargets && (r.morphTargets = !0), !0 === this.morphNormals && (r.morphNormals = !0), !0 === this.skinning && (r.skinning = !0), !1 === this.visible && (r.visible = !1), !1 === this.toneMapped && (r.toneMapped = !1), "{}" !== JSON.stringify(this.userData) && (r.userData = this.userData), e) { var i = n(t.textures), o = n(t.images); i.length > 0 && (r.textures = i), o.length > 0 && (r.images = o) } return r }, clone: function () { return (new this.constructor).copy(this) }, copy: function (t) { this.name = t.name, this.fog = t.fog, this.blending = t.blending, this.side = t.side, this.flatShading = t.flatShading, this.vertexTangents = t.vertexTangents, this.vertexColors = t.vertexColors, this.opacity = t.opacity, this.transparent = t.transparent, this.blendSrc = t.blendSrc, this.blendDst = t.blendDst, this.blendEquation = t.blendEquation, this.blendSrcAlpha = t.blendSrcAlpha, this.blendDstAlpha = t.blendDstAlpha, this.blendEquationAlpha = t.blendEquationAlpha, this.depthFunc = t.depthFunc, this.depthTest = t.depthTest, this.depthWrite = t.depthWrite, this.stencilWriteMask = t.stencilWriteMask, this.stencilFunc = t.stencilFunc, this.stencilRef = t.stencilRef, this.stencilFuncMask = t.stencilFuncMask, this.stencilFail = t.stencilFail, this.stencilZFail = t.stencilZFail, this.stencilZPass = t.stencilZPass, this.stencilWrite = t.stencilWrite; var e = t.clippingPlanes, r = null; if (null !== e) { var n = e.length; r = new Array(n); for (var i = 0; i !== n; ++i)r[i] = e[i].clone() } return this.clippingPlanes = r, this.clipIntersection = t.clipIntersection, this.clipShadows = t.clipShadows, this.shadowSide = t.shadowSide, this.colorWrite = t.colorWrite, this.precision = t.precision, this.polygonOffset = t.polygonOffset, this.polygonOffsetFactor = t.polygonOffsetFactor, this.polygonOffsetUnits = t.polygonOffsetUnits, this.dithering = t.dithering, this.alphaTest = t.alphaTest, this.premultipliedAlpha = t.premultipliedAlpha, this.visible = t.visible, this.toneMapped = t.toneMapped, this.userData = JSON.parse(JSON.stringify(t.userData)), this }, dispose: function () { this.dispatchEvent({ type: "dispose" }) } }), Object.defineProperty(pn.prototype, "needsUpdate", { set: function (t) { !0 === t && this.version++ } }), dn.prototype = Object.create(pn.prototype), dn.prototype.constructor = dn, dn.prototype.isMeshBasicMaterial = !0, dn.prototype.copy = function (t) { return pn.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this }, Object.defineProperty(fn.prototype, "needsUpdate", { set: function (t) { !0 === t && this.version++ } }), Object.assign(fn.prototype, { isBufferAttribute: !0, onUploadCallback: function () { }, setUsage: function (t) { return this.usage = t, this }, copy: function (t) { return this.name = t.name, this.array = new t.array.constructor(t.array), this.itemSize = t.itemSize, this.count = t.count, this.normalized = t.normalized, this.usage = t.usage, this }, copyAt: function (t, e, r) { t *= this.itemSize, r *= e.itemSize; for (var n = 0, i = this.itemSize; n < i; n++)this.array[t + n] = e.array[r + n]; return this }, copyArray: function (t) { return this.array.set(t), this }, copyColorsArray: function (t) { for (var e = this.array, r = 0, n = 0, i = t.length; n < i; n++) { var o = t[n]; void 0 === o && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", n), o = new an), e[r++] = o.r, e[r++] = o.g, e[r++] = o.b } return this }, copyVector2sArray: function (t) { for (var e = this.array, r = 0, n = 0, i = t.length; n < i; n++) { var o = t[n]; void 0 === o && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", n), o = new Pe), e[r++] = o.x, e[r++] = o.y } return this }, copyVector3sArray: function (t) { for (var e = this.array, r = 0, n = 0, i = t.length; n < i; n++) { var o = t[n]; void 0 === o && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", n), o = new Ie), e[r++] = o.x, e[r++] = o.y, e[r++] = o.z } return this }, copyVector4sArray: function (t) { for (var e = this.array, r = 0, n = 0, i = t.length; n < i; n++) { var o = t[n]; void 0 === o && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", n), o = new ke), e[r++] = o.x, e[r++] = o.y, e[r++] = o.z, e[r++] = o.w } return this }, set: function (t, e) { return void 0 === e && (e = 0), this.array.set(t, e), this }, getX: function (t) { return this.array[t * this.itemSize] }, setX: function (t, e) { return this.array[t * this.itemSize] = e, this }, getY: function (t) { return this.array[t * this.itemSize + 1] }, setY: function (t, e) { return this.array[t * this.itemSize + 1] = e, this }, getZ: function (t) { return this.array[t * this.itemSize + 2] }, setZ: function (t, e) { return this.array[t * this.itemSize + 2] = e, this }, getW: function (t) { return this.array[t * this.itemSize + 3] }, setW: function (t, e) { return this.array[t * this.itemSize + 3] = e, this }, setXY: function (t, e, r) { return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = r, this }, setXYZ: function (t, e, r, n) { return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = r, this.array[t + 2] = n, this }, setXYZW: function (t, e, r, n, i) { return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = r, this.array[t + 2] = n, this.array[t + 3] = i, this }, onUpload: function (t) { return this.onUploadCallback = t, this }, clone: function () { return new this.constructor(this.array, this.itemSize).copy(this) }, toJSON: function () { return { itemSize: this.itemSize, type: this.array.constructor.name, array: Array.prototype.slice.call(this.array), normalized: this.normalized } } }), mn.prototype = Object.create(fn.prototype), mn.prototype.constructor = mn, vn.prototype = Object.create(fn.prototype), vn.prototype.constructor = vn, gn.prototype = Object.create(fn.prototype), gn.prototype.constructor = gn, yn.prototype = Object.create(fn.prototype), yn.prototype.constructor = yn, xn.prototype = Object.create(fn.prototype), xn.prototype.constructor = xn, bn.prototype = Object.create(fn.prototype), bn.prototype.constructor = bn, wn.prototype = Object.create(fn.prototype), wn.prototype.constructor = wn, _n.prototype = Object.create(fn.prototype), _n.prototype.constructor = _n, Mn.prototype = Object.create(fn.prototype), Mn.prototype.constructor = Mn, Object.assign(Sn.prototype, { computeGroups: function (t) { for (var e, r = [], n = void 0, i = t.faces, o = 0; o < i.length; o++) { var a = i[o]; a.materialIndex !== n && (n = a.materialIndex, void 0 !== e && (e.count = 3 * o - e.start, r.push(e)), e = { start: 3 * o, materialIndex: n }) } void 0 !== e && (e.count = 3 * o - e.start, r.push(e)), this.groups = r }, fromGeometry: function (t) { var e, r = t.faces, n = t.vertices, i = t.faceVertexUvs, o = i[0] && i[0].length > 0, a = i[1] && i[1].length > 0, s = t.morphTargets, c = s.length; if (c > 0) { e = []; for (var l = 0; l < c; l++)e[l] = { name: s[l].name, data: [] }; this.morphTargets.position = e } var h, u = t.morphNormals, p = u.length; if (p > 0) { h = []; for (l = 0; l < p; l++)h[l] = { name: u[l].name, data: [] }; this.morphTargets.normal = h } var d = t.skinIndices, f = t.skinWeights, m = d.length === n.length, v = f.length === n.length; n.length > 0 && 0 === r.length && console.error("THREE.DirectGeometry: Faceless geometries are not supported."); for (l = 0; l < r.length; l++) { var g = r[l]; this.vertices.push(n[g.a], n[g.b], n[g.c]); var y = g.vertexNormals; if (3 === y.length) this.normals.push(y[0], y[1], y[2]); else { var x = g.normal; this.normals.push(x, x, x) } var b, w = g.vertexColors; if (3 === w.length) this.colors.push(w[0], w[1], w[2]); else { var _ = g.color; this.colors.push(_, _, _) } if (!0 === o) void 0 !== (b = i[0][l]) ? this.uvs.push(b[0], b[1], b[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ", l), this.uvs.push(new Pe, new Pe, new Pe)); if (!0 === a) void 0 !== (b = i[1][l]) ? this.uvs2.push(b[0], b[1], b[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ", l), this.uvs2.push(new Pe, new Pe, new Pe)); for (var M = 0; M < c; M++) { var S = s[M].vertices; e[M].data.push(S[g.a], S[g.b], S[g.c]) } for (M = 0; M < p; M++) { var T = u[M].vertexNormals[l]; h[M].data.push(T.a, T.b, T.c) } m && this.skinIndices.push(d[g.a], d[g.b], d[g.c]), v && this.skinWeights.push(f[g.a], f[g.b], f[g.c]) } return this.computeGroups(t), this.verticesNeedUpdate = t.verticesNeedUpdate, this.normalsNeedUpdate = t.normalsNeedUpdate, this.colorsNeedUpdate = t.colorsNeedUpdate, this.uvsNeedUpdate = t.uvsNeedUpdate, this.groupsNeedUpdate = t.groupsNeedUpdate, null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere.clone()), null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone()), this } }); var En = 1, An = new Je, Ln = new fr, Pn = new Ie, Rn = new Pr, Cn = new Pr, On = new Ie; function In() { Object.defineProperty(this, "id", { value: En += 2 }), this.uuid = Le.generateUUID(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = { start: 0, count: 1 / 0 }, this.userData = {} } In.prototype = Object.assign(Object.create(Te.prototype), { constructor: In, isBufferGeometry: !0, getIndex: function () { return this.index }, setIndex: function (t) { Array.isArray(t) ? this.index = new (Tn(t) > 65535 ? wn : xn)(t, 1) : this.index = t }, getAttribute: function (t) { return this.attributes[t] }, setAttribute: function (t, e) { return this.attributes[t] = e, this }, deleteAttribute: function (t) { return delete this.attributes[t], this }, addGroup: function (t, e, r) { this.groups.push({ start: t, count: e, materialIndex: void 0 !== r ? r : 0 }) }, clearGroups: function () { this.groups = [] }, setDrawRange: function (t, e) { this.drawRange.start = t, this.drawRange.count = e }, applyMatrix: function (t) { var e = this.attributes.position; void 0 !== e && (t.applyToBufferAttribute(e), e.needsUpdate = !0); var r = this.attributes.normal; void 0 !== r && ((new ze).getNormalMatrix(t).applyToBufferAttribute(r), r.needsUpdate = !0); var n = this.attributes.tangent; void 0 !== n && ((new ze).getNormalMatrix(t).applyToBufferAttribute(n), n.needsUpdate = !0); return null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this }, rotateX: function (t) { return An.makeRotationX(t), this.applyMatrix(An), this }, rotateY: function (t) { return An.makeRotationY(t), this.applyMatrix(An), this }, rotateZ: function (t) { return An.makeRotationZ(t), this.applyMatrix(An), this }, translate: function (t, e, r) { return An.makeTranslation(t, e, r), this.applyMatrix(An), this }, scale: function (t, e, r) { return An.makeScale(t, e, r), this.applyMatrix(An), this }, lookAt: function (t) { return Ln.lookAt(t), Ln.updateMatrix(), this.applyMatrix(Ln.matrix), this }, center: function () { return this.computeBoundingBox(), this.boundingBox.getCenter(Pn).negate(), this.translate(Pn.x, Pn.y, Pn.z), this }, setFromObject: function (t) { var e = t.geometry; if (t.isPoints || t.isLine) { var r = new _n(3 * e.vertices.length, 3), n = new _n(3 * e.colors.length, 3); if (this.setAttribute("position", r.copyVector3sArray(e.vertices)), this.setAttribute("color", n.copyColorsArray(e.colors)), e.lineDistances && e.lineDistances.length === e.vertices.length) { var i = new _n(e.lineDistances.length, 1); this.setAttribute("lineDistance", i.copyArray(e.lineDistances)) } null !== e.boundingSphere && (this.boundingSphere = e.boundingSphere.clone()), null !== e.boundingBox && (this.boundingBox = e.boundingBox.clone()) } else t.isMesh && e && e.isGeometry && this.fromGeometry(e); return this }, setFromPoints: function (t) { for (var e = [], r = 0, n = t.length; r < n; r++) { var i = t[r]; e.push(i.x, i.y, i.z || 0) } return this.setAttribute("position", new _n(e, 3)), this }, updateFromObject: function (t) { var e, r = t.geometry; if (t.isMesh) { var n = r.__directGeometry; if (!0 === r.elementsNeedUpdate && (n = void 0, r.elementsNeedUpdate = !1), void 0 === n) return this.fromGeometry(r); n.verticesNeedUpdate = r.verticesNeedUpdate, n.normalsNeedUpdate = r.normalsNeedUpdate, n.colorsNeedUpdate = r.colorsNeedUpdate, n.uvsNeedUpdate = r.uvsNeedUpdate, n.groupsNeedUpdate = r.groupsNeedUpdate, r.verticesNeedUpdate = !1, r.normalsNeedUpdate = !1, r.colorsNeedUpdate = !1, r.uvsNeedUpdate = !1, r.groupsNeedUpdate = !1, r = n } return !0 === r.verticesNeedUpdate && (void 0 !== (e = this.attributes.position) && (e.copyVector3sArray(r.vertices), e.needsUpdate = !0), r.verticesNeedUpdate = !1), !0 === r.normalsNeedUpdate && (void 0 !== (e = this.attributes.normal) && (e.copyVector3sArray(r.normals), e.needsUpdate = !0), r.normalsNeedUpdate = !1), !0 === r.colorsNeedUpdate && (void 0 !== (e = this.attributes.color) && (e.copyColorsArray(r.colors), e.needsUpdate = !0), r.colorsNeedUpdate = !1), r.uvsNeedUpdate && (void 0 !== (e = this.attributes.uv) && (e.copyVector2sArray(r.uvs), e.needsUpdate = !0), r.uvsNeedUpdate = !1), r.lineDistancesNeedUpdate && (void 0 !== (e = this.attributes.lineDistance) && (e.copyArray(r.lineDistances), e.needsUpdate = !0), r.lineDistancesNeedUpdate = !1), r.groupsNeedUpdate && (r.computeGroups(t.geometry), this.groups = r.groups, r.groupsNeedUpdate = !1), this }, fromGeometry: function (t) { return t.__directGeometry = (new Sn).fromGeometry(t), this.fromDirectGeometry(t.__directGeometry) }, fromDirectGeometry: function (t) { var e = new Float32Array(3 * t.vertices.length); if (this.setAttribute("position", new fn(e, 3).copyVector3sArray(t.vertices)), t.normals.length > 0) { var r = new Float32Array(3 * t.normals.length); this.setAttribute("normal", new fn(r, 3).copyVector3sArray(t.normals)) } if (t.colors.length > 0) { var n = new Float32Array(3 * t.colors.length); this.setAttribute("color", new fn(n, 3).copyColorsArray(t.colors)) } if (t.uvs.length > 0) { var i = new Float32Array(2 * t.uvs.length); this.setAttribute("uv", new fn(i, 2).copyVector2sArray(t.uvs)) } if (t.uvs2.length > 0) { var o = new Float32Array(2 * t.uvs2.length); this.setAttribute("uv2", new fn(o, 2).copyVector2sArray(t.uvs2)) } for (var a in this.groups = t.groups, t.morphTargets) { for (var s = [], c = t.morphTargets[a], l = 0, h = c.length; l < h; l++) { var u = c[l], p = new _n(3 * u.data.length, 3); p.name = u.name, s.push(p.copyVector3sArray(u.data)) } this.morphAttributes[a] = s } if (t.skinIndices.length > 0) { var d = new _n(4 * t.skinIndices.length, 4); this.setAttribute("skinIndex", d.copyVector4sArray(t.skinIndices)) } if (t.skinWeights.length > 0) { var f = new _n(4 * t.skinWeights.length, 4); this.setAttribute("skinWeight", f.copyVector4sArray(t.skinWeights)) } return null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere.clone()), null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone()), this }, computeBoundingBox: function () { null === this.boundingBox && (this.boundingBox = new Pr); var t = this.attributes.position, e = this.morphAttributes.position; if (void 0 !== t) { if (this.boundingBox.setFromBufferAttribute(t), e) for (var r = 0, n = e.length; r < n; r++) { var i = e[r]; Rn.setFromBufferAttribute(i), this.morphTargetsRelative ? (On.addVectors(this.boundingBox.min, Rn.min), this.boundingBox.expandByPoint(On), On.addVectors(this.boundingBox.max, Rn.max), this.boundingBox.expandByPoint(On)) : (this.boundingBox.expandByPoint(Rn.min), this.boundingBox.expandByPoint(Rn.max)) } } else this.boundingBox.makeEmpty(); (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this) }, computeBoundingSphere: function () { null === this.boundingSphere && (this.boundingSphere = new Or); var t = this.attributes.position, e = this.morphAttributes.position; if (t) { var r = this.boundingSphere.center; if (Rn.setFromBufferAttribute(t), e) for (var n = 0, i = e.length; n < i; n++) { var o = e[n]; Cn.setFromBufferAttribute(o), this.morphTargetsRelative ? (On.addVectors(Rn.min, Cn.min), Rn.expandByPoint(On), On.addVectors(Rn.max, Cn.max), Rn.expandByPoint(On)) : (Rn.expandByPoint(Cn.min), Rn.expandByPoint(Cn.max)) } Rn.getCenter(r); var a = 0; for (n = 0, i = t.count; n < i; n++)On.fromBufferAttribute(t, n), a = Math.max(a, r.distanceToSquared(On)); if (e) for (n = 0, i = e.length; n < i; n++) { o = e[n]; for (var s = this.morphTargetsRelative, c = 0, l = o.count; c < l; c++)On.fromBufferAttribute(o, c), s && (Pn.fromBufferAttribute(t, c), On.add(Pn)), a = Math.max(a, r.distanceToSquared(On)) } this.boundingSphere.radius = Math.sqrt(a), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this) } }, computeFaceNormals: function () { }, computeVertexNormals: function () { var t = this.index, e = this.attributes; if (e.position) { var r = e.position.array; if (void 0 === e.normal) this.setAttribute("normal", new fn(new Float32Array(r.length), 3)); else for (var n = e.normal.array, i = 0, o = n.length; i < o; i++)n[i] = 0; var a, s, c, l = e.normal.array, h = new Ie, u = new Ie, p = new Ie, d = new Ie, f = new Ie; if (t) { var m = t.array; for (i = 0, o = t.count; i < o; i += 3)a = 3 * m[i + 0], s = 3 * m[i + 1], c = 3 * m[i + 2], h.fromArray(r, a), u.fromArray(r, s), p.fromArray(r, c), d.subVectors(p, u), f.subVectors(h, u), d.cross(f), l[a] += d.x, l[a + 1] += d.y, l[a + 2] += d.z, l[s] += d.x, l[s + 1] += d.y, l[s + 2] += d.z, l[c] += d.x, l[c + 1] += d.y, l[c + 2] += d.z } else for (i = 0, o = r.length; i < o; i += 9)h.fromArray(r, i), u.fromArray(r, i + 3), p.fromArray(r, i + 6), d.subVectors(p, u), f.subVectors(h, u), d.cross(f), l[i] = d.x, l[i + 1] = d.y, l[i + 2] = d.z, l[i + 3] = d.x, l[i + 4] = d.y, l[i + 5] = d.z, l[i + 6] = d.x, l[i + 7] = d.y, l[i + 8] = d.z; this.normalizeNormals(), e.normal.needsUpdate = !0 } }, merge: function (t, e) { if (t && t.isBufferGeometry) { void 0 === e && (e = 0, console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge.")); var r = this.attributes; for (var n in r) if (void 0 !== t.attributes[n]) for (var i = r[n].array, o = t.attributes[n], a = o.array, s = o.itemSize * e, c = Math.min(a.length, i.length - s), l = 0, h = s; l < c; l++, h++)i[h] = a[l]; return this } console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", t) }, normalizeNormals: function () { for (var t = this.attributes.normal, e = 0, r = t.count; e < r; e++)On.x = t.getX(e), On.y = t.getY(e), On.z = t.getZ(e), On.normalize(), t.setXYZ(e, On.x, On.y, On.z) }, toNonIndexed: function () { function t(t, e) { for (var r = t.array, n = t.itemSize, i = new r.constructor(e.length * n), o = 0, a = 0, s = 0, c = e.length; s < c; s++) { o = e[s] * n; for (var l = 0; l < n; l++)i[a++] = r[o++] } return new fn(i, n) } if (null === this.index) return console.warn("THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed."), this; var e = new In, r = this.index.array, n = this.attributes; for (var i in n) { var o = t(n[i], r); e.setAttribute(i, o) } var a = this.morphAttributes; for (i in a) { for (var s = [], c = a[i], l = 0, h = c.length; l < h; l++) { o = t(c[l], r); s.push(o) } e.morphAttributes[i] = s } e.morphTargetsRelative = this.morphTargetsRelative; for (var u = this.groups, p = (l = 0, u.length); l < p; l++) { var d = u[l]; e.addGroup(d.start, d.count, d.materialIndex) } return e }, toJSON: function () { var t = { metadata: { version: 4.5, type: "BufferGeometry", generator: "BufferGeometry.toJSON" } }; if (t.uuid = this.uuid, t.type = this.type, "" !== this.name && (t.name = this.name), Object.keys(this.userData).length > 0 && (t.userData = this.userData), void 0 !== this.parameters) { var e = this.parameters; for (var r in e) void 0 !== e[r] && (t[r] = e[r]); return t } t.data = { attributes: {} }; var n = this.index; null !== n && (t.data.index = { type: n.array.constructor.name, array: Array.prototype.slice.call(n.array) }); var i = this.attributes; for (var r in i) { var o = (p = i[r]).toJSON(); "" !== p.name && (o.name = p.name), t.data.attributes[r] = o } var a = {}, s = !1; for (var r in this.morphAttributes) { for (var c = this.morphAttributes[r], l = [], h = 0, u = c.length; h < u; h++) { var p; o = (p = c[h]).toJSON(); "" !== p.name && (o.name = p.name), l.push(o) } l.length > 0 && (a[r] = l, s = !0) } s && (t.data.morphAttributes = a, t.data.morphTargetsRelative = this.morphTargetsRelative); var d = this.groups; d.length > 0 && (t.data.groups = JSON.parse(JSON.stringify(d))); var f = this.boundingSphere; return null !== f && (t.data.boundingSphere = { center: f.center.toArray(), radius: f.radius }), t }, clone: function () { return (new In).copy(this) }, copy: function (t) { var e, r, n; this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.name = t.name; var i = t.index; null !== i && this.setIndex(i.clone()); var o = t.attributes; for (e in o) { var a = o[e]; this.setAttribute(e, a.clone()) } var s = t.morphAttributes; for (e in s) { var c = [], l = s[e]; for (r = 0, n = l.length; r < n; r++)c.push(l[r].clone()); this.morphAttributes[e] = c } this.morphTargetsRelative = t.morphTargetsRelative; var h = t.groups; for (r = 0, n = h.length; r < n; r++) { var u = h[r]; this.addGroup(u.start, u.count, u.materialIndex) } var p = t.boundingBox; null !== p && (this.boundingBox = p.clone()); var d = t.boundingSphere; return null !== d && (this.boundingSphere = d.clone()), this.drawRange.start = t.drawRange.start, this.drawRange.count = t.drawRange.count, this.userData = t.userData, this }, dispose: function () { this.dispatchEvent({ type: "dispose" }) } }); var Nn = new Je, Dn = new kr, zn = new Or, Fn = new Ie, Un = new Ie, Bn = new Ie, kn = new Ie, jn = new Ie, Gn = new Ie, Vn = new Ie, Hn = new Ie, Wn = new Ie, qn = new Pe, Xn = new Pe, Yn = new Pe, Zn = new Ie, Jn = new Ie; function Kn(t, e) { fr.call(this), this.type = "Mesh", this.geometry = void 0 !== t ? t : new In, this.material = void 0 !== e ? e : new dn({ color: 16777215 * Math.random() }), this.drawMode = se, this.updateMorphTargets() } function Qn(t, e, r, n, i, o, a, s) { if (null === (e.side === h ? n.intersectTriangle(a, o, i, !0, s) : n.intersectTriangle(i, o, a, e.side !== u, s))) return null; Jn.copy(s), Jn.applyMatrix4(t.matrixWorld); var c = r.ray.origin.distanceTo(Jn); return c < r.near || c > r.far ? null : { distance: c, point: Jn.clone(), object: t } } function $n(t, e, r, n, i, o, a, s, c, l, h, u) { Fn.fromBufferAttribute(i, l), Un.fromBufferAttribute(i, h), Bn.fromBufferAttribute(i, u); var p = t.morphTargetInfluences; if (e.morphTargets && o && p) { Vn.set(0, 0, 0), Hn.set(0, 0, 0), Wn.set(0, 0, 0); for (var d = 0, f = o.length; d < f; d++) { var m = p[d], v = o[d]; 0 !== m && (kn.fromBufferAttribute(v, l), jn.fromBufferAttribute(v, h), Gn.fromBufferAttribute(v, u), a ? (Vn.addScaledVector(kn, m), Hn.addScaledVector(jn, m), Wn.addScaledVector(Gn, m)) : (Vn.addScaledVector(kn.sub(Fn), m), Hn.addScaledVector(jn.sub(Un), m), Wn.addScaledVector(Gn.sub(Bn), m))) } Fn.add(Vn), Un.add(Hn), Bn.add(Wn) } var g = Qn(t, e, r, n, Fn, Un, Bn, Zn); if (g) { s && (qn.fromBufferAttribute(s, l), Xn.fromBufferAttribute(s, h), Yn.fromBufferAttribute(s, u), g.uv = en.getUV(Zn, Fn, Un, Bn, qn, Xn, Yn, new Pe)), c && (qn.fromBufferAttribute(c, l), Xn.fromBufferAttribute(c, h), Yn.fromBufferAttribute(c, u), g.uv2 = en.getUV(Zn, Fn, Un, Bn, qn, Xn, Yn, new Pe)); var y = new hn(l, h, u); en.getNormal(Fn, Un, Bn, y.normal), g.face = y } return g } Kn.prototype = Object.assign(Object.create(fr.prototype), { constructor: Kn, isMesh: !0, setDrawMode: function (t) { this.drawMode = t }, copy: function (t) { return fr.prototype.copy.call(this, t), this.drawMode = t.drawMode, void 0 !== t.morphTargetInfluences && (this.morphTargetInfluences = t.morphTargetInfluences.slice()), void 0 !== t.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, t.morphTargetDictionary)), this }, updateMorphTargets: function () { var t, e, r, n = this.geometry; if (n.isBufferGeometry) { var i = n.morphAttributes, o = Object.keys(i); if (o.length > 0) { var a = i[o[0]]; if (void 0 !== a) for (this.morphTargetInfluences = [], this.morphTargetDictionary = {}, t = 0, e = a.length; t < e; t++)r = a[t].name || String(t), this.morphTargetInfluences.push(0), this.morphTargetDictionary[r] = t } } else { var s = n.morphTargets; void 0 !== s && s.length > 0 && console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.") } }, raycast: function (t, e) { var r, n = this.geometry, i = this.material, o = this.matrixWorld; if (void 0 !== i && (null === n.boundingSphere && n.computeBoundingSphere(), zn.copy(n.boundingSphere), zn.applyMatrix4(o), !1 !== t.ray.intersectsSphere(zn) && (Nn.getInverse(o), Dn.copy(t.ray).applyMatrix4(Nn), null === n.boundingBox || !1 !== Dn.intersectsBox(n.boundingBox)))) if (this.drawMode === se) { if (n.isBufferGeometry) { var a, s, c, l, h, u, p, d, f, m = n.index, v = n.attributes.position, g = n.morphAttributes.position, y = n.morphTargetsRelative, x = n.attributes.uv, b = n.attributes.uv2, w = n.groups, _ = n.drawRange; if (null !== m) if (Array.isArray(i)) for (l = 0, u = w.length; l < u; l++)for (f = i[(d = w[l]).materialIndex], h = Math.max(d.start, _.start), p = Math.min(d.start + d.count, _.start + _.count); h < p; h += 3)a = m.getX(h), s = m.getX(h + 1), c = m.getX(h + 2), (r = $n(this, f, t, Dn, v, g, y, x, b, a, s, c)) && (r.faceIndex = Math.floor(h / 3), r.face.materialIndex = d.materialIndex, e.push(r)); else for (l = Math.max(0, _.start), u = Math.min(m.count, _.start + _.count); l < u; l += 3)a = m.getX(l), s = m.getX(l + 1), c = m.getX(l + 2), (r = $n(this, i, t, Dn, v, g, y, x, b, a, s, c)) && (r.faceIndex = Math.floor(l / 3), e.push(r)); else if (void 0 !== v) if (Array.isArray(i)) for (l = 0, u = w.length; l < u; l++)for (f = i[(d = w[l]).materialIndex], h = Math.max(d.start, _.start), p = Math.min(d.start + d.count, _.start + _.count); h < p; h += 3)(r = $n(this, f, t, Dn, v, g, y, x, b, a = h, s = h + 1, c = h + 2)) && (r.faceIndex = Math.floor(h / 3), r.face.materialIndex = d.materialIndex, e.push(r)); else for (l = Math.max(0, _.start), u = Math.min(v.count, _.start + _.count); l < u; l += 3)(r = $n(this, i, t, Dn, v, g, y, x, b, a = l, s = l + 1, c = l + 2)) && (r.faceIndex = Math.floor(l / 3), e.push(r)) } else if (n.isGeometry) { var M, S, T, E, A = Array.isArray(i), L = n.vertices, P = n.faces, R = n.faceVertexUvs[0]; R.length > 0 && (E = R); for (var C = 0, O = P.length; C < O; C++) { var I = P[C], N = A ? i[I.materialIndex] : i; if (void 0 !== N && (M = L[I.a], S = L[I.b], T = L[I.c], r = Qn(this, N, t, Dn, M, S, T, Zn))) { if (E && E[C]) { var D = E[C]; qn.copy(D[0]), Xn.copy(D[1]), Yn.copy(D[2]), r.uv = en.getUV(Zn, M, S, T, qn, Xn, Yn, new Pe) } r.face = I, r.faceIndex = C, e.push(r) } } } } else console.warn("THREE.Mesh: TriangleStripDrawMode and TriangleFanDrawMode are not supported by .raycast().") }, clone: function () { return new this.constructor(this.geometry, this.material).copy(this) } }); var ti = 0, ei = new Je, ri = new fr, ni = new Ie; function ii() { Object.defineProperty(this, "id", { value: ti += 2 }), this.uuid = Le.generateUUID(), this.name = "", this.type = "Geometry", this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [[]], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingBox = null, this.boundingSphere = null, this.elementsNeedUpdate = !1, this.verticesNeedUpdate = !1, this.uvsNeedUpdate = !1, this.normalsNeedUpdate = !1, this.colorsNeedUpdate = !1, this.lineDistancesNeedUpdate = !1, this.groupsNeedUpdate = !1 } ii.prototype = Object.assign(Object.create(Te.prototype), { constructor: ii, isGeometry: !0, applyMatrix: function (t) { for (var e = (new ze).getNormalMatrix(t), r = 0, n = this.vertices.length; r < n; r++) { this.vertices[r].applyMatrix4(t) } for (r = 0, n = this.faces.length; r < n; r++) { var i = this.faces[r]; i.normal.applyMatrix3(e).normalize(); for (var o = 0, a = i.vertexNormals.length; o < a; o++)i.vertexNormals[o].applyMatrix3(e).normalize() } return null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this.verticesNeedUpdate = !0, this.normalsNeedUpdate = !0, this }, rotateX: function (t) { return ei.makeRotationX(t), this.applyMatrix(ei), this }, rotateY: function (t) { return ei.makeRotationY(t), this.applyMatrix(ei), this }, rotateZ: function (t) { return ei.makeRotationZ(t), this.applyMatrix(ei), this }, translate: function (t, e, r) { return ei.makeTranslation(t, e, r), this.applyMatrix(ei), this }, scale: function (t, e, r) { return ei.makeScale(t, e, r), this.applyMatrix(ei), this }, lookAt: function (t) { return ri.lookAt(t), ri.updateMatrix(), this.applyMatrix(ri.matrix), this }, fromBufferGeometry: function (t) { var e = this, r = null !== t.index ? t.index.array : void 0, n = t.attributes; if (void 0 === n.position) return console.error("THREE.Geometry.fromBufferGeometry(): Position attribute required for conversion."), this; var i = n.position.array, o = void 0 !== n.normal ? n.normal.array : void 0, a = void 0 !== n.color ? n.color.array : void 0, s = void 0 !== n.uv ? n.uv.array : void 0, c = void 0 !== n.uv2 ? n.uv2.array : void 0; void 0 !== c && (this.faceVertexUvs[1] = []); for (var l = 0; l < i.length; l += 3)e.vertices.push((new Ie).fromArray(i, l)), void 0 !== a && e.colors.push((new an).fromArray(a, l)); function h(t, r, n, i) { var l = void 0 === a ? [] : [e.colors[t].clone(), e.colors[r].clone(), e.colors[n].clone()], h = new hn(t, r, n, void 0 === o ? [] : [(new Ie).fromArray(o, 3 * t), (new Ie).fromArray(o, 3 * r), (new Ie).fromArray(o, 3 * n)], l, i); e.faces.push(h), void 0 !== s && e.faceVertexUvs[0].push([(new Pe).fromArray(s, 2 * t), (new Pe).fromArray(s, 2 * r), (new Pe).fromArray(s, 2 * n)]), void 0 !== c && e.faceVertexUvs[1].push([(new Pe).fromArray(c, 2 * t), (new Pe).fromArray(c, 2 * r), (new Pe).fromArray(c, 2 * n)]) } var u = t.groups; if (u.length > 0) for (l = 0; l < u.length; l++)for (var p = u[l], d = p.start, f = d, m = d + p.count; f < m; f += 3)void 0 !== r ? h(r[f], r[f + 1], r[f + 2], p.materialIndex) : h(f, f + 1, f + 2, p.materialIndex); else if (void 0 !== r) for (l = 0; l < r.length; l += 3)h(r[l], r[l + 1], r[l + 2]); else for (l = 0; l < i.length / 3; l += 3)h(l, l + 1, l + 2); return this.computeFaceNormals(), null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone()), null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere.clone()), this }, center: function () { return this.computeBoundingBox(), this.boundingBox.getCenter(ni).negate(), this.translate(ni.x, ni.y, ni.z), this }, normalize: function () { this.computeBoundingSphere(); var t = this.boundingSphere.center, e = this.boundingSphere.radius, r = 0 === e ? 1 : 1 / e, n = new Je; return n.set(r, 0, 0, -r * t.x, 0, r, 0, -r * t.y, 0, 0, r, -r * t.z, 0, 0, 0, 1), this.applyMatrix(n), this }, computeFaceNormals: function () { for (var t = new Ie, e = new Ie, r = 0, n = this.faces.length; r < n; r++) { var i = this.faces[r], o = this.vertices[i.a], a = this.vertices[i.b], s = this.vertices[i.c]; t.subVectors(s, a), e.subVectors(o, a), t.cross(e), t.normalize(), i.normal.copy(t) } }, computeVertexNormals: function (t) { var e, r, n, i, o, a; for (void 0 === t && (t = !0), a = new Array(this.vertices.length), e = 0, r = this.vertices.length; e < r; e++)a[e] = new Ie; if (t) { var s, c, l, h = new Ie, u = new Ie; for (n = 0, i = this.faces.length; n < i; n++)o = this.faces[n], s = this.vertices[o.a], c = this.vertices[o.b], l = this.vertices[o.c], h.subVectors(l, c), u.subVectors(s, c), h.cross(u), a[o.a].add(h), a[o.b].add(h), a[o.c].add(h) } else for (this.computeFaceNormals(), n = 0, i = this.faces.length; n < i; n++)a[(o = this.faces[n]).a].add(o.normal), a[o.b].add(o.normal), a[o.c].add(o.normal); for (e = 0, r = this.vertices.length; e < r; e++)a[e].normalize(); for (n = 0, i = this.faces.length; n < i; n++) { var p = (o = this.faces[n]).vertexNormals; 3 === p.length ? (p[0].copy(a[o.a]), p[1].copy(a[o.b]), p[2].copy(a[o.c])) : (p[0] = a[o.a].clone(), p[1] = a[o.b].clone(), p[2] = a[o.c].clone()) } this.faces.length > 0 && (this.normalsNeedUpdate = !0) }, computeFlatVertexNormals: function () { var t, e, r; for (this.computeFaceNormals(), t = 0, e = this.faces.length; t < e; t++) { var n = (r = this.faces[t]).vertexNormals; 3 === n.length ? (n[0].copy(r.normal), n[1].copy(r.normal), n[2].copy(r.normal)) : (n[0] = r.normal.clone(), n[1] = r.normal.clone(), n[2] = r.normal.clone()) } this.faces.length > 0 && (this.normalsNeedUpdate = !0) }, computeMorphNormals: function () { var t, e, r, n, i; for (r = 0, n = this.faces.length; r < n; r++)for ((i = this.faces[r]).__originalFaceNormal ? i.__originalFaceNormal.copy(i.normal) : i.__originalFaceNormal = i.normal.clone(), i.__originalVertexNormals || (i.__originalVertexNormals = []), t = 0, e = i.vertexNormals.length; t < e; t++)i.__originalVertexNormals[t] ? i.__originalVertexNormals[t].copy(i.vertexNormals[t]) : i.__originalVertexNormals[t] = i.vertexNormals[t].clone(); var o = new ii; for (o.faces = this.faces, t = 0, e = this.morphTargets.length; t < e; t++) { if (!this.morphNormals[t]) { this.morphNormals[t] = {}, this.morphNormals[t].faceNormals = [], this.morphNormals[t].vertexNormals = []; var a = this.morphNormals[t].faceNormals, s = this.morphNormals[t].vertexNormals; for (r = 0, n = this.faces.length; r < n; r++)c = new Ie, l = { a: new Ie, b: new Ie, c: new Ie }, a.push(c), s.push(l) } var c, l, h = this.morphNormals[t]; for (o.vertices = this.morphTargets[t].vertices, o.computeFaceNormals(), o.computeVertexNormals(), r = 0, n = this.faces.length; r < n; r++)i = this.faces[r], c = h.faceNormals[r], l = h.vertexNormals[r], c.copy(i.normal), l.a.copy(i.vertexNormals[0]), l.b.copy(i.vertexNormals[1]), l.c.copy(i.vertexNormals[2]) } for (r = 0, n = this.faces.length; r < n; r++)(i = this.faces[r]).normal = i.__originalFaceNormal, i.vertexNormals = i.__originalVertexNormals }, computeBoundingBox: function () { null === this.boundingBox && (this.boundingBox = new Pr), this.boundingBox.setFromPoints(this.vertices) }, computeBoundingSphere: function () { null === this.boundingSphere && (this.boundingSphere = new Or), this.boundingSphere.setFromPoints(this.vertices) }, merge: function (t, e, r) { if (t && t.isGeometry) { var n, i = this.vertices.length, o = this.vertices, a = t.vertices, s = this.faces, c = t.faces, l = this.colors, h = t.colors; void 0 === r && (r = 0), void 0 !== e && (n = (new ze).getNormalMatrix(e)); for (var u = 0, p = a.length; u < p; u++) { var d = a[u].clone(); void 0 !== e && d.applyMatrix4(e), o.push(d) } for (u = 0, p = h.length; u < p; u++)l.push(h[u].clone()); for (u = 0, p = c.length; u < p; u++) { var f, m, v, g = c[u], y = g.vertexNormals, x = g.vertexColors; (f = new hn(g.a + i, g.b + i, g.c + i)).normal.copy(g.normal), void 0 !== n && f.normal.applyMatrix3(n).normalize(); for (var b = 0, w = y.length; b < w; b++)m = y[b].clone(), void 0 !== n && m.applyMatrix3(n).normalize(), f.vertexNormals.push(m); f.color.copy(g.color); for (b = 0, w = x.length; b < w; b++)v = x[b], f.vertexColors.push(v.clone()); f.materialIndex = g.materialIndex + r, s.push(f) } for (u = 0, p = t.faceVertexUvs.length; u < p; u++) { var _ = t.faceVertexUvs[u]; void 0 === this.faceVertexUvs[u] && (this.faceVertexUvs[u] = []); for (b = 0, w = _.length; b < w; b++) { for (var M = _[b], S = [], T = 0, E = M.length; T < E; T++)S.push(M[T].clone()); this.faceVertexUvs[u].push(S) } } } else console.error("THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.", t) }, mergeMesh: function (t) { t && t.isMesh ? (t.matrixAutoUpdate && t.updateMatrix(), this.merge(t.geometry, t.matrix)) : console.error("THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.", t) }, mergeVertices: function () { var t, e, r, n, i, o, a, s, c = {}, l = [], h = [], u = Math.pow(10, 4); for (r = 0, n = this.vertices.length; r < n; r++)t = this.vertices[r], void 0 === c[e = Math.round(t.x * u) + "_" + Math.round(t.y * u) + "_" + Math.round(t.z * u)] ? (c[e] = r, l.push(this.vertices[r]), h[r] = l.length - 1) : h[r] = h[c[e]]; var p = []; for (r = 0, n = this.faces.length; r < n; r++) { (i = this.faces[r]).a = h[i.a], i.b = h[i.b], i.c = h[i.c], o = [i.a, i.b, i.c]; for (var d = 0; d < 3; d++)if (o[d] === o[(d + 1) % 3]) { p.push(r); break } } for (r = p.length - 1; r >= 0; r--) { var f = p[r]; for (this.faces.splice(f, 1), a = 0, s = this.faceVertexUvs.length; a < s; a++)this.faceVertexUvs[a].splice(f, 1) } var m = this.vertices.length - l.length; return this.vertices = l, m }, setFromPoints: function (t) { this.vertices = []; for (var e = 0, r = t.length; e < r; e++) { var n = t[e]; this.vertices.push(new Ie(n.x, n.y, n.z || 0)) } return this }, sortFacesByMaterialIndex: function () { for (var t = this.faces, e = t.length, r = 0; r < e; r++)t[r]._id = r; t.sort((function (t, e) { return t.materialIndex - e.materialIndex })); var n, i, o = this.faceVertexUvs[0], a = this.faceVertexUvs[1]; o && o.length === e && (n = []), a && a.length === e && (i = []); for (r = 0; r < e; r++) { var s = t[r]._id; n && n.push(o[s]), i && i.push(a[s]) } n && (this.faceVertexUvs[0] = n), i && (this.faceVertexUvs[1] = i) }, toJSON: function () { var t = { metadata: { version: 4.5, type: "Geometry", generator: "Geometry.toJSON" } }; if (t.uuid = this.uuid, t.type = this.type, "" !== this.name && (t.name = this.name), void 0 !== this.parameters) { var e = this.parameters; for (var r in e) void 0 !== e[r] && (t[r] = e[r]); return t } for (var n = [], i = 0; i < this.vertices.length; i++) { var o = this.vertices[i]; n.push(o.x, o.y, o.z) } var a = [], s = [], c = {}, l = [], h = {}, u = [], p = {}; for (i = 0; i < this.faces.length; i++) { var d = this.faces[i], f = void 0 !== this.faceVertexUvs[0][i], m = d.normal.length() > 0, v = d.vertexNormals.length > 0, g = 1 !== d.color.r || 1 !== d.color.g || 1 !== d.color.b, y = d.vertexColors.length > 0, x = 0; if (x = M(x, 0, 0), x = M(x, 1, !0), x = M(x, 2, !1), x = M(x, 3, f), x = M(x, 4, m), x = M(x, 5, v), x = M(x, 6, g), x = M(x, 7, y), a.push(x), a.push(d.a, d.b, d.c), a.push(d.materialIndex), f) { var b = this.faceVertexUvs[0][i]; a.push(E(b[0]), E(b[1]), E(b[2])) } if (m && a.push(S(d.normal)), v) { var w = d.vertexNormals; a.push(S(w[0]), S(w[1]), S(w[2])) } if (g && a.push(T(d.color)), y) { var _ = d.vertexColors; a.push(T(_[0]), T(_[1]), T(_[2])) } } function M(t, e, r) { return r ? t | 1 << e : t & ~(1 << e) } function S(t) { var e = t.x.toString() + t.y.toString() + t.z.toString(); return void 0 !== c[e] ? c[e] : (c[e] = s.length / 3, s.push(t.x, t.y, t.z), c[e]) } function T(t) { var e = t.r.toString() + t.g.toString() + t.b.toString(); return void 0 !== h[e] ? h[e] : (h[e] = l.length, l.push(t.getHex()), h[e]) } function E(t) { var e = t.x.toString() + t.y.toString(); return void 0 !== p[e] ? p[e] : (p[e] = u.length / 2, u.push(t.x, t.y), p[e]) } return t.data = {}, t.data.vertices = n, t.data.normals = s, l.length > 0 && (t.data.colors = l), u.length > 0 && (t.data.uvs = [u]), t.data.faces = a, t }, clone: function () { return (new ii).copy(this) }, copy: function (t) { var e, r, n, i, o, a; this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [[]], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingBox = null, this.boundingSphere = null, this.name = t.name; var s = t.vertices; for (e = 0, r = s.length; e < r; e++)this.vertices.push(s[e].clone()); var c = t.colors; for (e = 0, r = c.length; e < r; e++)this.colors.push(c[e].clone()); var l = t.faces; for (e = 0, r = l.length; e < r; e++)this.faces.push(l[e].clone()); for (e = 0, r = t.faceVertexUvs.length; e < r; e++) { var h = t.faceVertexUvs[e]; for (void 0 === this.faceVertexUvs[e] && (this.faceVertexUvs[e] = []), n = 0, i = h.length; n < i; n++) { var u = h[n], p = []; for (o = 0, a = u.length; o < a; o++) { var d = u[o]; p.push(d.clone()) } this.faceVertexUvs[e].push(p) } } var f = t.morphTargets; for (e = 0, r = f.length; e < r; e++) { var m = {}; if (m.name = f[e].name, void 0 !== f[e].vertices) for (m.vertices = [], n = 0, i = f[e].vertices.length; n < i; n++)m.vertices.push(f[e].vertices[n].clone()); if (void 0 !== f[e].normals) for (m.normals = [], n = 0, i = f[e].normals.length; n < i; n++)m.normals.push(f[e].normals[n].clone()); this.morphTargets.push(m) } var v = t.morphNormals; for (e = 0, r = v.length; e < r; e++) { var g = {}; if (void 0 !== v[e].vertexNormals) for (g.vertexNormals = [], n = 0, i = v[e].vertexNormals.length; n < i; n++) { var y = v[e].vertexNormals[n], x = {}; x.a = y.a.clone(), x.b = y.b.clone(), x.c = y.c.clone(), g.vertexNormals.push(x) } if (void 0 !== v[e].faceNormals) for (g.faceNormals = [], n = 0, i = v[e].faceNormals.length; n < i; n++)g.faceNormals.push(v[e].faceNormals[n].clone()); this.morphNormals.push(g) } var b = t.skinWeights; for (e = 0, r = b.length; e < r; e++)this.skinWeights.push(b[e].clone()); var w = t.skinIndices; for (e = 0, r = w.length; e < r; e++)this.skinIndices.push(w[e].clone()); var _ = t.lineDistances; for (e = 0, r = _.length; e < r; e++)this.lineDistances.push(_[e]); var M = t.boundingBox; null !== M && (this.boundingBox = M.clone()); var S = t.boundingSphere; return null !== S && (this.boundingSphere = S.clone()), this.elementsNeedUpdate = t.elementsNeedUpdate, this.verticesNeedUpdate = t.verticesNeedUpdate, this.uvsNeedUpdate = t.uvsNeedUpdate, this.normalsNeedUpdate = t.normalsNeedUpdate, this.colorsNeedUpdate = t.colorsNeedUpdate, this.lineDistancesNeedUpdate = t.lineDistancesNeedUpdate, this.groupsNeedUpdate = t.groupsNeedUpdate, this }, dispose: function () { this.dispatchEvent({ type: "dispose" }) } }); class oi extends In { constructor(t, e, r, n, i, o) { super(), this.type = "BoxBufferGeometry", this.parameters = { width: t, height: e, depth: r, widthSegments: n, heightSegments: i, depthSegments: o }; var a = this; t = t || 1, e = e || 1, r = r || 1, n = Math.floor(n) || 1, i = Math.floor(i) || 1, o = Math.floor(o) || 1; var s = [], c = [], l = [], h = [], u = 0, p = 0; function d(t, e, r, n, i, o, d, f, m, v, g) { var y, x, b = o / m, w = d / v, _ = o / 2, M = d / 2, S = f / 2, T = m + 1, E = v + 1, A = 0, L = 0, P = new Ie; for (x = 0; x < E; x++) { var R = x * w - M; for (y = 0; y < T; y++) { var C = y * b - _; P[t] = C * n, P[e] = R * i, P[r] = S, c.push(P.x, P.y, P.z), P[t] = 0, P[e] = 0, P[r] = f > 0 ? 1 : -1, l.push(P.x, P.y, P.z), h.push(y / m), h.push(1 - x / v), A += 1 } } for (x = 0; x < v; x++)for (y = 0; y < m; y++) { var O = u + y + T * x, I = u + y + T * (x + 1), N = u + (y + 1) + T * (x + 1), D = u + (y + 1) + T * x; s.push(O, I, D), s.push(I, N, D), L += 6 } a.addGroup(p, L, g), p += L, u += A } d("z", "y", "x", -1, -1, r, e, t, o, i, 0), d("z", "y", "x", 1, -1, r, e, -t, o, i, 1), d("x", "z", "y", 1, 1, t, r, e, n, o, 2), d("x", "z", "y", 1, -1, t, r, -e, n, o, 3), d("x", "y", "z", 1, -1, t, e, r, n, i, 4), d("x", "y", "z", -1, -1, t, e, -r, n, i, 5), this.setIndex(s), this.setAttribute("position", new _n(c, 3)), this.setAttribute("normal", new _n(l, 3)), this.setAttribute("uv", new _n(h, 2)) } } function ai(t) { var e = {}; for (var r in t) for (var n in e[r] = {}, t[r]) { var i = t[r][n]; i && (i.isColor || i.isMatrix3 || i.isMatrix4 || i.isVector2 || i.isVector3 || i.isVector4 || i.isTexture) ? e[r][n] = i.clone() : Array.isArray(i) ? e[r][n] = i.slice() : e[r][n] = i } return e } function si(t) { for (var e = {}, r = 0; r < t.length; r++) { var n = ai(t[r]); for (var i in n) e[i] = n[i] } return e } var ci = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", li = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}"; function hi(t) { pn.call(this), this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.vertexShader = ci, this.fragmentShader = li, this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.extensions = { derivatives: !1, fragDepth: !1, drawBuffers: !1, shaderTextureLOD: !1 }, this.defaultAttributeValues = { color: [1, 1, 1], uv: [0, 0], uv2: [0, 0] }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, void 0 !== t && (void 0 !== t.attributes && console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."), this.setValues(t)) } function ui() { fr.call(this), this.type = "Camera", this.matrixWorldInverse = new Je, this.projectionMatrix = new Je, this.projectionMatrixInverse = new Je } function pi(t, e, r, n) { ui.call(this), this.type = "PerspectiveCamera", this.fov = void 0 !== t ? t : 50, this.zoom = 1, this.near = void 0 !== r ? r : .1, this.far = void 0 !== n ? n : 2e3, this.focus = 10, this.aspect = void 0 !== e ? e : 1, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix() } hi.prototype = Object.create(pn.prototype), hi.prototype.constructor = hi, hi.prototype.isShaderMaterial = !0, hi.prototype.copy = function (t) { return pn.prototype.copy.call(this, t), this.fragmentShader = t.fragmentShader, this.vertexShader = t.vertexShader, this.uniforms = ai(t.uniforms), this.defines = Object.assign({}, t.defines), this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.lights = t.lights, this.clipping = t.clipping, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this.extensions = t.extensions, this }, hi.prototype.toJSON = function (t) { var e = pn.prototype.toJSON.call(this, t); for (var r in e.uniforms = {}, this.uniforms) { var n = this.uniforms[r].value; n && n.isTexture ? e.uniforms[r] = { type: "t", value: n.toJSON(t).uuid } : n && n.isColor ? e.uniforms[r] = { type: "c", value: n.getHex() } : n && n.isVector2 ? e.uniforms[r] = { type: "v2", value: n.toArray() } : n && n.isVector3 ? e.uniforms[r] = { type: "v3", value: n.toArray() } : n && n.isVector4 ? e.uniforms[r] = { type: "v4", value: n.toArray() } : n && n.isMatrix3 ? e.uniforms[r] = { type: "m3", value: n.toArray() } : n && n.isMatrix4 ? e.uniforms[r] = { type: "m4", value: n.toArray() } : e.uniforms[r] = { value: n } } Object.keys(this.defines).length > 0 && (e.defines = this.defines), e.vertexShader = this.vertexShader, e.fragmentShader = this.fragmentShader; var i = {}; for (var o in this.extensions) !0 === this.extensions[o] && (i[o] = !0); return Object.keys(i).length > 0 && (e.extensions = i), e }, ui.prototype = Object.assign(Object.create(fr.prototype), { constructor: ui, isCamera: !0, copy: function (t, e) { return fr.prototype.copy.call(this, t, e), this.matrixWorldInverse.copy(t.matrixWorldInverse), this.projectionMatrix.copy(t.projectionMatrix), this.projectionMatrixInverse.copy(t.projectionMatrixInverse), this }, getWorldDirection: function (t) { void 0 === t && (console.warn("THREE.Camera: .getWorldDirection() target is now required"), t = new Ie), this.updateMatrixWorld(!0); var e = this.matrixWorld.elements; return t.set(-e[8], -e[9], -e[10]).normalize() }, updateMatrixWorld: function (t) { fr.prototype.updateMatrixWorld.call(this, t), this.matrixWorldInverse.getInverse(this.matrixWorld) }, clone: function () { return (new this.constructor).copy(this) } }), pi.prototype = Object.assign(Object.create(ui.prototype), { constructor: pi, isPerspectiveCamera: !0, copy: function (t, e) { return ui.prototype.copy.call(this, t, e), this.fov = t.fov, this.zoom = t.zoom, this.near = t.near, this.far = t.far, this.focus = t.focus, this.aspect = t.aspect, this.view = null === t.view ? null : Object.assign({}, t.view), this.filmGauge = t.filmGauge, this.filmOffset = t.filmOffset, this }, setFocalLength: function (t) { var e = .5 * this.getFilmHeight() / t; this.fov = 2 * Le.RAD2DEG * Math.atan(e), this.updateProjectionMatrix() }, getFocalLength: function () { var t = Math.tan(.5 * Le.DEG2RAD * this.fov); return .5 * this.getFilmHeight() / t }, getEffectiveFOV: function () { return 2 * Le.RAD2DEG * Math.atan(Math.tan(.5 * Le.DEG2RAD * this.fov) / this.zoom) }, getFilmWidth: function () { return this.filmGauge * Math.min(this.aspect, 1) }, getFilmHeight: function () { return this.filmGauge / Math.max(this.aspect, 1) }, setViewOffset: function (t, e, r, n, i, o) { this.aspect = t / e, null === this.view && (this.view = { enabled: !0, fullWidth: 1, fullHeight: 1, offsetX: 0, offsetY: 0, width: 1, height: 1 }), this.view.enabled = !0, this.view.fullWidth = t, this.view.fullHeight = e, this.view.offsetX = r, this.view.offsetY = n, this.view.width = i, this.view.height = o, this.updateProjectionMatrix() }, clearViewOffset: function () { null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix() }, updateProjectionMatrix: function () { var t = this.near, e = t * Math.tan(.5 * Le.DEG2RAD * this.fov) / this.zoom, r = 2 * e, n = this.aspect * r, i = -.5 * n, o = this.view; if (null !== this.view && this.view.enabled) { var a = o.fullWidth, s = o.fullHeight; i += o.offsetX * n / a, e -= o.offsetY * r / s, n *= o.width / a, r *= o.height / s } var c = this.filmOffset; 0 !== c && (i += t * c / this.getFilmWidth()), this.projectionMatrix.makePerspective(i, i + n, e, e - r, t, this.far), this.projectionMatrixInverse.getInverse(this.projectionMatrix) }, toJSON: function (t) { var e = fr.prototype.toJSON.call(this, t); return e.object.fov = this.fov, e.object.zoom = this.zoom, e.object.near = this.near, e.object.far = this.far, e.object.focus = this.focus, e.object.aspect = this.aspect, null !== this.view && (e.object.view = Object.assign({}, this.view)), e.object.filmGauge = this.filmGauge, e.object.filmOffset = this.filmOffset, e } }); var di = 90, fi = 1; function mi(t, e, r, n) { fr.call(this), this.type = "CubeCamera"; var i = new pi(di, fi, t, e); i.up.set(0, -1, 0), i.lookAt(new Ie(1, 0, 0)), this.add(i); var o = new pi(di, fi, t, e); o.up.set(0, -1, 0), o.lookAt(new Ie(-1, 0, 0)), this.add(o); var a = new pi(di, fi, t, e); a.up.set(0, 0, 1), a.lookAt(new Ie(0, 1, 0)), this.add(a); var s = new pi(di, fi, t, e); s.up.set(0, 0, -1), s.lookAt(new Ie(0, -1, 0)), this.add(s); var c = new pi(di, fi, t, e); c.up.set(0, -1, 0), c.lookAt(new Ie(0, 0, 1)), this.add(c); var l = new pi(di, fi, t, e); l.up.set(0, -1, 0), l.lookAt(new Ie(0, 0, -1)), this.add(l), n = n || { format: Pt, magFilter: dt, minFilter: dt }, this.renderTarget = new vi(r, r, n), this.renderTarget.texture.name = "CubeCamera", this.update = function (t, e) { null === this.parent && this.updateMatrixWorld(); var r = t.getRenderTarget(), n = this.renderTarget, h = n.texture.generateMipmaps; n.texture.generateMipmaps = !1, t.setRenderTarget(n, 0), t.render(e, i), t.setRenderTarget(n, 1), t.render(e, o), t.setRenderTarget(n, 2), t.render(e, a), t.setRenderTarget(n, 3), t.render(e, s), t.setRenderTarget(n, 4), t.render(e, c), n.texture.generateMipmaps = h, t.setRenderTarget(n, 5), t.render(e, l), t.setRenderTarget(r) }, this.clear = function (t, e, r, n) { for (var i = t.getRenderTarget(), o = this.renderTarget, a = 0; a < 6; a++)t.setRenderTarget(o, a), t.clear(e, r, n); t.setRenderTarget(i) } } function vi(t, e, r) { je.call(this, t, e, r) } function gi(t, e, r, n, i, o, a, s, c, l, h, u) { Be.call(this, null, o, a, s, c, l, n, i, h, u), this.image = { data: t || null, width: e || 1, height: r || 1 }, this.magFilter = void 0 !== c ? c : ht, this.minFilter = void 0 !== l ? l : ht, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1, this.needsUpdate = !0 } mi.prototype = Object.create(fr.prototype), mi.prototype.constructor = mi, vi.prototype = Object.create(je.prototype), vi.prototype.constructor = vi, vi.prototype.isWebGLRenderTargetCube = !0, vi.prototype.fromEquirectangularTexture = function (t, e) { this.texture.type = e.type, this.texture.format = e.format, this.texture.encoding = e.encoding; var r = new mr, n = { uniforms: { tEquirect: { value: null } }, vertexShader: ["varying vec3 vWorldDirection;", "vec3 transformDirection( in vec3 dir, in mat4 matrix ) {", "\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );", "}", "void main() {", "\tvWorldDirection = transformDirection( position, modelMatrix );", "\t#include <begin_vertex>", "\t#include <project_vertex>", "}"].join("\n"), fragmentShader: ["uniform sampler2D tEquirect;", "varying vec3 vWorldDirection;", "#define RECIPROCAL_PI 0.31830988618", "#define RECIPROCAL_PI2 0.15915494", "void main() {", "\tvec3 direction = normalize( vWorldDirection );", "\tvec2 sampleUV;", "\tsampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;", "\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;", "\tgl_FragColor = texture2D( tEquirect, sampleUV );", "}"].join("\n") }, i = new hi({ type: "CubemapFromEquirect", uniforms: ai(n.uniforms), vertexShader: n.vertexShader, fragmentShader: n.fragmentShader, side: h, blending: m }); i.uniforms.tEquirect.value = e; var o = new Kn(new oi(5, 5, 5), i); r.add(o); var a = new mi(1, 10, 1); return a.renderTarget = this, a.renderTarget.texture.name = "CubeCameraTexture", a.update(t, r), o.geometry.dispose(), o.material.dispose(), this }, gi.prototype = Object.create(Be.prototype), gi.prototype.constructor = gi, gi.prototype.isDataTexture = !0; var yi = new Or, xi = new Ie; function bi(t, e, r, n, i, o) { this.planes = [void 0 !== t ? t : new Hr, void 0 !== e ? e : new Hr, void 0 !== r ? r : new Hr, void 0 !== n ? n : new Hr, void 0 !== i ? i : new Hr, void 0 !== o ? o : new Hr] } Object.assign(bi.prototype, { set: function (t, e, r, n, i, o) { var a = this.planes; return a[0].copy(t), a[1].copy(e), a[2].copy(r), a[3].copy(n), a[4].copy(i), a[5].copy(o), this }, clone: function () { return (new this.constructor).copy(this) }, copy: function (t) { for (var e = this.planes, r = 0; r < 6; r++)e[r].copy(t.planes[r]); return this }, setFromMatrix: function (t) { var e = this.planes, r = t.elements, n = r[0], i = r[1], o = r[2], a = r[3], s = r[4], c = r[5], l = r[6], h = r[7], u = r[8], p = r[9], d = r[10], f = r[11], m = r[12], v = r[13], g = r[14], y = r[15]; return e[0].setComponents(a - n, h - s, f - u, y - m).normalize(), e[1].setComponents(a + n, h + s, f + u, y + m).normalize(), e[2].setComponents(a + i, h + c, f + p, y + v).normalize(), e[3].setComponents(a - i, h - c, f - p, y - v).normalize(), e[4].setComponents(a - o, h - l, f - d, y - g).normalize(), e[5].setComponents(a + o, h + l, f + d, y + g).normalize(), this }, intersectsObject: function (t) { var e = t.geometry; return null === e.boundingSphere && e.computeBoundingSphere(), yi.copy(e.boundingSphere).applyMatrix4(t.matrixWorld), this.intersectsSphere(yi) }, intersectsSprite: function (t) { return yi.center.set(0, 0, 0), yi.radius = .7071067811865476, yi.applyMatrix4(t.matrixWorld), this.intersectsSphere(yi) }, intersectsSphere: function (t) { for (var e = this.planes, r = t.center, n = -t.radius, i = 0; i < 6; i++) { if (e[i].distanceToPoint(r) < n) return !1 } return !0 }, intersectsBox: function (t) { for (var e = this.planes, r = 0; r < 6; r++) { var n = e[r]; if (xi.x = n.normal.x > 0 ? t.max.x : t.min.x, xi.y = n.normal.y > 0 ? t.max.y : t.min.y, xi.z = n.normal.z > 0 ? t.max.z : t.min.z, n.distanceToPoint(xi) < 0) return !1 } return !0 }, containsPoint: function (t) { for (var e = this.planes, r = 0; r < 6; r++)if (e[r].distanceToPoint(t) < 0) return !1; return !0 } }); var wi = { alphamap_fragment: "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif", alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif", alphatest_fragment: "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif", aomap_fragment: "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif", aomap_pars_fragment: "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif", begin_vertex: "vec3 transformed = vec3( position );", beginnormal_vertex: "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif", bsdfs: "vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\treturn vec2( -1.04, 1.04 ) * a004 + r.zw;\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n#else\n\tif( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t}\n\treturn 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nvec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );\n\tvec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;\n\treturn Fr * fresnel + F0;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + viewDir );\n\tfloat dotNL = saturate( dot( normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE  = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS  = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\treturn specularColor * brdf.x + brdf.y;\n}\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tvec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\tvec3 FssEss = F * brdf.x + brdf.y;\n\tfloat Ess = brdf.x + brdf.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie(float roughness, float NoH) {\n\tfloat invAlpha  = 1.0 / roughness;\n\tfloat cos2h = NoH * NoH;\n\tfloat sin2h = max(1.0 - cos2h, 0.0078125);\treturn (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);\n}\nfloat V_Neubelt(float NoV, float NoL) {\n\treturn saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));\n}\nvec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {\n\tvec3 N = geometry.normal;\n\tvec3 V = geometry.viewDir;\n\tvec3 H = normalize( V + L );\n\tfloat dotNH = saturate( dot( N, H ) );\n\treturn specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );\n}\n#endif", bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tfDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif", clipping_planes_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\tif ( clipped ) discard;\n\t#endif\n#endif", clipping_planes_pars_fragment: "#if NUM_CLIPPING_PLANES > 0\n\t#if ! defined( STANDARD ) && ! defined( PHONG ) && ! defined( MATCAP )\n\t\tvarying vec3 vViewPosition;\n\t#endif\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif", clipping_planes_pars_vertex: "#if NUM_CLIPPING_PLANES > 0 && ! defined( STANDARD ) && ! defined( PHONG ) && ! defined( MATCAP )\n\tvarying vec3 vViewPosition;\n#endif", clipping_planes_vertex: "#if NUM_CLIPPING_PLANES > 0 && ! defined( STANDARD ) && ! defined( PHONG ) && ! defined( MATCAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif", color_fragment: "#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif", color_pars_fragment: "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif", color_pars_vertex: "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif", color_vertex: "#ifdef USE_COLOR\n\tvColor.xyz = color.xyz;\n#endif", common: "#define PI 3.14159265359\n#define PI2 6.28318530718\n#define PI_HALF 1.5707963267949\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n  return m[ 2 ][ 3 ] == - 1.0;\n}", cube_uv_reflection_fragment: "#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_textureSize (1024.0)\nint getFaceFromDirection(vec3 direction) {\n\tvec3 absDirection = abs(direction);\n\tint face = -1;\n\tif( absDirection.x > absDirection.z ) {\n\t\tif(absDirection.x > absDirection.y )\n\t\t\tface = direction.x > 0.0 ? 0 : 3;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\telse {\n\t\tif(absDirection.z > absDirection.y )\n\t\t\tface = direction.z > 0.0 ? 2 : 5;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\treturn face;\n}\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\n\tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\n\tfloat dxRoughness = dFdx(roughness);\n\tfloat dyRoughness = dFdy(roughness);\n\tvec3 dx = dFdx( vec * scale * dxRoughness );\n\tvec3 dy = dFdy( vec * scale * dyRoughness );\n\tfloat d = max( dot( dx, dx ), dot( dy, dy ) );\n\td = clamp(d, 1.0, cubeUV_rangeClamp);\n\tfloat mipLevel = 0.5 * log2(d);\n\treturn vec2(floor(mipLevel), fract(mipLevel));\n}\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\n\tmipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\n\tfloat a = 16.0 * cubeUV_rcpTextureSize;\n\tvec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\n\tvec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\n\tfloat powScale = exp2_packed.x * exp2_packed.y;\n\tfloat scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\n\tfloat mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\n\tbool bRes = mipLevel == 0.0;\n\tscale =  bRes && (scale < a) ? a : scale;\n\tvec3 r;\n\tvec2 offset;\n\tint face = getFaceFromDirection(direction);\n\tfloat rcpPowScale = 1.0 / powScale;\n\tif( face == 0) {\n\t\tr = vec3(direction.x, -direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 1) {\n\t\tr = vec3(direction.y, direction.x, direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 2) {\n\t\tr = vec3(direction.z, direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 3) {\n\t\tr = vec3(direction.x, direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse if( face == 4) {\n\t\tr = vec3(direction.y, direction.x, -direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse {\n\t\tr = vec3(direction.z, -direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\tr = normalize(r);\n\tfloat texelOffset = 0.5 * cubeUV_rcpTextureSize;\n\tvec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\n\tvec2 base = offset + vec2( texelOffset );\n\treturn base + s * ( scale - 2.0 * texelOffset );\n}\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\nvec4 textureCubeUV( sampler2D envMap, vec3 reflectedDirection, float roughness ) {\n\tfloat roughnessVal = roughness* cubeUV_maxLods3;\n\tfloat r1 = floor(roughnessVal);\n\tfloat r2 = r1 + 1.0;\n\tfloat t = fract(roughnessVal);\n\tvec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\n\tfloat s = mipInfo.y;\n\tfloat level0 = mipInfo.x;\n\tfloat level1 = level0 + 1.0;\n\tlevel1 = level1 > 5.0 ? 5.0 : level1;\n\tlevel0 += min( floor( s + 0.5 ), 5.0 );\n\tvec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\n\tvec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\n\tvec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\n\tvec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\n\tvec4 result = mix(color10, color20, t);\n\treturn vec4(result.rgb, 1.0);\n}\n#endif", defaultnormal_vertex: "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\ttransformedNormal = mat3( instanceMatrix ) * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = normalMatrix * objectTangent;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif", displacementmap_pars_vertex: "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif", displacementmap_vertex: "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif", emissivemap_fragment: "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif", emissivemap_pars_fragment: "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif", encodings_fragment: "gl_FragColor = linearToOutputTexel( gl_FragColor );", encodings_pars_fragment: "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = min( floor( D ) / 255.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}", envmap_fragment: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\t\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t}  else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\tvec2 sampleUV;\n\t\treflectVec = normalize( reflectVec );\n\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\n\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\treflectVec = normalize( reflectVec );\n\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\tenvColor = envMapTexelToLinear( envColor );\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif", envmap_common_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif", envmap_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif", envmap_pars_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif", envmap_physical_pars_fragment: "#if defined( USE_ENVMAP )\n\t#ifdef ENVMAP_MODE_REFRACTION\n\t\tuniform float refractionRatio;\n\t#endif\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, queryVec, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat sigma = PI * roughness * roughness / ( 1.0 + roughness );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + log2( sigma );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t  vec3 reflectVec = reflect( -viewDir, normal );\n\t\t  reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t#else\n\t\t  vec3 reflectVec = refract( -viewDir, normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, queryReflectVec, roughness );\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\t\tvec2 sampleUV;\n\t\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif", envmap_vertex: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) { \n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif", fog_vertex: "#ifdef USE_FOG\n\tfogDepth = -mvPosition.z;\n#endif", fog_pars_vertex: "#ifdef USE_FOG\n\tvarying float fogDepth;\n#endif", fog_fragment: "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif", fog_pars_fragment: "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif", gradientmap_pars_fragment: "#ifdef TOON\n\tuniform sampler2D gradientMap;\n\tvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\t\tfloat dotNL = dot( normal, lightDirection );\n\t\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t\t#ifdef USE_GRADIENTMAP\n\t\t\treturn texture2D( gradientMap, coord ).rgb;\n\t\t#else\n\t\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t\t#endif\n\t}\n#endif", lightmap_fragment: "#ifdef USE_LIGHTMAP\n\treflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n#endif", lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif", lights_lambert_vertex: "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n#endif", lights_pars_begin: "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\n\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t\tfloat shadowCameraNear;\n\t\tfloat shadowCameraFar;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif", lights_phong_fragment: "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;", lights_phong_pars_fragment: "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifdef TOON\n\t\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#else\n\t\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\t\tvec3 irradiance = dotNL * directLight.color;\n\t#endif\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)", lights_physical_fragment: "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\n#ifdef REFLECTIVITY\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#endif\n#ifdef CLEARCOAT\n\tmaterial.clearcoat = saturate( clearcoat );\tmaterial.clearcoatRoughness = clamp( clearcoatRoughness, 0.04, 1.0 );\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheen;\n#endif", lights_physical_pars_fragment: "struct PhysicalMaterial {\n\tvec3\tdiffuseColor;\n\tfloat\tspecularRoughness;\n\tvec3\tspecularColor;\n#ifdef CLEARCOAT\n\tfloat clearcoat;\n\tfloat clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tvec3 sheenColor;\n#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearcoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = ccDotNL * directLight.color;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tccIrradiance *= PI;\n\t\t#endif\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t\treflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(\n\t\t\tmaterial.specularRoughness,\n\t\t\tdirectLight.direction,\n\t\t\tgeometry,\n\t\t\tmaterial.sheenColor\n\t\t);\n\t#else\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularRoughness);\n\t#endif\n\treflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t\tfloat ccDotNL = ccDotNV;\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\tfloat clearcoatInv = 1.0 - clearcoatDHR;\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\tBRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\treflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}", lights_fragment_begin: "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tdirectLight.color *= all( bvec3( pointLight.shadow, directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tdirectLight.color *= all( bvec3( spotLight.shadow, directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectLight.color *= all( bvec3( directionalLight.shadow, directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif", lights_fragment_maps: "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );\n\t#ifdef CLEARCOAT\n\t\tclearcoatRadiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );\n\t#endif\n#endif", lights_fragment_end: "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif", logdepthbuf_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif", logdepthbuf_pars_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif", logdepthbuf_pars_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif", logdepthbuf_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif", map_fragment: "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif", map_pars_fragment: "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif", map_particle_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif", map_particle_pars_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif", metalnessmap_fragment: "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif", metalnessmap_pars_fragment: "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif", morphnormal_vertex: "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n#endif", morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifndef USE_MORPHNORMALS\n\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif", morphtarget_vertex: "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t#endif\n#endif", normal_fragment_begin: "#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t\tbitangent = bitangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;", normal_fragment_maps: "#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( -vViewPosition, normal, mapN );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif", normalmap_pars_fragment: "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tfloat scale = sign( st1.t * st0.s - st0.t * st1.s );\n\t\tvec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\n\t\tvec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );\n\t\tvec3 N = normalize( surf_norm );\n\t\tmat3 tsn = mat3( S, T, N );\n\t\tmapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\treturn normalize( tsn * mapN );\n\t}\n#endif", clearcoat_normal_fragment_begin: "#ifdef CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif", clearcoat_normal_fragment_maps: "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN );\n\t#endif\n#endif", clearcoat_normalmap_pars_fragment: "#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif", packing: "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);\n}\nvec2 unpack2HalfToRGBA( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}", premultiplied_alpha_fragment: "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif", project_vertex: "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;", dithering_fragment: "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif", dithering_pars_fragment: "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif", roughnessmap_fragment: "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif", roughnessmap_pars_fragment: "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif", shadowmap_pars_fragment: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpack2HalfToRGBA( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\n\t\tconst vec2 offset = vec2( 0.0, 1.0 );\n\t\tvec2 texelSize = vec2( 1.0 ) / size;\n\t\tvec2 centroidUV = ( floor( uv * size - 0.5 ) + 0.5 ) * texelSize;\n\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\n\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\n\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\n\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\n\t\tvec2 f = fract( uv * size + 0.5 );\n\t\tfloat a = mix( lb, lt, f.y );\n\t\tfloat b = mix( rb, rt, f.y );\n\t\tfloat c = mix( a, b, f.x );\n\t\treturn c;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tshadow = (\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif", shadowmap_pars_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif", shadowmap_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n#endif", shadowmask_pars_fragment: "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLight directionalLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tshadow *= all( bvec2( directionalLight.shadow, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLight spotLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tshadow *= all( bvec2( spotLight.shadow, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLight pointLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tshadow *= all( bvec2( pointLight.shadow, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#endif\n\t#endif\n\treturn shadow;\n}", skinbase_vertex: "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif", skinning_pars_vertex: "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform highp sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif", skinning_vertex: "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif", skinnormal_vertex: "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif", specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif", specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif", tonemapping_fragment: "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif", tonemapping_pars_fragment: "#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( ( color * ( 2.51 * color + 0.03 ) ) / ( color * ( 2.43 * color + 0.59 ) + 0.14 ) );\n}", uv_pars_fragment: "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif", uv_pars_vertex: "#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif", uv_vertex: "#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif", uv2_pars_fragment: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif", uv2_pars_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n#endif", uv2_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = uv2;\n#endif", worldpos_vertex: "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif", background_frag: "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}", background_vert: "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}", cube_frag: "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldDirection;\nvoid main() {\n\tvec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}", cube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}", depth_frag: "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - gl_FragCoord.z ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\n\t#endif\n}", depth_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}", distanceRGBA_frag: "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}", distanceRGBA_vert: "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}", equirect_frag: "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV;\n\tsampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}", equirect_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}", linedashed_frag: "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}", linedashed_vert: "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\tvLineDistance = scale * lineDistance;\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}", meshbasic_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\treflectedLight.indirectDiffuse += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}", meshbasic_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}", meshlambert_frag: "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}", meshlambert_vert: "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}", meshmatcap_frag: "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}", meshmatcap_vert: "#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#ifndef FLAT_SHADED\n\t\tvNormal = normalize( transformedNormal );\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}", meshphong_frag: "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}", meshphong_vert: "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}", meshphysical_frag: "#define STANDARD\n#ifdef PHYSICAL\n\t#define REFLECTIVITY\n\t#define CLEARCOAT\n\t#define TRANSPARENCY\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef TRANSPARENCY\n\tuniform float transparency;\n#endif\n#ifdef REFLECTIVITY\n\tuniform float reflectivity;\n#endif\n#ifdef CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheen;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#ifdef TRANSPARENCY\n\t\tdiffuseColor.a *= saturate( 1. - transparency + linearToRelativeLuminance( reflectedLight.directSpecular + reflectedLight.indirectSpecular ) );\n\t#endif\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}", meshphysical_vert: "#define STANDARD\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}", normal_frag: "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}", normal_vert: "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}", points_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}", points_vert: "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}", shadow_frag: "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <fog_fragment>\n}", shadow_vert: "#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}", sprite_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}", sprite_vert: "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}" }, _i = { common: { diffuse: { value: new an(15658734) }, opacity: { value: 1 }, map: { value: null }, uvTransform: { value: new ze }, alphaMap: { value: null } }, specularmap: { specularMap: { value: null } }, envmap: { envMap: { value: null }, flipEnvMap: { value: -1 }, reflectivity: { value: 1 }, refractionRatio: { value: .98 }, maxMipLevel: { value: 0 } }, aomap: { aoMap: { value: null }, aoMapIntensity: { value: 1 } }, lightmap: { lightMap: { value: null }, lightMapIntensity: { value: 1 } }, emissivemap: { emissiveMap: { value: null } }, bumpmap: { bumpMap: { value: null }, bumpScale: { value: 1 } }, normalmap: { normalMap: { value: null }, normalScale: { value: new Pe(1, 1) } }, displacementmap: { displacementMap: { value: null }, displacementScale: { value: 1 }, displacementBias: { value: 0 } }, roughnessmap: { roughnessMap: { value: null } }, metalnessmap: { metalnessMap: { value: null } }, gradientmap: { gradientMap: { value: null } }, fog: { fogDensity: { value: 25e-5 }, fogNear: { value: 1 }, fogFar: { value: 2e3 }, fogColor: { value: new an(16777215) } }, lights: { ambientLightColor: { value: [] }, lightProbe: { value: [] }, directionalLights: { value: [], properties: { direction: {}, color: {}, shadow: {}, shadowBias: {}, shadowRadius: {}, shadowMapSize: {} } }, directionalShadowMap: { value: [] }, directionalShadowMatrix: { value: [] }, spotLights: { value: [], properties: { color: {}, position: {}, direction: {}, distance: {}, coneCos: {}, penumbraCos: {}, decay: {}, shadow: {}, shadowBias: {}, shadowRadius: {}, shadowMapSize: {} } }, spotShadowMap: { value: [] }, spotShadowMatrix: { value: [] }, pointLights: { value: [], properties: { color: {}, position: {}, decay: {}, distance: {}, shadow: {}, shadowBias: {}, shadowRadius: {}, shadowMapSize: {}, shadowCameraNear: {}, shadowCameraFar: {} } }, pointShadowMap: { value: [] }, pointShadowMatrix: { value: [] }, hemisphereLights: { value: [], properties: { direction: {}, skyColor: {}, groundColor: {} } }, rectAreaLights: { value: [], properties: { color: {}, position: {}, width: {}, height: {} } } }, points: { diffuse: { value: new an(15658734) }, opacity: { value: 1 }, size: { value: 1 }, scale: { value: 1 }, map: { value: null }, alphaMap: { value: null }, uvTransform: { value: new ze } }, sprite: { diffuse: { value: new an(15658734) }, opacity: { value: 1 }, center: { value: new Pe(.5, .5) }, rotation: { value: 0 }, map: { value: null }, alphaMap: { value: null }, uvTransform: { value: new ze } } }, Mi = { basic: { uniforms: si([_i.common, _i.specularmap, _i.envmap, _i.aomap, _i.lightmap, _i.fog]), vertexShader: wi.meshbasic_vert, fragmentShader: wi.meshbasic_frag }, lambert: { uniforms: si([_i.common, _i.specularmap, _i.envmap, _i.aomap, _i.lightmap, _i.emissivemap, _i.fog, _i.lights, { emissive: { value: new an(0) } }]), vertexShader: wi.meshlambert_vert, fragmentShader: wi.meshlambert_frag }, phong: { uniforms: si([_i.common, _i.specularmap, _i.envmap, _i.aomap, _i.lightmap, _i.emissivemap, _i.bumpmap, _i.normalmap, _i.displacementmap, _i.gradientmap, _i.fog, _i.lights, { emissive: { value: new an(0) }, specular: { value: new an(1118481) }, shininess: { value: 30 } }]), vertexShader: wi.meshphong_vert, fragmentShader: wi.meshphong_frag }, standard: { uniforms: si([_i.common, _i.envmap, _i.aomap, _i.lightmap, _i.emissivemap, _i.bumpmap, _i.normalmap, _i.displacementmap, _i.roughnessmap, _i.metalnessmap, _i.fog, _i.lights, { emissive: { value: new an(0) }, roughness: { value: .5 }, metalness: { value: .5 }, envMapIntensity: { value: 1 } }]), vertexShader: wi.meshphysical_vert, fragmentShader: wi.meshphysical_frag }, matcap: { uniforms: si([_i.common, _i.bumpmap, _i.normalmap, _i.displacementmap, _i.fog, { matcap: { value: null } }]), vertexShader: wi.meshmatcap_vert, fragmentShader: wi.meshmatcap_frag }, points: { uniforms: si([_i.points, _i.fog]), vertexShader: wi.points_vert, fragmentShader: wi.points_frag }, dashed: { uniforms: si([_i.common, _i.fog, { scale: { value: 1 }, dashSize: { value: 1 }, totalSize: { value: 2 } }]), vertexShader: wi.linedashed_vert, fragmentShader: wi.linedashed_frag }, depth: { uniforms: si([_i.common, _i.displacementmap]), vertexShader: wi.depth_vert, fragmentShader: wi.depth_frag }, normal: { uniforms: si([_i.common, _i.bumpmap, _i.normalmap, _i.displacementmap, { opacity: { value: 1 } }]), vertexShader: wi.normal_vert, fragmentShader: wi.normal_frag }, sprite: { uniforms: si([_i.sprite, _i.fog]), vertexShader: wi.sprite_vert, fragmentShader: wi.sprite_frag }, background: { uniforms: { uvTransform: { value: new ze }, t2D: { value: null } }, vertexShader: wi.background_vert, fragmentShader: wi.background_frag }, cube: { uniforms: { tCube: { value: null }, tFlip: { value: -1 }, opacity: { value: 1 } }, vertexShader: wi.cube_vert, fragmentShader: wi.cube_frag }, equirect: { uniforms: { tEquirect: { value: null } }, vertexShader: wi.equirect_vert, fragmentShader: wi.equirect_frag }, distanceRGBA: { uniforms: si([_i.common, _i.displacementmap, { referencePosition: { value: new Ie }, nearDistance: { value: 1 }, farDistance: { value: 1e3 } }]), vertexShader: wi.distanceRGBA_vert, fragmentShader: wi.distanceRGBA_frag }, shadow: { uniforms: si([_i.lights, _i.fog, { color: { value: new an(0) }, opacity: { value: 1 } }]), vertexShader: wi.shadow_vert, fragmentShader: wi.shadow_frag } }; function Si() { var t = null, e = !1, r = null; function n(i, o) { !1 !== e && (r(i, o), t.requestAnimationFrame(n)) } return { start: function () { !0 !== e && null !== r && (t.requestAnimationFrame(n), e = !0) }, stop: function () { e = !1 }, setAnimationLoop: function (t) { r = t }, setContext: function (e) { t = e } } } function Ti(t) { var e = new WeakMap; return { get: function (t) { return t.isInterleavedBufferAttribute && (t = t.data), e.get(t) }, remove: function (r) { r.isInterleavedBufferAttribute && (r = r.data); var n = e.get(r); n && (t.deleteBuffer(n.buffer), e.delete(r)) }, update: function (r, n) { r.isInterleavedBufferAttribute && (r = r.data); var i = e.get(r); void 0 === i ? e.set(r, function (e, r) { var n = e.array, i = e.usage, o = t.createBuffer(); t.bindBuffer(r, o), t.bufferData(r, n, i), e.onUploadCallback(); var a = 5126; return n instanceof Float32Array ? a = 5126 : n instanceof Float64Array ? console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.") : n instanceof Uint16Array ? a = 5123 : n instanceof Int16Array ? a = 5122 : n instanceof Uint32Array ? a = 5125 : n instanceof Int32Array ? a = 5124 : n instanceof Int8Array ? a = 5120 : n instanceof Uint8Array && (a = 5121), { buffer: o, type: a, bytesPerElement: n.BYTES_PER_ELEMENT, version: e.version } }(r, n)) : i.version < r.version && (!function (e, r, n) { var i = r.array, o = r.updateRange; t.bindBuffer(n, e), -1 === o.count ? t.bufferSubData(n, 0, i) : (t.bufferSubData(n, o.offset * i.BYTES_PER_ELEMENT, i.subarray(o.offset, o.offset + o.count)), o.count = -1) }(i.buffer, r, n), i.version = r.version) } } } function Ei(t, e, r, n) { ii.call(this), this.type = "PlaneGeometry", this.parameters = { width: t, height: e, widthSegments: r, heightSegments: n }, this.fromBufferGeometry(new Ai(t, e, r, n)), this.mergeVertices() } function Ai(t, e, r, n) { In.call(this), this.type = "PlaneBufferGeometry", this.parameters = { width: t, height: e, widthSegments: r, heightSegments: n }; var i, o, a = (t = t || 1) / 2, s = (e = e || 1) / 2, c = Math.floor(r) || 1, l = Math.floor(n) || 1, h = c + 1, u = l + 1, p = t / c, d = e / l, f = [], m = [], v = [], g = []; for (o = 0; o < u; o++) { var y = o * d - s; for (i = 0; i < h; i++) { var x = i * p - a; m.push(x, -y, 0), v.push(0, 0, 1), g.push(i / c), g.push(1 - o / l) } } for (o = 0; o < l; o++)for (i = 0; i < c; i++) { var b = i + h * o, w = i + h * (o + 1), _ = i + 1 + h * (o + 1), M = i + 1 + h * o; f.push(b, w, M), f.push(w, _, M) } this.setIndex(f), this.setAttribute("position", new _n(m, 3)), this.setAttribute("normal", new _n(v, 3)), this.setAttribute("uv", new _n(g, 2)) } function Li(t, e, r, n) { var i, o, a = new an(0), s = 0, c = null, u = 0; function p(t, r) { e.buffers.color.setClear(t.r, t.g, t.b, r, n) } return { getClearColor: function () { return a }, setClearColor: function (t, e) { a.set(t), p(a, s = void 0 !== e ? e : 1) }, getClearAlpha: function () { return s }, setClearAlpha: function (t) { p(a, s = t) }, render: function (e, n, d, f) { var m = n.background, v = t.vr, g = v.getSession && v.getSession(); if (g && "additive" === g.environmentBlendMode && (m = null), null === m ? (p(a, s), c = null, u = 0) : m && m.isColor && (p(m, 1), f = !0, c = null, u = 0), (t.autoClear || f) && t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil), m && (m.isCubeTexture || m.isWebGLRenderTargetCube)) { void 0 === o && ((o = new Kn(new oi(1, 1, 1), new hi({ type: "BackgroundCubeMaterial", uniforms: ai(Mi.cube.uniforms), vertexShader: Mi.cube.vertexShader, fragmentShader: Mi.cube.fragmentShader, side: h, depthTest: !1, depthWrite: !1, fog: !1 }))).geometry.deleteAttribute("normal"), o.geometry.deleteAttribute("uv"), o.onBeforeRender = function (t, e, r) { this.matrixWorld.copyPosition(r.matrixWorld) }, Object.defineProperty(o.material, "map", { get: function () { return this.uniforms.tCube.value } }), r.update(o)); var y = m.isWebGLRenderTargetCube ? m.texture : m; o.material.uniforms.tCube.value = y, o.material.uniforms.tFlip.value = m.isWebGLRenderTargetCube ? 1 : -1, c === m && u === y.version || (o.material.needsUpdate = !0, c = m, u = y.version), e.unshift(o, o.geometry, o.material, 0, 0, null) } else m && m.isTexture && (void 0 === i && ((i = new Kn(new Ai(2, 2), new hi({ type: "BackgroundMaterial", uniforms: ai(Mi.background.uniforms), vertexShader: Mi.background.vertexShader, fragmentShader: Mi.background.fragmentShader, side: l, depthTest: !1, depthWrite: !1, fog: !1 }))).geometry.deleteAttribute("normal"), Object.defineProperty(i.material, "map", { get: function () { return this.uniforms.t2D.value } }), r.update(i)), i.material.uniforms.t2D.value = m, !0 === m.matrixAutoUpdate && m.updateMatrix(), i.material.uniforms.uvTransform.value.copy(m.matrix), c === m && u === m.version || (i.material.needsUpdate = !0, c = m, u = m.version), e.unshift(i, i.geometry, i.material, 0, 0, null)) } } } function Pi(t, e, r, n) { var i, o = n.isWebGL2; this.setMode = function (t) { i = t }, this.render = function (e, n) { t.drawArrays(i, e, n), r.update(n, i) }, this.renderInstances = function (n, a, s, c) { if (0 !== c) { var l, h; if (o) l = t, h = "drawArraysInstanced"; else if (h = "drawArraysInstancedANGLE", null === (l = e.get("ANGLE_instanced_arrays"))) return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."); l[h](i, a, s, c), r.update(s, i, c) } } } function Ri(t, e, r) { var n; function i(e) { if ("highp" === e) { if (t.getShaderPrecisionFormat(35633, 36338).precision > 0 && t.getShaderPrecisionFormat(35632, 36338).precision > 0) return "highp"; e = "mediump" } return "mediump" === e && t.getShaderPrecisionFormat(35633, 36337).precision > 0 && t.getShaderPrecisionFormat(35632, 36337).precision > 0 ? "mediump" : "lowp" } var o = "undefined" != typeof WebGL2RenderingContext && t instanceof WebGL2RenderingContext || "undefined" != typeof WebGL2ComputeRenderingContext && t instanceof WebGL2ComputeRenderingContext, a = void 0 !== r.precision ? r.precision : "highp", s = i(a); s !== a && (console.warn("THREE.WebGLRenderer:", a, "not supported, using", s, "instead."), a = s); var c = !0 === r.logarithmicDepthBuffer, l = t.getParameter(34930), h = t.getParameter(35660), u = t.getParameter(3379), p = t.getParameter(34076), d = t.getParameter(34921), f = t.getParameter(36347), m = t.getParameter(36348), v = t.getParameter(36349), g = h > 0, y = o || !!e.get("OES_texture_float"); return { isWebGL2: o, getMaxAnisotropy: function () { if (void 0 !== n) return n; var r = e.get("EXT_texture_filter_anisotropic"); return n = null !== r ? t.getParameter(r.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0 }, getMaxPrecision: i, precision: a, logarithmicDepthBuffer: c, maxTextures: l, maxVertexTextures: h, maxTextureSize: u, maxCubemapSize: p, maxAttributes: d, maxVertexUniforms: f, maxVaryings: m, maxFragmentUniforms: v, vertexTextures: g, floatFragmentTextures: y, floatVertexTextures: g && y, maxSamples: o ? t.getParameter(36183) : 0 } } function Ci() { var t = this, e = null, r = 0, n = !1, i = !1, o = new Hr, a = new ze, s = { value: null, needsUpdate: !1 }; function c() { s.value !== e && (s.value = e, s.needsUpdate = r > 0), t.numPlanes = r, t.numIntersection = 0 } function l(e, r, n, i) { var c = null !== e ? e.length : 0, l = null; if (0 !== c) { if (l = s.value, !0 !== i || null === l) { var h = n + 4 * c, u = r.matrixWorldInverse; a.getNormalMatrix(u), (null === l || l.length < h) && (l = new Float32Array(h)); for (var p = 0, d = n; p !== c; ++p, d += 4)o.copy(e[p]).applyMatrix4(u, a), o.normal.toArray(l, d), l[d + 3] = o.constant } s.value = l, s.needsUpdate = !0 } return t.numPlanes = c, l } this.uniform = s, this.numPlanes = 0, this.numIntersection = 0, this.init = function (t, i, o) { var a = 0 !== t.length || i || 0 !== r || n; return n = i, e = l(t, o, 0), r = t.length, a }, this.beginShadows = function () { i = !0, l(null) }, this.endShadows = function () { i = !1, c() }, this.setState = function (t, o, a, h, u, p) { if (!n || null === t || 0 === t.length || i && !a) i ? l(null) : c(); else { var d = i ? 0 : r, f = 4 * d, m = u.clippingState || null; s.value = m, m = l(t, h, f, p); for (var v = 0; v !== f; ++v)m[v] = e[v]; u.clippingState = m, this.numIntersection = o ? this.numPlanes : 0, this.numPlanes += d } } } function Oi(t) { var e = {}; return { get: function (r) { if (void 0 !== e[r]) return e[r]; var n; switch (r) { case "WEBGL_depth_texture": n = t.getExtension("WEBGL_depth_texture") || t.getExtension("MOZ_WEBGL_depth_texture") || t.getExtension("WEBKIT_WEBGL_depth_texture"); break; case "EXT_texture_filter_anisotropic": n = t.getExtension("EXT_texture_filter_anisotropic") || t.getExtension("MOZ_EXT_texture_filter_anisotropic") || t.getExtension("WEBKIT_EXT_texture_filter_anisotropic"); break; case "WEBGL_compressed_texture_s3tc": n = t.getExtension("WEBGL_compressed_texture_s3tc") || t.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc"); break; case "WEBGL_compressed_texture_pvrtc": n = t.getExtension("WEBGL_compressed_texture_pvrtc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"); break; default: n = t.getExtension(r) }return null === n && console.warn("THREE.WebGLRenderer: " + r + " extension not supported."), e[r] = n, n } } } function Ii(t, e, r) { var n = new WeakMap, i = new WeakMap; function o(t) { var a = t.target, s = n.get(a); for (var c in null !== s.index && e.remove(s.index), s.attributes) e.remove(s.attributes[c]); a.removeEventListener("dispose", o), n.delete(a); var l = i.get(s); l && (e.remove(l), i.delete(s)), r.memory.geometries-- } function a(t) { var r = [], n = t.index, o = t.attributes.position, a = 0; if (null !== n) { var s = n.array; a = n.version; for (var c = 0, l = s.length; c < l; c += 3) { var h = s[c + 0], u = s[c + 1], p = s[c + 2]; r.push(h, u, u, p, p, h) } } else { s = o.array; a = o.version; for (c = 0, l = s.length / 3 - 1; c < l; c += 3) { h = c + 0, u = c + 1, p = c + 2; r.push(h, u, u, p, p, h) } } var d = new (Tn(r) > 65535 ? wn : xn)(r, 1); d.version = a, e.update(d, 34963); var f = i.get(t); f && e.remove(f), i.set(t, d) } return { get: function (t, e) { var i = n.get(e); return i || (e.addEventListener("dispose", o), e.isBufferGeometry ? i = e : e.isGeometry && (void 0 === e._bufferGeometry && (e._bufferGeometry = (new In).setFromObject(t)), i = e._bufferGeometry), n.set(e, i), r.memory.geometries++, i) }, update: function (t) { var r = t.index, n = t.attributes; for (var i in null !== r && e.update(r, 34963), n) e.update(n[i], 34962); var o = t.morphAttributes; for (var i in o) for (var a = o[i], s = 0, c = a.length; s < c; s++)e.update(a[s], 34962) }, getWireframeAttribute: function (t) { var e = i.get(t); if (e) { var r = t.index; null !== r && e.version < r.version && a(t) } else a(t); return i.get(t) } } } function Ni(t, e, r, n) { var i, o, a, s = n.isWebGL2; this.setMode = function (t) { i = t }, this.setIndex = function (t) { o = t.type, a = t.bytesPerElement }, this.render = function (e, n) { t.drawElements(i, n, o, e * a), r.update(n, i) }, this.renderInstances = function (n, c, l, h) { if (0 !== h) { var u, p; if (s) u = t, p = "drawElementsInstanced"; else if (p = "drawElementsInstancedANGLE", null === (u = e.get("ANGLE_instanced_arrays"))) return void console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."); u[p](i, l, o, c * a, h), r.update(l, i, h) } } } function Di(t) { var e = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 }; return { memory: { geometries: 0, textures: 0 }, render: e, programs: null, autoReset: !0, reset: function () { e.frame++, e.calls = 0, e.triangles = 0, e.points = 0, e.lines = 0 }, update: function (t, r, n) { switch (n = n || 1, e.calls++, r) { case 4: e.triangles += n * (t / 3); break; case 5: case 6: e.triangles += n * (t - 2); break; case 1: e.lines += n * (t / 2); break; case 3: e.lines += n * (t - 1); break; case 2: e.lines += n * t; break; case 0: e.points += n * t; break; default: console.error("THREE.WebGLInfo: Unknown draw mode:", r) } } } } function zi(t, e) { return Math.abs(e[1]) - Math.abs(t[1]) } function Fi(t) { var e = {}, r = new Float32Array(8); return { update: function (n, i, o, a) { var s = n.morphTargetInfluences, c = s.length, l = e[i.id]; if (void 0 === l) { l = []; for (var h = 0; h < c; h++)l[h] = [h, 0]; e[i.id] = l } var u = o.morphTargets && i.morphAttributes.position, p = o.morphNormals && i.morphAttributes.normal; for (h = 0; h < c; h++) { 0 !== (f = l[h])[1] && (u && i.deleteAttribute("morphTarget" + h), p && i.deleteAttribute("morphNormal" + h)) } for (h = 0; h < c; h++) { (f = l[h])[0] = h, f[1] = s[h] } l.sort(zi); var d = 0; for (h = 0; h < 8; h++) { var f; if (f = l[h]) { var m = f[0], v = f[1]; if (v) { u && i.setAttribute("morphTarget" + h, u[m]), p && i.setAttribute("morphNormal" + h, p[m]), r[h] = v, d += v; continue } } r[h] = 0 } var g = i.morphTargetsRelative ? 1 : 1 - d; a.getUniforms().setValue(t, "morphTargetBaseInfluence", g), a.getUniforms().setValue(t, "morphTargetInfluences", r) } } } function Ui(t, e, r, n) { var i = {}; return { update: function (t) { var o = n.render.frame, a = t.geometry, s = e.get(t, a); return i[s.id] !== o && (a.isGeometry && s.updateFromObject(t), e.update(s), i[s.id] = o), t.isInstancedMesh && r.update(t.instanceMatrix, 34962), s }, dispose: function () { i = {} } } } function Bi(t, e, r, n, i, o, a, s, c, l) { t = void 0 !== t ? t : [], e = void 0 !== e ? e : tt, a = void 0 !== a ? a : Pt, Be.call(this, t, e, r, n, i, o, a, s, c, l), this.flipY = !1 } function ki(t, e, r, n) { Be.call(this, null), this.image = { data: t || null, width: e || 1, height: r || 1, depth: n || 1 }, this.magFilter = ht, this.minFilter = ht, this.wrapR = ct, this.generateMipmaps = !1, this.flipY = !1, this.needsUpdate = !0 } function ji(t, e, r, n) { Be.call(this, null), this.image = { data: t || null, width: e || 1, height: r || 1, depth: n || 1 }, this.magFilter = ht, this.minFilter = ht, this.wrapR = ct, this.generateMipmaps = !1, this.flipY = !1, this.needsUpdate = !0 } Mi.physical = { uniforms: si([Mi.standard.uniforms, { transparency: { value: 0 }, clearcoat: { value: 0 }, clearcoatRoughness: { value: 0 }, sheen: { value: new an(0) }, clearcoatNormalScale: { value: new Pe(1, 1) }, clearcoatNormalMap: { value: null } }]), vertexShader: wi.meshphysical_vert, fragmentShader: wi.meshphysical_frag }, Ei.prototype = Object.create(ii.prototype), Ei.prototype.constructor = Ei, Ai.prototype = Object.create(In.prototype), Ai.prototype.constructor = Ai, Bi.prototype = Object.create(Be.prototype), Bi.prototype.constructor = Bi, Bi.prototype.isCubeTexture = !0, Object.defineProperty(Bi.prototype, "images", { get: function () { return this.image }, set: function (t) { this.image = t } }), ki.prototype = Object.create(Be.prototype), ki.prototype.constructor = ki, ki.prototype.isDataTexture2DArray = !0, ji.prototype = Object.create(Be.prototype), ji.prototype.constructor = ji, ji.prototype.isDataTexture3D = !0; var Gi = new Be, Vi = new ki, Hi = new ji, Wi = new Bi, qi = [], Xi = [], Yi = new Float32Array(16), Zi = new Float32Array(9), Ji = new Float32Array(4); function Ki(t, e, r) { var n = t[0]; if (n <= 0 || n > 0) return t; var i = e * r, o = qi[i]; if (void 0 === o && (o = new Float32Array(i), qi[i] = o), 0 !== e) { n.toArray(o, 0); for (var a = 1, s = 0; a !== e; ++a)s += r, t[a].toArray(o, s) } return o } function Qi(t, e) { if (t.length !== e.length) return !1; for (var r = 0, n = t.length; r < n; r++)if (t[r] !== e[r]) return !1; return !0 } function $i(t, e) { for (var r = 0, n = e.length; r < n; r++)t[r] = e[r] } function to(t, e) { var r = Xi[e]; void 0 === r && (r = new Int32Array(e), Xi[e] = r); for (var n = 0; n !== e; ++n)r[n] = t.allocateTextureUnit(); return r } function eo(t, e) { var r = this.cache; r[0] !== e && (t.uniform1f(this.addr, e), r[0] = e) } function ro(t, e) { var r = this.cache; if (void 0 !== e.x) r[0] === e.x && r[1] === e.y || (t.uniform2f(this.addr, e.x, e.y), r[0] = e.x, r[1] = e.y); else { if (Qi(r, e)) return; t.uniform2fv(this.addr, e), $i(r, e) } } function no(t, e) { var r = this.cache; if (void 0 !== e.x) r[0] === e.x && r[1] === e.y && r[2] === e.z || (t.uniform3f(this.addr, e.x, e.y, e.z), r[0] = e.x, r[1] = e.y, r[2] = e.z); else if (void 0 !== e.r) r[0] === e.r && r[1] === e.g && r[2] === e.b || (t.uniform3f(this.addr, e.r, e.g, e.b), r[0] = e.r, r[1] = e.g, r[2] = e.b); else { if (Qi(r, e)) return; t.uniform3fv(this.addr, e), $i(r, e) } } function io(t, e) { var r = this.cache; if (void 0 !== e.x) r[0] === e.x && r[1] === e.y && r[2] === e.z && r[3] === e.w || (t.uniform4f(this.addr, e.x, e.y, e.z, e.w), r[0] = e.x, r[1] = e.y, r[2] = e.z, r[3] = e.w); else { if (Qi(r, e)) return; t.uniform4fv(this.addr, e), $i(r, e) } } function oo(t, e) { var r = this.cache, n = e.elements; if (void 0 === n) { if (Qi(r, e)) return; t.uniformMatrix2fv(this.addr, !1, e), $i(r, e) } else { if (Qi(r, n)) return; Ji.set(n), t.uniformMatrix2fv(this.addr, !1, Ji), $i(r, n) } } function ao(t, e) { var r = this.cache, n = e.elements; if (void 0 === n) { if (Qi(r, e)) return; t.uniformMatrix3fv(this.addr, !1, e), $i(r, e) } else { if (Qi(r, n)) return; Zi.set(n), t.uniformMatrix3fv(this.addr, !1, Zi), $i(r, n) } } function so(t, e) { var r = this.cache, n = e.elements; if (void 0 === n) { if (Qi(r, e)) return; t.uniformMatrix4fv(this.addr, !1, e), $i(r, e) } else { if (Qi(r, n)) return; Yi.set(n), t.uniformMatrix4fv(this.addr, !1, Yi), $i(r, n) } } function co(t, e, r) { var n = this.cache, i = r.allocateTextureUnit(); n[0] !== i && (t.uniform1i(this.addr, i), n[0] = i), r.safeSetTexture2D(e || Gi, i) } function lo(t, e, r) { var n = this.cache, i = r.allocateTextureUnit(); n[0] !== i && (t.uniform1i(this.addr, i), n[0] = i), r.setTexture2DArray(e || Vi, i) } function ho(t, e, r) { var n = this.cache, i = r.allocateTextureUnit(); n[0] !== i && (t.uniform1i(this.addr, i), n[0] = i), r.setTexture3D(e || Hi, i) } function uo(t, e, r) { var n = this.cache, i = r.allocateTextureUnit(); n[0] !== i && (t.uniform1i(this.addr, i), n[0] = i), r.safeSetTextureCube(e || Wi, i) } function po(t, e) { var r = this.cache; r[0] !== e && (t.uniform1i(this.addr, e), r[0] = e) } function fo(t, e) { var r = this.cache; Qi(r, e) || (t.uniform2iv(this.addr, e), $i(r, e)) } function mo(t, e) { var r = this.cache; Qi(r, e) || (t.uniform3iv(this.addr, e), $i(r, e)) } function vo(t, e) { var r = this.cache; Qi(r, e) || (t.uniform4iv(this.addr, e), $i(r, e)) } function go(t, e) { t.uniform1fv(this.addr, e) } function yo(t, e) { t.uniform1iv(this.addr, e) } function xo(t, e) { t.uniform2iv(this.addr, e) } function bo(t, e) { t.uniform3iv(this.addr, e) } function wo(t, e) { t.uniform4iv(this.addr, e) } function _o(t, e) { var r = Ki(e, this.size, 2); t.uniform2fv(this.addr, r) } function Mo(t, e) { var r = Ki(e, this.size, 3); t.uniform3fv(this.addr, r) } function So(t, e) { var r = Ki(e, this.size, 4); t.uniform4fv(this.addr, r) } function To(t, e) { var r = Ki(e, this.size, 4); t.uniformMatrix2fv(this.addr, !1, r) } function Eo(t, e) { var r = Ki(e, this.size, 9); t.uniformMatrix3fv(this.addr, !1, r) } function Ao(t, e) { var r = Ki(e, this.size, 16); t.uniformMatrix4fv(this.addr, !1, r) } function Lo(t, e, r) { var n = e.length, i = to(r, n); t.uniform1iv(this.addr, i); for (var o = 0; o !== n; ++o)r.safeSetTexture2D(e[o] || Gi, i[o]) } function Po(t, e, r) { var n = e.length, i = to(r, n); t.uniform1iv(this.addr, i); for (var o = 0; o !== n; ++o)r.safeSetTextureCube(e[o] || Wi, i[o]) } function Ro(t, e, r) { this.id = t, this.addr = r, this.cache = [], this.setValue = function (t) { switch (t) { case 5126: return eo; case 35664: return ro; case 35665: return no; case 35666: return io; case 35674: return oo; case 35675: return ao; case 35676: return so; case 35678: case 36198: return co; case 35679: return ho; case 35680: return uo; case 36289: return lo; case 5124: case 35670: return po; case 35667: case 35671: return fo; case 35668: case 35672: return mo; case 35669: case 35673: return vo } }(e.type) } function Co(t, e, r) { this.id = t, this.addr = r, this.cache = [], this.size = e.size, this.setValue = function (t) { switch (t) { case 5126: return go; case 35664: return _o; case 35665: return Mo; case 35666: return So; case 35674: return To; case 35675: return Eo; case 35676: return Ao; case 35678: return Lo; case 35680: return Po; case 5124: case 35670: return yo; case 35667: case 35671: return xo; case 35668: case 35672: return bo; case 35669: case 35673: return wo } }(e.type) } function Oo(t) { this.id = t, this.seq = [], this.map = {} } Co.prototype.updateCache = function (t) { var e = this.cache; t instanceof Float32Array && e.length !== t.length && (this.cache = new Float32Array(t.length)), $i(e, t) }, Oo.prototype.setValue = function (t, e, r) { for (var n = this.seq, i = 0, o = n.length; i !== o; ++i) { var a = n[i]; a.setValue(t, e[a.id], r) } }; var Io = /([\w\d_]+)(\])?(\[|\.)?/g; function No(t, e) { t.seq.push(e), t.map[e.id] = e } function Do(t, e, r) { var n = t.name, i = n.length; for (Io.lastIndex = 0; ;) { var o = Io.exec(n), a = Io.lastIndex, s = o[1], c = "]" === o[2], l = o[3]; if (c && (s |= 0), void 0 === l || "[" === l && a + 2 === i) { No(r, void 0 === l ? new Ro(s, t, e) : new Co(s, t, e)); break } var h = r.map[s]; void 0 === h && No(r, h = new Oo(s)), r = h } } function zo(t, e) { this.seq = [], this.map = {}; for (var r = t.getProgramParameter(e, 35718), n = 0; n < r; ++n) { var i = t.getActiveUniform(e, n); Do(i, t.getUniformLocation(e, i.name), this) } } function Fo(t, e, r) { var n = t.createShader(e); return t.shaderSource(n, r), t.compileShader(n), n } zo.prototype.setValue = function (t, e, r, n) { var i = this.map[e]; void 0 !== i && i.setValue(t, r, n) }, zo.prototype.setOptional = function (t, e, r) { var n = e[r]; void 0 !== n && this.setValue(t, r, n) }, zo.upload = function (t, e, r, n) { for (var i = 0, o = e.length; i !== o; ++i) { var a = e[i], s = r[a.id]; !1 !== s.needsUpdate && a.setValue(t, s.value, n) } }, zo.seqWithValue = function (t, e) { for (var r = [], n = 0, i = t.length; n !== i; ++n) { var o = t[n]; o.id in e && r.push(o) } return r }; var Uo = 0; function Bo(t) { switch (t) { case he: return ["Linear", "( value )"]; case ue: return ["sRGB", "( value )"]; case de: return ["RGBE", "( value )"]; case me: return ["RGBM", "( value, 7.0 )"]; case ve: return ["RGBM", "( value, 16.0 )"]; case ge: return ["RGBD", "( value, 256.0 )"]; case pe: return ["Gamma", "( value, float( GAMMA_FACTOR ) )"]; case fe: return ["LogLuv", "( value )"]; default: throw new Error("unsupported encoding: " + t) } } function ko(t, e, r) { var n = t.getShaderParameter(e, 35713), i = t.getShaderInfoLog(e).trim(); return n && "" === i ? "" : "THREE.WebGLShader: gl.getShaderInfoLog() " + r + "\n" + i + function (t) { for (var e = t.split("\n"), r = 0; r < e.length; r++)e[r] = r + 1 + ": " + e[r]; return e.join("\n") }(t.getShaderSource(e)) } function jo(t, e) { var r = Bo(e); return "vec4 " + t + "( vec4 value ) { return " + r[0] + "ToLinear" + r[1] + "; }" } function Go(t, e) { var r; switch (e) { case Z: r = "Linear"; break; case J: r = "Reinhard"; break; case K: r = "Uncharted2"; break; case Q: r = "OptimizedCineon"; break; case $: r = "ACESFilmic"; break; default: throw new Error("unsupported toneMapping: " + e) }return "vec3 " + t + "( vec3 color ) { return " + r + "ToneMapping( color ); }" } function Vo(t) { return "" !== t } function Ho(t, e) { return t.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows) } function Wo(t, e) { return t.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection) } var qo = /^[ \t]*#include +<([\w\d./]+)>/gm; function Xo(t) { return t.replace(qo, Yo) } function Yo(t, e) { var r = wi[e]; if (void 0 === r) throw new Error("Can not resolve #include <" + e + ">"); return Xo(r) } var Zo = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g; function Jo(t) { return t.replace(Zo, Ko) } function Ko(t, e, r, n) { for (var i = "", o = parseInt(e); o < parseInt(r); o++)i += n.replace(/\[ i \]/g, "[ " + o + " ]").replace(/UNROLLED_LOOP_INDEX/g, o); return i } function Qo(t) { var e = "precision " + t.precision + " float;\nprecision " + t.precision + " int;"; return "highp" === t.precision ? e += "\n#define HIGH_PRECISION" : "mediump" === t.precision ? e += "\n#define MEDIUM_PRECISION" : "lowp" === t.precision && (e += "\n#define LOW_PRECISION"), e } function $o(t, e, r, n, i, o) { var l, h, u, p, d, f = t.getContext(), m = n.defines, v = i.vertexShader, g = i.fragmentShader, y = function (t) { var e = "SHADOWMAP_TYPE_BASIC"; return t.shadowMapType === a ? e = "SHADOWMAP_TYPE_PCF" : t.shadowMapType === s ? e = "SHADOWMAP_TYPE_PCF_SOFT" : t.shadowMapType === c && (e = "SHADOWMAP_TYPE_VSM"), e }(o), x = function (t) { var e = "ENVMAP_TYPE_CUBE"; if (t.envMap) switch (t.envMapMode) { case tt: case et: e = "ENVMAP_TYPE_CUBE"; break; case ot: case at: e = "ENVMAP_TYPE_CUBE_UV"; break; case rt: case nt: e = "ENVMAP_TYPE_EQUIREC"; break; case it: e = "ENVMAP_TYPE_SPHERE" }return e }(o), b = function (t) { var e = "ENVMAP_MODE_REFLECTION"; if (t.envMap) switch (t.envMapMode) { case et: case nt: e = "ENVMAP_MODE_REFRACTION" }return e }(o), w = function (t) { var e = "ENVMAP_BLENDING_MULTIPLY"; if (t.envMap) switch (t.combine) { case W: e = "ENVMAP_BLENDING_MULTIPLY"; break; case q: e = "ENVMAP_BLENDING_MIX"; break; case X: e = "ENVMAP_BLENDING_ADD" }return e }(o), _ = t.gammaFactor > 0 ? t.gammaFactor : 1, M = o.isWebGL2 ? "" : function (t, e, r) { return [(t = t || {}).derivatives || e.envMapCubeUV || e.bumpMap || e.tangentSpaceNormalMap || e.clearcoatNormalMap || e.flatShading ? "#extension GL_OES_standard_derivatives : enable" : "", (t.fragDepth || e.logarithmicDepthBuffer) && r.get("EXT_frag_depth") ? "#extension GL_EXT_frag_depth : enable" : "", t.drawBuffers && r.get("WEBGL_draw_buffers") ? "#extension GL_EXT_draw_buffers : require" : "", (t.shaderTextureLOD || e.envMap) && r.get("EXT_shader_texture_lod") ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(Vo).join("\n") }(n.extensions, o, e), S = function (t) { var e = []; for (var r in t) { var n = t[r]; !1 !== n && e.push("#define " + r + " " + n) } return e.join("\n") }(m), T = f.createProgram(), E = o.numMultiviewViews; if (n.isRawShaderMaterial ? ((l = [S].filter(Vo).join("\n")).length > 0 && (l += "\n"), (h = [M, S].filter(Vo).join("\n")).length > 0 && (h += "\n")) : (l = [Qo(o), "#define SHADER_NAME " + i.name, S, o.instancing ? "#define USE_INSTANCING" : "", o.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", "#define GAMMA_FACTOR " + _, "#define MAX_BONES " + o.maxBones, o.useFog && o.fog ? "#define USE_FOG" : "", o.useFog && o.fogExp2 ? "#define FOG_EXP2" : "", o.map ? "#define USE_MAP" : "", o.envMap ? "#define USE_ENVMAP" : "", o.envMap ? "#define " + b : "", o.lightMap ? "#define USE_LIGHTMAP" : "", o.aoMap ? "#define USE_AOMAP" : "", o.emissiveMap ? "#define USE_EMISSIVEMAP" : "", o.bumpMap ? "#define USE_BUMPMAP" : "", o.normalMap ? "#define USE_NORMALMAP" : "", o.normalMap && o.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", o.normalMap && o.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", o.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", o.displacementMap && o.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", o.specularMap ? "#define USE_SPECULARMAP" : "", o.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", o.metalnessMap ? "#define USE_METALNESSMAP" : "", o.alphaMap ? "#define USE_ALPHAMAP" : "", o.vertexTangents ? "#define USE_TANGENT" : "", o.vertexColors ? "#define USE_COLOR" : "", o.vertexUvs ? "#define USE_UV" : "", o.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", o.flatShading ? "#define FLAT_SHADED" : "", o.skinning ? "#define USE_SKINNING" : "", o.useVertexTexture ? "#define BONE_TEXTURE" : "", o.morphTargets ? "#define USE_MORPHTARGETS" : "", o.morphNormals && !1 === o.flatShading ? "#define USE_MORPHNORMALS" : "", o.doubleSided ? "#define DOUBLE_SIDED" : "", o.flipSided ? "#define FLIP_SIDED" : "", o.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", o.shadowMapEnabled ? "#define " + y : "", o.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", o.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", o.logarithmicDepthBuffer && (o.isWebGL2 || e.get("EXT_frag_depth")) ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", " attribute mat4 instanceMatrix;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_TANGENT", "\tattribute vec4 tangent;", "#endif", "#ifdef USE_COLOR", "\tattribute vec3 color;", "#endif", "#ifdef USE_MORPHTARGETS", "\tattribute vec3 morphTarget0;", "\tattribute vec3 morphTarget1;", "\tattribute vec3 morphTarget2;", "\tattribute vec3 morphTarget3;", "\t#ifdef USE_MORPHNORMALS", "\t\tattribute vec3 morphNormal0;", "\t\tattribute vec3 morphNormal1;", "\t\tattribute vec3 morphNormal2;", "\t\tattribute vec3 morphNormal3;", "\t#else", "\t\tattribute vec3 morphTarget4;", "\t\tattribute vec3 morphTarget5;", "\t\tattribute vec3 morphTarget6;", "\t\tattribute vec3 morphTarget7;", "\t#endif", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n"].filter(Vo).join("\n"), h = [M, Qo(o), "#define SHADER_NAME " + i.name, S, o.alphaTest ? "#define ALPHATEST " + o.alphaTest + (o.alphaTest % 1 ? "" : ".0") : "", "#define GAMMA_FACTOR " + _, o.useFog && o.fog ? "#define USE_FOG" : "", o.useFog && o.fogExp2 ? "#define FOG_EXP2" : "", o.map ? "#define USE_MAP" : "", o.matcap ? "#define USE_MATCAP" : "", o.envMap ? "#define USE_ENVMAP" : "", o.envMap ? "#define " + x : "", o.envMap ? "#define " + b : "", o.envMap ? "#define " + w : "", o.lightMap ? "#define USE_LIGHTMAP" : "", o.aoMap ? "#define USE_AOMAP" : "", o.emissiveMap ? "#define USE_EMISSIVEMAP" : "", o.bumpMap ? "#define USE_BUMPMAP" : "", o.normalMap ? "#define USE_NORMALMAP" : "", o.normalMap && o.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", o.normalMap && o.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", o.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", o.specularMap ? "#define USE_SPECULARMAP" : "", o.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", o.metalnessMap ? "#define USE_METALNESSMAP" : "", o.alphaMap ? "#define USE_ALPHAMAP" : "", o.sheen ? "#define USE_SHEEN" : "", o.vertexTangents ? "#define USE_TANGENT" : "", o.vertexColors ? "#define USE_COLOR" : "", o.vertexUvs ? "#define USE_UV" : "", o.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", o.gradientMap ? "#define USE_GRADIENTMAP" : "", o.flatShading ? "#define FLAT_SHADED" : "", o.doubleSided ? "#define DOUBLE_SIDED" : "", o.flipSided ? "#define FLIP_SIDED" : "", o.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", o.shadowMapEnabled ? "#define " + y : "", o.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", o.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", o.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", o.logarithmicDepthBuffer && (o.isWebGL2 || e.get("EXT_frag_depth")) ? "#define USE_LOGDEPTHBUF_EXT" : "", (n.extensions && n.extensions.shaderTextureLOD || o.envMap) && (o.isWebGL2 || e.get("EXT_shader_texture_lod")) ? "#define TEXTURE_LOD_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", o.toneMapping !== Y ? "#define TONE_MAPPING" : "", o.toneMapping !== Y ? wi.tonemapping_pars_fragment : "", o.toneMapping !== Y ? Go("toneMapping", o.toneMapping) : "", o.dithering ? "#define DITHERING" : "", o.outputEncoding || o.mapEncoding || o.matcapEncoding || o.envMapEncoding || o.emissiveMapEncoding ? wi.encodings_pars_fragment : "", o.mapEncoding ? jo("mapTexelToLinear", o.mapEncoding) : "", o.matcapEncoding ? jo("matcapTexelToLinear", o.matcapEncoding) : "", o.envMapEncoding ? jo("envMapTexelToLinear", o.envMapEncoding) : "", o.emissiveMapEncoding ? jo("emissiveMapTexelToLinear", o.emissiveMapEncoding) : "", o.outputEncoding ? (u = "linearToOutputTexel", p = o.outputEncoding, d = Bo(p), "vec4 " + u + "( vec4 value ) { return LinearTo" + d[0] + d[1] + "; }") : "", o.depthPacking ? "#define DEPTH_PACKING " + n.depthPacking : "", "\n"].filter(Vo).join("\n")), v = Wo(v = Ho(v = Xo(v), o), o), g = Wo(g = Ho(g = Xo(g), o), o), v = Jo(v), g = Jo(g), o.isWebGL2 && !n.isRawShaderMaterial) { var A = !1, L = /^\s*#version\s+300\s+es\s*\n/; n.isShaderMaterial && null !== v.match(L) && null !== g.match(L) && (A = !0, v = v.replace(L, ""), g = g.replace(L, "")), l = ["#version 300 es\n", "#define attribute in", "#define varying out", "#define texture2D texture"].join("\n") + "\n" + l, h = ["#version 300 es\n", "#define varying in", A ? "" : "out highp vec4 pc_fragColor;", A ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join("\n") + "\n" + h, E > 0 && (l = (l = l.replace("#version 300 es\n", ["#version 300 es\n", "#extension GL_OVR_multiview2 : require", "layout(num_views = " + E + ") in;", "#define VIEW_ID gl_ViewID_OVR"].join("\n"))).replace(["uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;"].join("\n"), ["uniform mat4 modelViewMatrices[" + E + "];", "uniform mat4 projectionMatrices[" + E + "];", "uniform mat4 viewMatrices[" + E + "];", "uniform mat3 normalMatrices[" + E + "];", "#define modelViewMatrix modelViewMatrices[VIEW_ID]", "#define projectionMatrix projectionMatrices[VIEW_ID]", "#define viewMatrix viewMatrices[VIEW_ID]", "#define normalMatrix normalMatrices[VIEW_ID]"].join("\n")), h = (h = h.replace("#version 300 es\n", ["#version 300 es\n", "#extension GL_OVR_multiview2 : require", "#define VIEW_ID gl_ViewID_OVR"].join("\n"))).replace("uniform mat4 viewMatrix;", ["uniform mat4 viewMatrices[" + E + "];", "#define viewMatrix viewMatrices[VIEW_ID]"].join("\n"))) } var P, R, C = h + g, O = Fo(f, 35633, l + v), I = Fo(f, 35632, C); if (f.attachShader(T, O), f.attachShader(T, I), void 0 !== n.index0AttributeName ? f.bindAttribLocation(T, 0, n.index0AttributeName) : !0 === o.morphTargets && f.bindAttribLocation(T, 0, "position"), f.linkProgram(T), t.debug.checkShaderErrors) { var N = f.getProgramInfoLog(T).trim(), D = f.getShaderInfoLog(O).trim(), z = f.getShaderInfoLog(I).trim(), F = !0, U = !0; if (!1 === f.getProgramParameter(T, 35714)) { F = !1; var B = ko(f, O, "vertex"), k = ko(f, I, "fragment"); console.error("THREE.WebGLProgram: shader error: ", f.getError(), "35715", f.getProgramParameter(T, 35715), "gl.getProgramInfoLog", N, B, k) } else "" !== N ? console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", N) : "" !== D && "" !== z || (U = !1); U && (this.diagnostics = { runnable: F, material: n, programLog: N, vertexShader: { log: D, prefix: l }, fragmentShader: { log: z, prefix: h } }) } return f.deleteShader(O), f.deleteShader(I), this.getUniforms = function () { return void 0 === P && (P = new zo(f, T)), P }, this.getAttributes = function () { return void 0 === R && (R = function (t, e) { for (var r = {}, n = t.getProgramParameter(e, 35721), i = 0; i < n; i++) { var o = t.getActiveAttrib(e, i).name; r[o] = t.getAttribLocation(e, o) } return r }(f, T)), R }, this.destroy = function () { f.deleteProgram(T), this.program = void 0 }, this.name = i.name, this.id = Uo++, this.cacheKey = r, this.usedTimes = 1, this.program = T, this.vertexShader = O, this.fragmentShader = I, this.numMultiviewViews = E, this } function ta(t, e, r) { var n = [], i = r.isWebGL2, o = r.logarithmicDepthBuffer, a = r.floatVertexTextures, s = r.precision, c = r.maxVertexUniforms, l = r.vertexTextures, p = { MeshDepthMaterial: "depth", MeshDistanceMaterial: "distanceRGBA", MeshNormalMaterial: "normal", MeshBasicMaterial: "basic", MeshLambertMaterial: "lambert", MeshPhongMaterial: "phong", MeshToonMaterial: "phong", MeshStandardMaterial: "physical", MeshPhysicalMaterial: "physical", MeshMatcapMaterial: "matcap", LineBasicMaterial: "basic", LineDashedMaterial: "dashed", PointsMaterial: "points", ShadowMaterial: "shadow", SpriteMaterial: "sprite" }, d = ["precision", "isWebGL2", "supportsVertexTextures", "outputEncoding", "instancing", "numMultiviewViews", "map", "mapEncoding", "matcap", "matcapEncoding", "envMap", "envMapMode", "envMapEncoding", "envMapCubeUV", "lightMap", "aoMap", "emissiveMap", "emissiveMapEncoding", "bumpMap", "normalMap", "objectSpaceNormalMap", "tangentSpaceNormalMap", "clearcoatNormalMap", "displacementMap", "specularMap", "roughnessMap", "metalnessMap", "gradientMap", "alphaMap", "combine", "vertexColors", "vertexTangents", "vertexUvs", "uvsVertexOnly", "fog", "useFog", "fogExp2", "flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning", "maxBones", "useVertexTexture", "morphTargets", "morphNormals", "maxMorphTargets", "maxMorphNormals", "premultipliedAlpha", "numDirLights", "numPointLights", "numSpotLights", "numHemiLights", "numRectAreaLights", "numDirLightShadows", "numPointLightShadows", "numSpotLightShadows", "shadowMapEnabled", "shadowMapType", "toneMapping", "physicallyCorrectLights", "alphaTest", "doubleSided", "flipSided", "numClippingPlanes", "numClipIntersection", "depthPacking", "dithering", "sheen"]; function f(t, e) { var r; return t ? t.isTexture ? r = t.encoding : t.isWebGLRenderTarget && (console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."), r = t.texture.encoding) : r = he, r === he && e && (r = pe), r } this.getParameters = function (e, n, d, m, v, g, y) { var x = p[e.type], b = y.isSkinnedMesh ? function (t) { var e = t.skeleton.bones; if (a) return 1024; var r = c, n = Math.floor((r - 20) / 4), i = Math.min(n, e.length); return i < e.length ? (console.warn("THREE.WebGLRenderer: Skeleton has " + e.length + " bones. This GPU supports " + i + "."), 0) : i }(y) : 0; null !== e.precision && (s = r.getMaxPrecision(e.precision)) !== e.precision && console.warn("THREE.WebGLProgram.getParameters:", e.precision, "not supported, using", s, "instead."); var w = t.getRenderTarget(), _ = w && w.isWebGLMultiviewRenderTarget ? w.numViews : 0; return { isWebGL2: i, shaderID: x, precision: s, instancing: !0 === y.isInstancedMesh, supportsVertexTextures: l, numMultiviewViews: _, outputEncoding: f(w ? w.texture : null, t.gammaOutput), map: !!e.map, mapEncoding: f(e.map, t.gammaInput), matcap: !!e.matcap, matcapEncoding: f(e.matcap, t.gammaInput), envMap: !!e.envMap, envMapMode: e.envMap && e.envMap.mapping, envMapEncoding: f(e.envMap, t.gammaInput), envMapCubeUV: !!e.envMap && (e.envMap.mapping === ot || e.envMap.mapping === at), lightMap: !!e.lightMap, aoMap: !!e.aoMap, emissiveMap: !!e.emissiveMap, emissiveMapEncoding: f(e.emissiveMap, t.gammaInput), bumpMap: !!e.bumpMap, normalMap: !!e.normalMap, objectSpaceNormalMap: e.normalMapType === we, tangentSpaceNormalMap: e.normalMapType === be, clearcoatNormalMap: !!e.clearcoatNormalMap, displacementMap: !!e.displacementMap, roughnessMap: !!e.roughnessMap, metalnessMap: !!e.metalnessMap, specularMap: !!e.specularMap, alphaMap: !!e.alphaMap, gradientMap: !!e.gradientMap, sheen: !!e.sheen, combine: e.combine, vertexTangents: e.normalMap && e.vertexTangents, vertexColors: e.vertexColors, vertexUvs: !!(e.map || e.bumpMap || e.normalMap || e.specularMap || e.alphaMap || e.emissiveMap || e.roughnessMap || e.metalnessMap || e.clearcoatNormalMap || e.displacementMap), uvsVertexOnly: !(e.map || e.bumpMap || e.normalMap || e.specularMap || e.alphaMap || e.emissiveMap || e.roughnessMap || e.metalnessMap || e.clearcoatNormalMap || !e.displacementMap), fog: !!m, useFog: e.fog, fogExp2: m && m.isFogExp2, flatShading: e.flatShading, sizeAttenuation: e.sizeAttenuation, logarithmicDepthBuffer: o, skinning: e.skinning && b > 0, maxBones: b, useVertexTexture: a, morphTargets: e.morphTargets, morphNormals: e.morphNormals, maxMorphTargets: t.maxMorphTargets, maxMorphNormals: t.maxMorphNormals, numDirLights: n.directional.length, numPointLights: n.point.length, numSpotLights: n.spot.length, numRectAreaLights: n.rectArea.length, numHemiLights: n.hemi.length, numDirLightShadows: n.directionalShadowMap.length, numPointLightShadows: n.pointShadowMap.length, numSpotLightShadows: n.spotShadowMap.length, numClippingPlanes: v, numClipIntersection: g, dithering: e.dithering, shadowMapEnabled: t.shadowMap.enabled && d.length > 0, shadowMapType: t.shadowMap.type, toneMapping: e.toneMapped ? t.toneMapping : Y, physicallyCorrectLights: t.physicallyCorrectLights, premultipliedAlpha: e.premultipliedAlpha, alphaTest: e.alphaTest, doubleSided: e.side === u, flipSided: e.side === h, depthPacking: void 0 !== e.depthPacking && e.depthPacking } }, this.getProgramCacheKey = function (e, r) { var n = []; if (r.shaderID ? n.push(r.shaderID) : (n.push(e.fragmentShader), n.push(e.vertexShader)), void 0 !== e.defines) for (var i in e.defines) n.push(i), n.push(e.defines[i]); for (var o = 0; o < d.length; o++)n.push(r[d[o]]); return n.push(e.onBeforeCompile.toString()), n.push(t.gammaOutput), n.push(t.gammaFactor), n.join() }, this.acquireProgram = function (r, i, o, a) { for (var s, c = 0, l = n.length; c < l; c++) { var h = n[c]; if (h.cacheKey === a) { ++(s = h).usedTimes; break } } return void 0 === s && (s = new $o(t, e, a, r, i, o), n.push(s)), s }, this.releaseProgram = function (t) { if (0 == --t.usedTimes) { var e = n.indexOf(t); n[e] = n[n.length - 1], n.pop(), t.destroy() } }, this.programs = n } function ea() { var t = new WeakMap; return { get: function (e) { var r = t.get(e); return void 0 === r && (r = {}, t.set(e, r)), r }, remove: function (e) { t.delete(e) }, update: function (e, r, n) { t.get(e)[r] = n }, dispose: function () { t = new WeakMap } } } function ra(t, e) { return t.groupOrder !== e.groupOrder ? t.groupOrder - e.groupOrder : t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.program !== e.program ? t.program.id - e.program.id : t.material.id !== e.material.id ? t.material.id - e.material.id : t.z !== e.z ? t.z - e.z : t.id - e.id } function na(t, e) { return t.groupOrder !== e.groupOrder ? t.groupOrder - e.groupOrder : t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.z !== e.z ? e.z - t.z : t.id - e.id } function ia() { var t = [], e = 0, r = [], n = [], i = { id: -1 }; function o(r, n, o, a, s, c) { var l = t[e]; return void 0 === l ? (l = { id: r.id, object: r, geometry: n, material: o, program: o.program || i, groupOrder: a, renderOrder: r.renderOrder, z: s, group: c }, t[e] = l) : (l.id = r.id, l.object = r, l.geometry = n, l.material = o, l.program = o.program || i, l.groupOrder = a, l.renderOrder = r.renderOrder, l.z = s, l.group = c), e++, l } return { opaque: r, transparent: n, init: function () { e = 0, r.length = 0, n.length = 0 }, push: function (t, e, i, a, s, c) { var l = o(t, e, i, a, s, c); (!0 === i.transparent ? n : r).push(l) }, unshift: function (t, e, i, a, s, c) { var l = o(t, e, i, a, s, c); (!0 === i.transparent ? n : r).unshift(l) }, sort: function () { r.length > 1 && r.sort(ra), n.length > 1 && n.sort(na) } } } function oa() { var t = new WeakMap; function e(r) { var n = r.target; n.removeEventListener("dispose", e), t.delete(n) } return { get: function (r, n) { var i, o = t.get(r); return void 0 === o ? (i = new ia, t.set(r, new WeakMap), t.get(r).set(n, i), r.addEventListener("dispose", e)) : void 0 === (i = o.get(n)) && (i = new ia, o.set(n, i)), i }, dispose: function () { t = new WeakMap } } } function aa() { var t = {}; return { get: function (e) { if (void 0 !== t[e.id]) return t[e.id]; var r; switch (e.type) { case "DirectionalLight": r = { direction: new Ie, color: new an, shadow: !1, shadowBias: 0, shadowRadius: 1, shadowMapSize: new Pe }; break; case "SpotLight": r = { position: new Ie, direction: new Ie, color: new an, distance: 0, coneCos: 0, penumbraCos: 0, decay: 0, shadow: !1, shadowBias: 0, shadowRadius: 1, shadowMapSize: new Pe }; break; case "PointLight": r = { position: new Ie, color: new an, distance: 0, decay: 0, shadow: !1, shadowBias: 0, shadowRadius: 1, shadowMapSize: new Pe, shadowCameraNear: 1, shadowCameraFar: 1e3 }; break; case "HemisphereLight": r = { direction: new Ie, skyColor: new an, groundColor: new an }; break; case "RectAreaLight": r = { color: new an, position: new Ie, halfWidth: new Ie, halfHeight: new Ie } }return t[e.id] = r, r } } } var sa = 0; function ca(t, e) { return (e.castShadow ? 1 : 0) - (t.castShadow ? 1 : 0) } function la() { for (var t = new aa, e = { version: 0, hash: { directionalLength: -1, pointLength: -1, spotLength: -1, rectAreaLength: -1, hemiLength: -1, numDirectionalShadows: -1, numPointShadows: -1, numSpotShadows: -1 }, ambient: [0, 0, 0], probe: [], directional: [], directionalShadowMap: [], directionalShadowMatrix: [], spot: [], spotShadowMap: [], spotShadowMatrix: [], rectArea: [], point: [], pointShadowMap: [], pointShadowMatrix: [], hemi: [], numDirectionalShadows: -1, numPointShadows: -1, numSpotShadows: -1 }, r = 0; r < 9; r++)e.probe.push(new Ie); var n = new Ie, i = new Je, o = new Je; return { setup: function (r, a, s) { for (var c = 0, l = 0, h = 0, u = 0; u < 9; u++)e.probe[u].set(0, 0, 0); var p = 0, d = 0, f = 0, m = 0, v = 0, g = 0, y = 0, x = 0, b = s.matrixWorldInverse; r.sort(ca), u = 0; for (var w = r.length; u < w; u++) { var _ = r[u], M = _.color, S = _.intensity, T = _.distance, E = _.shadow && _.shadow.map ? _.shadow.map.texture : null; if (_.isAmbientLight) c += M.r * S, l += M.g * S, h += M.b * S; else if (_.isLightProbe) for (var A = 0; A < 9; A++)e.probe[A].addScaledVector(_.sh.coefficients[A], S); else if (_.isDirectionalLight) { if ((P = t.get(_)).color.copy(_.color).multiplyScalar(_.intensity), P.direction.setFromMatrixPosition(_.matrixWorld), n.setFromMatrixPosition(_.target.matrixWorld), P.direction.sub(n), P.direction.transformDirection(b), P.shadow = _.castShadow, _.castShadow) { var L = _.shadow; P.shadowBias = L.bias, P.shadowRadius = L.radius, P.shadowMapSize = L.mapSize, e.directionalShadowMap[p] = E, e.directionalShadowMatrix[p] = _.shadow.matrix, g++ } e.directional[p] = P, p++ } else if (_.isSpotLight) { if ((P = t.get(_)).position.setFromMatrixPosition(_.matrixWorld), P.position.applyMatrix4(b), P.color.copy(M).multiplyScalar(S), P.distance = T, P.direction.setFromMatrixPosition(_.matrixWorld), n.setFromMatrixPosition(_.target.matrixWorld), P.direction.sub(n), P.direction.transformDirection(b), P.coneCos = Math.cos(_.angle), P.penumbraCos = Math.cos(_.angle * (1 - _.penumbra)), P.decay = _.decay, P.shadow = _.castShadow, _.castShadow) { L = _.shadow; P.shadowBias = L.bias, P.shadowRadius = L.radius, P.shadowMapSize = L.mapSize, e.spotShadowMap[f] = E, e.spotShadowMatrix[f] = _.shadow.matrix, x++ } e.spot[f] = P, f++ } else if (_.isRectAreaLight) { (P = t.get(_)).color.copy(M).multiplyScalar(S), P.position.setFromMatrixPosition(_.matrixWorld), P.position.applyMatrix4(b), o.identity(), i.copy(_.matrixWorld), i.premultiply(b), o.extractRotation(i), P.halfWidth.set(.5 * _.width, 0, 0), P.halfHeight.set(0, .5 * _.height, 0), P.halfWidth.applyMatrix4(o), P.halfHeight.applyMatrix4(o), e.rectArea[m] = P, m++ } else if (_.isPointLight) { if ((P = t.get(_)).position.setFromMatrixPosition(_.matrixWorld), P.position.applyMatrix4(b), P.color.copy(_.color).multiplyScalar(_.intensity), P.distance = _.distance, P.decay = _.decay, P.shadow = _.castShadow, _.castShadow) { L = _.shadow; P.shadowBias = L.bias, P.shadowRadius = L.radius, P.shadowMapSize = L.mapSize, P.shadowCameraNear = L.camera.near, P.shadowCameraFar = L.camera.far, e.pointShadowMap[d] = E, e.pointShadowMatrix[d] = _.shadow.matrix, y++ } e.point[d] = P, d++ } else if (_.isHemisphereLight) { var P; (P = t.get(_)).direction.setFromMatrixPosition(_.matrixWorld), P.direction.transformDirection(b), P.direction.normalize(), P.skyColor.copy(_.color).multiplyScalar(S), P.groundColor.copy(_.groundColor).multiplyScalar(S), e.hemi[v] = P, v++ } } e.ambient[0] = c, e.ambient[1] = l, e.ambient[2] = h; var R = e.hash; R.directionalLength === p && R.pointLength === d && R.spotLength === f && R.rectAreaLength === m && R.hemiLength === v && R.numDirectionalShadows === g && R.numPointShadows === y && R.numSpotShadows === x || (e.directional.length = p, e.spot.length = f, e.rectArea.length = m, e.point.length = d, e.hemi.length = v, e.directionalShadowMap.length = g, e.pointShadowMap.length = y, e.spotShadowMap.length = x, e.directionalShadowMatrix.length = g, e.pointShadowMatrix.length = y, e.spotShadowMatrix.length = x, R.directionalLength = p, R.pointLength = d, R.spotLength = f, R.rectAreaLength = m, R.hemiLength = v, R.numDirectionalShadows = g, R.numPointShadows = y, R.numSpotShadows = x, e.version = sa++) }, state: e } } function ha() { var t = new la, e = [], r = []; return { init: function () { e.length = 0, r.length = 0 }, state: { lightsArray: e, shadowsArray: r, lights: t }, setupLights: function (n) { t.setup(e, r, n) }, pushLight: function (t) { e.push(t) }, pushShadow: function (t) { r.push(t) } } } function ua() { var t = new WeakMap; function e(r) { var n = r.target; n.removeEventListener("dispose", e), t.delete(n) } return { get: function (r, n) { var i; return !1 === t.has(r) ? (i = new ha, t.set(r, new WeakMap), t.get(r).set(n, i), r.addEventListener("dispose", e)) : !1 === t.get(r).has(n) ? (i = new ha, t.get(r).set(n, i)) : i = t.get(r).get(n), i }, dispose: function () { t = new WeakMap } } } function pa(t) { pn.call(this), this.type = "MeshDepthMaterial", this.depthPacking = ye, this.skinning = !1, this.morphTargets = !1, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.setValues(t) } function da(t) { pn.call(this), this.type = "MeshDistanceMaterial", this.referencePosition = new Ie, this.nearDistance = 1, this.farDistance = 1e3, this.skinning = !1, this.morphTargets = !1, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.fog = !1, this.setValues(t) } pa.prototype = Object.create(pn.prototype), pa.prototype.constructor = pa, pa.prototype.isMeshDepthMaterial = !0, pa.prototype.copy = function (t) { return pn.prototype.copy.call(this, t), this.depthPacking = t.depthPacking, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this }, da.prototype = Object.create(pn.prototype), da.prototype.constructor = da, da.prototype.isMeshDistanceMaterial = !0, da.prototype.copy = function (t) { return pn.prototype.copy.call(this, t), this.referencePosition.copy(t.referencePosition), this.nearDistance = t.nearDistance, this.farDistance = t.farDistance, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this }; var fa = "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n  float mean = 0.0;\n  float squared_mean = 0.0;\n\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy  ) / resolution ) );\n  for ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {\n    #ifdef HORIZONAL_PASS\n      vec2 distribution = unpack2HalfToRGBA ( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );\n      mean += distribution.x;\n      squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n    #else\n      float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0,  i )  * radius ) / resolution ) );\n      mean += depth;\n      squared_mean += depth * depth;\n    #endif\n  }\n  mean = mean * HALF_SAMPLE_RATE;\n  squared_mean = squared_mean * HALF_SAMPLE_RATE;\n  float std_dev = sqrt( squared_mean - mean * mean );\n  gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}", ma = "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}"; function va(t, e, r) { var n = new bi, i = new Pe, o = new Pe, s = new ke, p = [], d = [], f = {}, v = { 0: h, 1: l, 2: u }, g = new hi({ defines: { SAMPLE_RATE: .25, HALF_SAMPLE_RATE: 1 / 8 }, uniforms: { shadow_pass: { value: null }, resolution: { value: new Pe }, radius: { value: 4 } }, vertexShader: ma, fragmentShader: fa }), y = g.clone(); y.defines.HORIZONAL_PASS = 1; var x = new In; x.setAttribute("position", new fn(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]), 3)); var b = new Kn(x, g), w = this; function _(r, n) { var i = e.update(b); g.uniforms.shadow_pass.value = r.map.texture, g.uniforms.resolution.value = r.mapSize, g.uniforms.radius.value = r.radius, t.setRenderTarget(r.mapPass), t.clear(), t.renderBufferDirect(n, null, i, g, b, null), y.uniforms.shadow_pass.value = r.mapPass.texture, y.uniforms.resolution.value = r.mapSize, y.uniforms.radius.value = r.radius, t.setRenderTarget(r.map), t.clear(), t.renderBufferDirect(n, null, i, y, b, null) } function M(t, e, r) { var n = t << 0 | e << 1 | r << 2, i = p[n]; return void 0 === i && (i = new pa({ depthPacking: xe, morphTargets: t, skinning: e }), p[n] = i), i } function S(t, e, r) { var n = t << 0 | e << 1 | r << 2, i = d[n]; return void 0 === i && (i = new da({ morphTargets: t, skinning: e }), d[n] = i), i } function T(e, r, n, i, o, a) { var s = e.geometry, l = null, h = M, u = e.customDepthMaterial; if (!0 === n.isPointLight && (h = S, u = e.customDistanceMaterial), void 0 === u) { var p = !1; !0 === r.morphTargets && (!0 === s.isBufferGeometry ? p = s.morphAttributes && s.morphAttributes.position && s.morphAttributes.position.length > 0 : !0 === s.isGeometry && (p = s.morphTargets && s.morphTargets.length > 0)); var d = !1; !0 === e.isSkinnedMesh && (!0 === r.skinning ? d = !0 : console.warn("THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:", e)), l = h(p, d, !0 === e.isInstancedMesh) } else l = u; if (t.localClippingEnabled && !0 === r.clipShadows && 0 !== r.clippingPlanes.length) { var m = l.uuid, g = r.uuid, y = f[m]; void 0 === y && (y = {}, f[m] = y); var x = y[g]; void 0 === x && (x = l.clone(), y[g] = x), l = x } return l.visible = r.visible, l.wireframe = r.wireframe, l.side = a === c ? null !== r.shadowSide ? r.shadowSide : r.side : null !== r.shadowSide ? r.shadowSide : v[r.side], l.clipShadows = r.clipShadows, l.clippingPlanes = r.clippingPlanes, l.clipIntersection = r.clipIntersection, l.wireframeLinewidth = r.wireframeLinewidth, l.linewidth = r.linewidth, !0 === n.isPointLight && !0 === l.isMeshDistanceMaterial && (l.referencePosition.setFromMatrixPosition(n.matrixWorld), l.nearDistance = i, l.farDistance = o), l } function E(r, i, o, a, s) { if (!1 !== r.visible) { if (r.layers.test(i.layers) && (r.isMesh || r.isLine || r.isPoints) && (r.castShadow || r.receiveShadow && s === c) && (!r.frustumCulled || n.intersectsObject(r))) { r.modelViewMatrix.multiplyMatrices(o.matrixWorldInverse, r.matrixWorld); var l = e.update(r), h = r.material; if (Array.isArray(h)) for (var u = l.groups, p = 0, d = u.length; p < d; p++) { var f = u[p], m = h[f.materialIndex]; if (m && m.visible) { var v = T(r, m, a, o.near, o.far, s); t.renderBufferDirect(o, null, l, v, r, f) } } else if (h.visible) { v = T(r, h, a, o.near, o.far, s); t.renderBufferDirect(o, null, l, v, r, null) } } for (var g = r.children, y = 0, x = g.length; y < x; y++)E(g[y], i, o, a, s) } } this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = a, this.render = function (e, a, l) { if (!1 !== w.enabled && (!1 !== w.autoUpdate || !1 !== w.needsUpdate) && 0 !== e.length) { var h = t.getRenderTarget(), u = t.getActiveCubeFace(), p = t.getActiveMipmapLevel(), d = t.state; d.setBlending(m), d.buffers.color.setClear(1, 1, 1, 1), d.buffers.depth.setTest(!0), d.setScissorTest(!1); for (var f = 0, v = e.length; f < v; f++) { var g = e[f], y = g.shadow; if (void 0 !== y) { i.copy(y.mapSize); var x = y.getFrameExtents(); if (i.multiply(x), o.copy(y.mapSize), (i.x > r || i.y > r) && (console.warn("THREE.WebGLShadowMap:", g, "has shadow exceeding max texture size, reducing"), i.x > r && (o.x = Math.floor(r / x.x), i.x = o.x * x.x, y.mapSize.x = o.x), i.y > r && (o.y = Math.floor(r / x.y), i.y = o.y * x.y, y.mapSize.y = o.y)), null === y.map && !y.isPointLightShadow && this.type === c) { var b = { minFilter: dt, magFilter: dt, format: Rt }; y.map = new je(i.x, i.y, b), y.map.texture.name = g.name + ".shadowMap", y.mapPass = new je(i.x, i.y, b), y.camera.updateProjectionMatrix() } if (null === y.map) { b = { minFilter: ht, magFilter: ht, format: Rt }; y.map = new je(i.x, i.y, b), y.map.texture.name = g.name + ".shadowMap", y.camera.updateProjectionMatrix() } t.setRenderTarget(y.map), t.clear(); for (var M = y.getViewportCount(), S = 0; S < M; S++) { var T = y.getViewport(S); s.set(o.x * T.x, o.y * T.y, o.x * T.z, o.y * T.w), d.viewport(s), y.updateMatrices(g, S), n = y.getFrustum(), E(a, l, y.camera, g, this.type) } y.isPointLightShadow || this.type !== c || _(y, l) } else console.warn("THREE.WebGLShadowMap:", g, "has no shadow.") } w.needsUpdate = !1, t.setRenderTarget(h, u, p) } } } function ga(t, e, r) { var a = r.isWebGL2; var s = new function () { var e = !1, r = new ke, n = null, i = new ke(0, 0, 0, 0); return { setMask: function (r) { n === r || e || (t.colorMask(r, r, r, r), n = r) }, setLocked: function (t) { e = t }, setClear: function (e, n, o, a, s) { !0 === s && (e *= a, n *= a, o *= a), r.set(e, n, o, a), !1 === i.equals(r) && (t.clearColor(e, n, o, a), i.copy(r)) }, reset: function () { e = !1, n = null, i.set(-1, 0, 0, 0) } } }, c = new function () { var e = !1, r = null, n = null, i = null; return { setTest: function (t) { t ? xt(2929) : bt(2929) }, setMask: function (n) { r === n || e || (t.depthMask(n), r = n) }, setFunc: function (e) { if (n !== e) { if (e) switch (e) { case F: t.depthFunc(512); break; case U: t.depthFunc(519); break; case B: t.depthFunc(513); break; case k: t.depthFunc(515); break; case j: t.depthFunc(514); break; case G: t.depthFunc(518); break; case V: t.depthFunc(516); break; case H: t.depthFunc(517); break; default: t.depthFunc(515) } else t.depthFunc(515); n = e } }, setLocked: function (t) { e = t }, setClear: function (e) { i !== e && (t.clearDepth(e), i = e) }, reset: function () { e = !1, r = null, n = null, i = null } } }, l = new function () { var e = !1, r = null, n = null, i = null, o = null, a = null, s = null, c = null, l = null; return { setTest: function (t) { e || (t ? xt(2960) : bt(2960)) }, setMask: function (n) { r === n || e || (t.stencilMask(n), r = n) }, setFunc: function (e, r, a) { n === e && i === r && o === a || (t.stencilFunc(e, r, a), n = e, i = r, o = a) }, setOp: function (e, r, n) { a === e && s === r && c === n || (t.stencilOp(e, r, n), a = e, s = r, c = n) }, setLocked: function (t) { e = t }, setClear: function (e) { l !== e && (t.clearStencil(e), l = e) }, reset: function () { e = !1, r = null, n = null, i = null, o = null, a = null, s = null, c = null, l = null } } }, p = t.getParameter(34921), d = new Uint8Array(p), f = new Uint8Array(p), W = new Uint8Array(p), q = {}, X = null, Y = null, Z = null, J = null, K = null, Q = null, $ = null, tt = null, et = null, rt = !1, nt = null, it = null, ot = null, at = null, st = null, ct = t.getParameter(35661), lt = !1, ht = 0, ut = t.getParameter(7938); -1 !== ut.indexOf("WebGL") ? (ht = parseFloat(/^WebGL\ ([0-9])/.exec(ut)[1]), lt = ht >= 1) : -1 !== ut.indexOf("OpenGL ES") && (ht = parseFloat(/^OpenGL\ ES\ ([0-9])/.exec(ut)[1]), lt = ht >= 2); var pt = null, dt = {}, ft = new ke, mt = new ke; function vt(e, r, n) { var i = new Uint8Array(4), o = t.createTexture(); t.bindTexture(e, o), t.texParameteri(e, 10241, 9728), t.texParameteri(e, 10240, 9728); for (var a = 0; a < n; a++)t.texImage2D(r + a, 0, 6408, 1, 1, 0, 6408, 5121, i); return o } var gt = {}; function yt(r, n) { (d[r] = 1, 0 === f[r] && (t.enableVertexAttribArray(r), f[r] = 1), W[r] !== n) && ((a ? t : e.get("ANGLE_instanced_arrays"))[a ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](r, n), W[r] = n) } function xt(e) { !0 !== q[e] && (t.enable(e), q[e] = !0) } function bt(e) { !1 !== q[e] && (t.disable(e), q[e] = !1) } gt[3553] = vt(3553, 3553, 1), gt[34067] = vt(34067, 34069, 6), s.setClear(0, 0, 0, 1), c.setClear(1), l.setClear(0), xt(2929), c.setFunc(k), Tt(!1), Et(i), xt(2884), St(m); var wt = { [w]: 32774, [_]: 32778, [M]: 32779 }; if (a) wt[S] = 32775, wt[T] = 32776; else { var _t = e.get("EXT_blend_minmax"); null !== _t && (wt[S] = _t.MIN_EXT, wt[T] = _t.MAX_EXT) } var Mt = { [E]: 0, [A]: 1, [L]: 768, [R]: 770, [z]: 776, [N]: 774, [O]: 772, [P]: 769, [C]: 771, [D]: 775, [I]: 773 }; function St(e, r, n, i, o, a, s, c) { if (e !== m) { if (Y || (xt(3042), Y = !0), e === b) o = o || r, a = a || n, s = s || i, r === J && o === $ || (t.blendEquationSeparate(wt[r], wt[o]), J = r, $ = o), n === K && i === Q && a === tt && s === et || (t.blendFuncSeparate(Mt[n], Mt[i], Mt[a], Mt[s]), K = n, Q = i, tt = a, et = s), Z = e, rt = null; else if (e !== Z || c !== rt) { if (J === w && $ === w || (t.blendEquation(32774), J = w, $ = w), c) switch (e) { case v: t.blendFuncSeparate(1, 771, 1, 771); break; case g: t.blendFunc(1, 1); break; case y: t.blendFuncSeparate(0, 0, 769, 771); break; case x: t.blendFuncSeparate(0, 768, 0, 770); break; default: console.error("THREE.WebGLState: Invalid blending: ", e) } else switch (e) { case v: t.blendFuncSeparate(770, 771, 1, 771); break; case g: t.blendFunc(770, 1); break; case y: t.blendFunc(0, 769); break; case x: t.blendFunc(0, 768); break; default: console.error("THREE.WebGLState: Invalid blending: ", e) }K = null, Q = null, tt = null, et = null, Z = e, rt = c } } else Y && (bt(3042), Y = !1) } function Tt(e) { nt !== e && (e ? t.frontFace(2304) : t.frontFace(2305), nt = e) } function Et(e) { e !== n ? (xt(2884), e !== it && (e === i ? t.cullFace(1029) : e === o ? t.cullFace(1028) : t.cullFace(1032))) : bt(2884), it = e } function At(e, r, n) { e ? (xt(32823), at === r && st === n || (t.polygonOffset(r, n), at = r, st = n)) : bt(32823) } function Lt(e) { void 0 === e && (e = 33984 + ct - 1), pt !== e && (t.activeTexture(e), pt = e) } return { buffers: { color: s, depth: c, stencil: l }, initAttributes: function () { for (var t = 0, e = d.length; t < e; t++)d[t] = 0 }, enableAttribute: function (t) { yt(t, 0) }, enableAttributeAndDivisor: yt, disableUnusedAttributes: function () { for (var e = 0, r = f.length; e !== r; ++e)f[e] !== d[e] && (t.disableVertexAttribArray(e), f[e] = 0) }, enable: xt, disable: bt, useProgram: function (e) { return X !== e && (t.useProgram(e), X = e, !0) }, setBlending: St, setMaterial: function (t, e) { t.side === u ? bt(2884) : xt(2884); var r = t.side === h; e && (r = !r), Tt(r), t.blending === v && !1 === t.transparent ? St(m) : St(t.blending, t.blendEquation, t.blendSrc, t.blendDst, t.blendEquationAlpha, t.blendSrcAlpha, t.blendDstAlpha, t.premultipliedAlpha), c.setFunc(t.depthFunc), c.setTest(t.depthTest), c.setMask(t.depthWrite), s.setMask(t.colorWrite); var n = t.stencilWrite; l.setTest(n), n && (l.setMask(t.stencilWriteMask), l.setFunc(t.stencilFunc, t.stencilRef, t.stencilFuncMask), l.setOp(t.stencilFail, t.stencilZFail, t.stencilZPass)), At(t.polygonOffset, t.polygonOffsetFactor, t.polygonOffsetUnits) }, setFlipSided: Tt, setCullFace: Et, setLineWidth: function (e) { e !== ot && (lt && t.lineWidth(e), ot = e) }, setPolygonOffset: At, setScissorTest: function (t) { t ? xt(3089) : bt(3089) }, activeTexture: Lt, bindTexture: function (e, r) { null === pt && Lt(); var n = dt[pt]; void 0 === n && (n = { type: void 0, texture: void 0 }, dt[pt] = n), n.type === e && n.texture === r || (t.bindTexture(e, r || gt[e]), n.type = e, n.texture = r) }, unbindTexture: function () { var e = dt[pt]; void 0 !== e && void 0 !== e.type && (t.bindTexture(e.type, null), e.type = void 0, e.texture = void 0) }, compressedTexImage2D: function () { try { t.compressedTexImage2D.apply(t, arguments) } catch (t) { console.error("THREE.WebGLState:", t) } }, texImage2D: function () { try { t.texImage2D.apply(t, arguments) } catch (t) { console.error("THREE.WebGLState:", t) } }, texImage3D: function () { try { t.texImage3D.apply(t, arguments) } catch (t) { console.error("THREE.WebGLState:", t) } }, scissor: function (e) { !1 === ft.equals(e) && (t.scissor(e.x, e.y, e.z, e.w), ft.copy(e)) }, viewport: function (e) { !1 === mt.equals(e) && (t.viewport(e.x, e.y, e.z, e.w), mt.copy(e)) }, reset: function () { for (var e = 0; e < f.length; e++)1 === f[e] && (t.disableVertexAttribArray(e), f[e] = 0); q = {}, pt = null, dt = {}, X = null, Z = null, nt = null, it = null, s.reset(), c.reset(), l.reset() } } } function ya(t, e, r, n, i, o, a) { var s, c = i.isWebGL2, l = i.maxTextures, h = i.maxCubemapSize, u = i.maxTextureSize, p = i.maxSamples, d = new WeakMap, f = "undefined" != typeof OffscreenCanvas && null !== new OffscreenCanvas(1, 1).getContext("2d"); function m(t, e) { return f ? new OffscreenCanvas(t, e) : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas") } function v(t, e, r, n) { var i = 1; if ((t.width > n || t.height > n) && (i = n / Math.max(t.width, t.height)), i < 1 || !0 === e) { if ("undefined" != typeof HTMLImageElement && t instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && t instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && t instanceof ImageBitmap) { var o = e ? Le.floorPowerOfTwo : Math.floor, a = o(i * t.width), c = o(i * t.height); void 0 === s && (s = m(a, c)); var l = r ? m(a, c) : s; return l.width = a, l.height = c, l.getContext("2d").drawImage(t, 0, 0, a, c), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + t.width + "x" + t.height + ") to (" + a + "x" + c + ")."), l } return "data" in t && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + t.width + "x" + t.height + ")."), t } return t } function g(t) { return Le.isPowerOfTwo(t.width) && Le.isPowerOfTwo(t.height) } function y(t, e) { return t.generateMipmaps && e && t.minFilter !== ht && t.minFilter !== dt } function x(e, r, i, o) { t.generateMipmap(e), n.get(r).__maxMipLevel = Math.log(Math.max(i, o)) * Math.LOG2E } function b(t, r) { if (!1 === c) return t; var n = t; return 6403 === t && (5126 === r && (n = 33326), 5131 === r && (n = 33325), 5121 === r && (n = 33321)), 6407 === t && (5126 === r && (n = 34837), 5131 === r && (n = 34843), 5121 === r && (n = 32849)), 6408 === t && (5126 === r && (n = 34836), 5131 === r && (n = 34842), 5121 === r && (n = 32856)), 33325 === n || 33326 === n || 34842 === n || 34836 === n ? e.get("EXT_color_buffer_float") : 34843 !== n && 34837 !== n || console.warn("THREE.WebGLRenderer: Floating point textures with RGB format not supported. Please use RGBA instead."), n } function w(t) { return t === ht || t === ut || t === pt ? 9728 : 9729 } function _(e) { var r = e.target; r.removeEventListener("dispose", _), function (e) { var r = n.get(e); if (void 0 === r.__webglInit) return; t.deleteTexture(r.__webglTexture), n.remove(e) }(r), r.isVideoTexture && d.delete(r), a.memory.textures-- } function M(e) { var r = e.target; r.removeEventListener("dispose", M), function (e) { var r = n.get(e), i = n.get(e.texture); if (!e) return; void 0 !== i.__webglTexture && t.deleteTexture(i.__webglTexture); e.depthTexture && e.depthTexture.dispose(); if (e.isWebGLRenderTargetCube) for (var o = 0; o < 6; o++)t.deleteFramebuffer(r.__webglFramebuffer[o]), r.__webglDepthbuffer && t.deleteRenderbuffer(r.__webglDepthbuffer[o]); else t.deleteFramebuffer(r.__webglFramebuffer), r.__webglDepthbuffer && t.deleteRenderbuffer(r.__webglDepthbuffer); if (e.isWebGLMultiviewRenderTarget) { t.deleteTexture(r.__webglColorTexture), t.deleteTexture(r.__webglDepthStencilTexture), a.memory.textures -= 2; o = 0; for (var s = r.__webglViewFramebuffers.length; o < s; o++)t.deleteFramebuffer(r.__webglViewFramebuffers[o]) } n.remove(e.texture), n.remove(e) }(r), a.memory.textures-- } var S = 0; function T(t, e) { var i = n.get(t); if (t.isVideoTexture && function (t) { var e = a.render.frame; d.get(t) !== e && (d.set(t, e), t.update()) }(t), t.version > 0 && i.__version !== t.version) { var o = t.image; if (void 0 === o) console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined"); else { if (!1 !== o.complete) return void O(i, t, e); console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete") } } r.activeTexture(33984 + e), r.bindTexture(3553, i.__webglTexture) } function E(e, i) { if (6 === e.image.length) { var a = n.get(e); if (e.version > 0 && a.__version !== e.version) { C(a, e), r.activeTexture(33984 + i), r.bindTexture(34067, a.__webglTexture), t.pixelStorei(37440, e.flipY); for (var s = e && e.isCompressedTexture, l = e.image[0] && e.image[0].isDataTexture, u = [], p = 0; p < 6; p++)u[p] = s || l ? l ? e.image[p].image : e.image[p] : v(e.image[p], !1, !0, h); var d, f = u[0], m = g(f) || c, w = o.convert(e.format), _ = o.convert(e.type), M = b(w, _); if (R(34067, e, m), s) { for (p = 0; p < 6; p++) { d = u[p].mipmaps; for (var S = 0; S < d.length; S++) { var T = d[S]; e.format !== Rt && e.format !== Pt ? null !== w ? r.compressedTexImage2D(34069 + p, S, M, T.width, T.height, 0, T.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : r.texImage2D(34069 + p, S, M, T.width, T.height, 0, w, _, T.data) } } a.__maxMipLevel = d.length - 1 } else { d = e.mipmaps; for (p = 0; p < 6; p++)if (l) { r.texImage2D(34069 + p, 0, M, u[p].width, u[p].height, 0, w, _, u[p].data); for (S = 0; S < d.length; S++) { var E = (T = d[S]).image[p].image; r.texImage2D(34069 + p, S + 1, M, E.width, E.height, 0, w, _, E.data) } } else { r.texImage2D(34069 + p, 0, M, w, _, u[p]); for (S = 0; S < d.length; S++) { T = d[S]; r.texImage2D(34069 + p, S + 1, M, w, _, T.image[p]) } } a.__maxMipLevel = d.length } y(e, m) && x(34067, e, f.width, f.height), a.__version = e.version, e.onUpdate && e.onUpdate(e) } else r.activeTexture(33984 + i), r.bindTexture(34067, a.__webglTexture) } } function A(t, e) { r.activeTexture(33984 + e), r.bindTexture(34067, n.get(t).__webglTexture) } var L = { [st]: 10497, [ct]: 33071, [lt]: 33648 }, P = { [ht]: 9728, [ut]: 9984, [pt]: 9986, [dt]: 9729, [ft]: 9985, [mt]: 9987 }; function R(r, o, a) { a ? (t.texParameteri(r, 10242, L[o.wrapS]), t.texParameteri(r, 10243, L[o.wrapT]), 32879 !== r && 35866 !== r || t.texParameteri(r, 32882, L[o.wrapR]), t.texParameteri(r, 10240, P[o.magFilter]), t.texParameteri(r, 10241, P[o.minFilter])) : (t.texParameteri(r, 10242, 33071), t.texParameteri(r, 10243, 33071), 32879 !== r && 35866 !== r || t.texParameteri(r, 32882, 33071), o.wrapS === ct && o.wrapT === ct || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."), t.texParameteri(r, 10240, w(o.magFilter)), t.texParameteri(r, 10241, w(o.minFilter)), o.minFilter !== ht && o.minFilter !== dt && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")); var s = e.get("EXT_texture_filter_anisotropic"); if (s) { if (o.type === _t && null === e.get("OES_texture_float_linear")) return; if (o.type === Mt && null === (c || e.get("OES_texture_half_float_linear"))) return; (o.anisotropy > 1 || n.get(o).__currentAnisotropy) && (t.texParameterf(r, s.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(o.anisotropy, i.getMaxAnisotropy())), n.get(o).__currentAnisotropy = o.anisotropy) } } function C(e, r) { void 0 === e.__webglInit && (e.__webglInit = !0, r.addEventListener("dispose", _), e.__webglTexture = t.createTexture(), a.memory.textures++) } function O(e, n, i) { var a = 3553; n.isDataTexture2DArray && (a = 35866), n.isDataTexture3D && (a = 32879), C(e, n), r.activeTexture(33984 + i), r.bindTexture(a, e.__webglTexture), t.pixelStorei(37440, n.flipY), t.pixelStorei(37441, n.premultiplyAlpha), t.pixelStorei(3317, n.unpackAlignment); var s = function (t) { return !c && (t.wrapS !== ct || t.wrapT !== ct || t.minFilter !== ht && t.minFilter !== dt) }(n) && !1 === g(n.image), l = v(n.image, s, !1, u), h = g(l) || c, p = o.convert(n.format), d = o.convert(n.type), f = b(p, d); R(a, n, h); var m, w = n.mipmaps; if (n.isDepthTexture) { if (f = 6402, n.type === _t) { if (!1 === c) throw new Error("Float Depth Texture only supported in WebGL2.0"); f = 36012 } else c && (f = 33189); n.format === It && 6402 === f && n.type !== xt && n.type !== wt && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), n.type = xt, d = o.convert(n.type)), n.format === Nt && (f = 34041, n.type !== At && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), n.type = At, d = o.convert(n.type))), r.texImage2D(3553, 0, f, l.width, l.height, 0, p, d, null) } else if (n.isDataTexture) if (w.length > 0 && h) { for (var _ = 0, M = w.length; _ < M; _++)m = w[_], r.texImage2D(3553, _, f, m.width, m.height, 0, p, d, m.data); n.generateMipmaps = !1, e.__maxMipLevel = w.length - 1 } else r.texImage2D(3553, 0, f, l.width, l.height, 0, p, d, l.data), e.__maxMipLevel = 0; else if (n.isCompressedTexture) { for (_ = 0, M = w.length; _ < M; _++)m = w[_], n.format !== Rt && n.format !== Pt ? null !== p ? r.compressedTexImage2D(3553, _, f, m.width, m.height, 0, m.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : r.texImage2D(3553, _, f, m.width, m.height, 0, p, d, m.data); e.__maxMipLevel = w.length - 1 } else if (n.isDataTexture2DArray) r.texImage3D(35866, 0, f, l.width, l.height, l.depth, 0, p, d, l.data), e.__maxMipLevel = 0; else if (n.isDataTexture3D) r.texImage3D(32879, 0, f, l.width, l.height, l.depth, 0, p, d, l.data), e.__maxMipLevel = 0; else if (w.length > 0 && h) { for (_ = 0, M = w.length; _ < M; _++)m = w[_], r.texImage2D(3553, _, f, p, d, m); n.generateMipmaps = !1, e.__maxMipLevel = w.length - 1 } else r.texImage2D(3553, 0, f, p, d, l), e.__maxMipLevel = 0; y(n, h) && x(3553, n, l.width, l.height), e.__version = n.version, n.onUpdate && n.onUpdate(n) } function I(e, i, a, s) { var c = o.convert(i.texture.format), l = o.convert(i.texture.type), h = b(c, l); r.texImage2D(s, 0, h, i.width, i.height, 0, c, l, null), t.bindFramebuffer(36160, e), t.framebufferTexture2D(36160, a, s, n.get(i.texture).__webglTexture, 0), t.bindFramebuffer(36160, null) } function N(e, r, n) { if (t.bindRenderbuffer(36161, e), r.depthBuffer && !r.stencilBuffer) { if (n) { var i = z(r); t.renderbufferStorageMultisample(36161, i, 33189, r.width, r.height) } else t.renderbufferStorage(36161, 33189, r.width, r.height); t.framebufferRenderbuffer(36160, 36096, 36161, e) } else if (r.depthBuffer && r.stencilBuffer) { if (n) { i = z(r); t.renderbufferStorageMultisample(36161, i, 35056, r.width, r.height) } else t.renderbufferStorage(36161, 34041, r.width, r.height); t.framebufferRenderbuffer(36160, 33306, 36161, e) } else { var a = b(o.convert(r.texture.format), o.convert(r.texture.type)); if (n) { i = z(r); t.renderbufferStorageMultisample(36161, i, a, r.width, r.height) } else t.renderbufferStorage(36161, a, r.width, r.height) } t.bindRenderbuffer(36161, null) } function D(e) { var r = n.get(e), i = !0 === e.isWebGLRenderTargetCube; if (e.depthTexture) { if (i) throw new Error("target.depthTexture not supported in Cube render targets"); !function (e, r) { if (r && r.isWebGLRenderTargetCube) throw new Error("Depth Texture with cube render targets is not supported"); if (t.bindFramebuffer(36160, e), !r.depthTexture || !r.depthTexture.isDepthTexture) throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture"); n.get(r.depthTexture).__webglTexture && r.depthTexture.image.width === r.width && r.depthTexture.image.height === r.height || (r.depthTexture.image.width = r.width, r.depthTexture.image.height = r.height, r.depthTexture.needsUpdate = !0), T(r.depthTexture, 0); var i = n.get(r.depthTexture).__webglTexture; if (r.depthTexture.format === It) t.framebufferTexture2D(36160, 36096, 3553, i, 0); else { if (r.depthTexture.format !== Nt) throw new Error("Unknown depthTexture format"); t.framebufferTexture2D(36160, 33306, 3553, i, 0) } }(r.__webglFramebuffer, e) } else if (i) { r.__webglDepthbuffer = []; for (var o = 0; o < 6; o++)t.bindFramebuffer(36160, r.__webglFramebuffer[o]), r.__webglDepthbuffer[o] = t.createRenderbuffer(), N(r.__webglDepthbuffer[o], e) } else t.bindFramebuffer(36160, r.__webglFramebuffer), r.__webglDepthbuffer = t.createRenderbuffer(), N(r.__webglDepthbuffer, e); t.bindFramebuffer(36160, null) } function z(t) { return c && t.isWebGLMultisampleRenderTarget ? Math.min(p, t.samples) : 0 } var F = !1, U = !1; this.allocateTextureUnit = function () { var t = S; return t >= l && console.warn("THREE.WebGLTextures: Trying to use " + t + " texture units while this GPU supports only " + l), S += 1, t }, this.resetTextureUnits = function () { S = 0 }, this.setTexture2D = T, this.setTexture2DArray = function (t, e) { var i = n.get(t); t.version > 0 && i.__version !== t.version ? O(i, t, e) : (r.activeTexture(33984 + e), r.bindTexture(35866, i.__webglTexture)) }, this.setTexture3D = function (t, e) { var i = n.get(t); t.version > 0 && i.__version !== t.version ? O(i, t, e) : (r.activeTexture(33984 + e), r.bindTexture(32879, i.__webglTexture)) }, this.setTextureCube = E, this.setTextureCubeDynamic = A, this.setupRenderTarget = function (i) { var s = n.get(i), l = n.get(i.texture); i.addEventListener("dispose", M), l.__webglTexture = t.createTexture(), a.memory.textures++; var h = !0 === i.isWebGLRenderTargetCube, u = !0 === i.isWebGLMultisampleRenderTarget, p = !0 === i.isWebGLMultiviewRenderTarget, d = g(i) || c; if (h) { s.__webglFramebuffer = []; for (var f = 0; f < 6; f++)s.__webglFramebuffer[f] = t.createFramebuffer() } else if (s.__webglFramebuffer = t.createFramebuffer(), u) if (c) { s.__webglMultisampledFramebuffer = t.createFramebuffer(), s.__webglColorRenderbuffer = t.createRenderbuffer(), t.bindRenderbuffer(36161, s.__webglColorRenderbuffer); var m = b(o.convert(i.texture.format), o.convert(i.texture.type)), v = z(i); t.renderbufferStorageMultisample(36161, v, m, i.width, i.height), t.bindFramebuffer(36160, s.__webglMultisampledFramebuffer), t.framebufferRenderbuffer(36160, 36064, 36161, s.__webglColorRenderbuffer), t.bindRenderbuffer(36161, null), i.depthBuffer && (s.__webglDepthRenderbuffer = t.createRenderbuffer(), N(s.__webglDepthRenderbuffer, i, !0)), t.bindFramebuffer(36160, null) } else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2."); else if (p) { var w = i.width, _ = i.height, S = i.numViews; t.bindFramebuffer(36160, s.__webglFramebuffer); var T = e.get("OVR_multiview2"); a.memory.textures += 2; var E = t.createTexture(); t.bindTexture(35866, E), t.texParameteri(35866, 10240, 9728), t.texParameteri(35866, 10241, 9728), t.texImage3D(35866, 0, 32856, w, _, S, 0, 6408, 5121, null), T.framebufferTextureMultiviewOVR(36160, 36064, E, 0, 0, S); var A = t.createTexture(); t.bindTexture(35866, A), t.texParameteri(35866, 10240, 9728), t.texParameteri(35866, 10241, 9728), t.texImage3D(35866, 0, 35056, w, _, S, 0, 34041, 34042, null), T.framebufferTextureMultiviewOVR(36160, 33306, A, 0, 0, S); var L = new Array(S); for (f = 0; f < S; ++f)L[f] = t.createFramebuffer(), t.bindFramebuffer(36160, L[f]), t.framebufferTextureLayer(36160, 36064, E, 0, f); s.__webglColorTexture = E, s.__webglDepthStencilTexture = A, s.__webglViewFramebuffers = L, t.bindFramebuffer(36160, null), t.bindTexture(35866, null) } if (h) { r.bindTexture(34067, l.__webglTexture), R(34067, i.texture, d); for (f = 0; f < 6; f++)I(s.__webglFramebuffer[f], i, 36064, 34069 + f); y(i.texture, d) && x(34067, i.texture, i.width, i.height), r.bindTexture(34067, null) } else p || (r.bindTexture(3553, l.__webglTexture), R(3553, i.texture, d), I(s.__webglFramebuffer, i, 36064, 3553), y(i.texture, d) && x(3553, i.texture, i.width, i.height), r.bindTexture(3553, null)); i.depthBuffer && D(i) }, this.updateRenderTargetMipmap = function (t) { var e = t.texture; if (y(e, g(t) || c)) { var i = t.isWebGLRenderTargetCube ? 34067 : 3553, o = n.get(e).__webglTexture; r.bindTexture(i, o), x(i, e, t.width, t.height), r.bindTexture(i, null) } }, this.updateMultisampleRenderTarget = function (e) { if (e.isWebGLMultisampleRenderTarget) if (c) { var r = n.get(e); t.bindFramebuffer(36008, r.__webglMultisampledFramebuffer), t.bindFramebuffer(36009, r.__webglFramebuffer); var i = e.width, o = e.height, a = 16384; e.depthBuffer && (a |= 256), e.stencilBuffer && (a |= 1024), t.blitFramebuffer(0, 0, i, o, 0, 0, i, o, a, 9728) } else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.") }, this.safeSetTexture2D = function (t, e) { t && t.isWebGLRenderTarget && (!1 === F && (console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."), F = !0), t = t.texture), T(t, e) }, this.safeSetTextureCube = function (t, e) { t && t.isWebGLRenderTargetCube && (!1 === U && (console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."), U = !0), t = t.texture), t && t.isCubeTexture || Array.isArray(t.image) && 6 === t.image.length ? E(t, e) : A(t, e) } } function xa(t, e, r) { var n = r.isWebGL2; return { convert: function (t) { var r; if (t === vt) return 5121; if (t === St) return 32819; if (t === Tt) return 32820; if (t === Et) return 33635; if (t === gt) return 5120; if (t === yt) return 5122; if (t === xt) return 5123; if (t === bt) return 5124; if (t === wt) return 5125; if (t === _t) return 5126; if (t === Mt) return n ? 5131 : null !== (r = e.get("OES_texture_half_float")) ? r.HALF_FLOAT_OES : null; if (t === Lt) return 6406; if (t === Pt) return 6407; if (t === Rt) return 6408; if (t === Ct) return 6409; if (t === Ot) return 6410; if (t === It) return 6402; if (t === Nt) return 34041; if (t === Dt) return 6403; if (t === zt || t === Ft || t === Ut || t === Bt) { if (null === (r = e.get("WEBGL_compressed_texture_s3tc"))) return null; if (t === zt) return r.COMPRESSED_RGB_S3TC_DXT1_EXT; if (t === Ft) return r.COMPRESSED_RGBA_S3TC_DXT1_EXT; if (t === Ut) return r.COMPRESSED_RGBA_S3TC_DXT3_EXT; if (t === Bt) return r.COMPRESSED_RGBA_S3TC_DXT5_EXT } if (t === kt || t === jt || t === Gt || t === Vt) { if (null === (r = e.get("WEBGL_compressed_texture_pvrtc"))) return null; if (t === kt) return r.COMPRESSED_RGB_PVRTC_4BPPV1_IMG; if (t === jt) return r.COMPRESSED_RGB_PVRTC_2BPPV1_IMG; if (t === Gt) return r.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG; if (t === Vt) return r.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG } return t === Ht ? null !== (r = e.get("WEBGL_compressed_texture_etc1")) ? r.COMPRESSED_RGB_ETC1_WEBGL : null : t === Wt || t === qt || t === Xt || t === Yt || t === Zt || t === Jt || t === Kt || t === Qt || t === $t || t === te || t === ee || t === re || t === ne || t === ie ? null !== (r = e.get("WEBGL_compressed_texture_astc")) ? t : null : t === At ? n ? 34042 : null !== (r = e.get("WEBGL_depth_texture")) ? r.UNSIGNED_INT_24_8_WEBGL : null : void 0 } } } function ba(t, e, r, n) { je.call(this, t, e, n), this.depthBuffer = !1, this.stencilBuffer = !1, this.numViews = r } function wa(t, e) { var r, n, i, o, a, s, c, l = 2, h = t.extensions, u = t.properties, p = 0; function d(t) { return t.isArrayCamera ? t.cameras : (a[0] = t, a) } this.isAvailable = function () { if (void 0 === c) { var t = h.get("OVR_multiview2"); if (c = null !== t && !1 === e.getContextAttributes().antialias) { p = e.getParameter(t.MAX_VIEWS_OVR), r = new ba(0, 0, l), s = new Pe, o = [], i = [], a = []; for (var n = 0; n < p; n++)o[n] = new Je, i[n] = new ze } } return c }, this.attachCamera = function (e) { !1 !== function (t) { if (void 0 === t.isArrayCamera) return !0; var e = t.cameras; if (e.length > p) return !1; for (var r = 1, n = e.length; r < n; r++)if (e[0].viewport.z !== e[r].viewport.z || e[0].viewport.w !== e[r].viewport.w) return !1; return !0 }(e) && (n = t.getRenderTarget(), function (e) { if (n ? s.set(n.width, n.height) : t.getDrawingBufferSize(s), e.isArrayCamera) { var i = e.cameras[0].viewport; r.setSize(i.z, i.w), r.setNumViews(e.cameras.length) } else r.setSize(s.x, s.y), r.setNumViews(l) }(e), t.setRenderTarget(r)) }, this.detachCamera = function (i) { r === t.getRenderTarget() && (t.setRenderTarget(n), function (t) { var n = r, i = n.numViews, o = u.get(n).__webglViewFramebuffers, a = n.width, c = n.height; if (t.isArrayCamera) for (var l = 0; l < i; l++) { var h = t.cameras[l].viewport, p = h.x, d = h.y, f = p + h.z, m = d + h.w; e.bindFramebuffer(36008, o[l]), e.blitFramebuffer(0, 0, a, c, p, d, f, m, 16384, 9728) } else e.bindFramebuffer(36008, o[0]), e.blitFramebuffer(0, 0, a, c, 0, 0, s.x, s.y, 16384, 9728) }(i)) }, this.updateCameraProjectionMatricesUniform = function (t, r) { for (var n = d(t), i = 0; i < n.length; i++)o[i].copy(n[i].projectionMatrix); r.setValue(e, "projectionMatrices", o) }, this.updateCameraViewMatricesUniform = function (t, r) { for (var n = d(t), i = 0; i < n.length; i++)o[i].copy(n[i].matrixWorldInverse); r.setValue(e, "viewMatrices", o) }, this.updateObjectMatricesUniforms = function (t, r, n) { for (var a = d(r), s = 0; s < a.length; s++)o[s].multiplyMatrices(a[s].matrixWorldInverse, t.matrixWorld), i[s].getNormalMatrix(o[s]); n.setValue(e, "modelViewMatrices", o), n.setValue(e, "normalMatrices", i) } } function _a() { fr.call(this), this.type = "Group" } function Ma(t) { pi.call(this), this.cameras = t || [] } ba.prototype = Object.assign(Object.create(je.prototype), { constructor: ba, isWebGLMultiviewRenderTarget: !0, copy: function (t) { return je.prototype.copy.call(this, t), this.numViews = t.numViews, this }, setNumViews: function (t) { return this.numViews !== t && (this.numViews = t, this.dispose()), this } }), _a.prototype = Object.assign(Object.create(fr.prototype), { constructor: _a, isGroup: !0 }), Ma.prototype = Object.assign(Object.create(pi.prototype), { constructor: Ma, isArrayCamera: !0 }); var Sa, Ta = new Ie, Ea = new Ie; function Aa(t, e, r) { Ta.setFromMatrixPosition(e.matrixWorld), Ea.setFromMatrixPosition(r.matrixWorld); var n = Ta.distanceTo(Ea), i = e.projectionMatrix.elements, o = r.projectionMatrix.elements, a = i[14] / (i[10] - 1), s = i[14] / (i[10] + 1), c = (i[9] + 1) / i[5], l = (i[9] - 1) / i[5], h = (i[8] - 1) / i[0], u = (o[8] + 1) / o[0], p = a * h, d = a * u, f = n / (-h + u), m = f * -h; e.matrixWorld.decompose(t.position, t.quaternion, t.scale), t.translateX(m), t.translateZ(f), t.matrixWorld.compose(t.position, t.quaternion, t.scale), t.matrixWorldInverse.getInverse(t.matrixWorld); var v = a + f, g = s + f, y = p - m, x = d + (n - m), b = c * s / g * v, w = l * s / g * v; t.projectionMatrix.makePerspective(y, x, b, w, v, g) } function La(t) { var e, r, n = this, i = null, o = null, a = [], s = new Je, c = new Je, l = 1, h = "local-floor"; "undefined" != typeof window && "VRFrameData" in window && (o = new window.VRFrameData, window.addEventListener("vrdisplaypresentchange", w, !1)); var u = new Je, p = new Re, d = new Ie, f = new pi, m = new pi; m.viewport = new ke, m.layers.enable(1); var v = new pi; v.viewport = new ke, v.layers.enable(2); var g = new Ma([m, v]); function y() { return null !== i && !0 === i.isPresenting } g.layers.enable(1), g.layers.enable(2); var x, b = new Pe; function w() { if (y()) { var o = i.getEyeParameters("left"); e = 2 * o.renderWidth * l, r = o.renderHeight * l, x = t.getPixelRatio(), t.getSize(b), t.setDrawingBufferSize(e, r, 1), m.viewport.set(0, 0, e / 2, r), v.viewport.set(e / 2, 0, e / 2, r), E.start(), n.dispatchEvent({ type: "sessionstart" }) } else n.enabled && t.setDrawingBufferSize(b.width, b.height, x), E.stop(), n.dispatchEvent({ type: "sessionend" }) } var _ = [], M = []; function S(t) { for (var e = navigator.getGamepads && navigator.getGamepads(), r = 0, n = e.length; r < n; r++) { var i = e[r]; if (i && ("Daydream Controller" === i.id || "Gear VR Controller" === i.id || "Oculus Go Controller" === i.id || "OpenVR Gamepad" === i.id || i.id.startsWith("Oculus Touch") || i.id.startsWith("HTC Vive Focus") || i.id.startsWith("Spatial Controller"))) { var o = i.hand; if (0 === t && ("" === o || "right" === o)) return i; if (1 === t && "left" === o) return i } } } function T(t, n) { null !== n && 4 === n.length && t.set(n[0] * e, n[1] * r, n[2] * e, n[3] * r) } this.enabled = !1, this.getController = function (t) { var e = a[t]; return void 0 === e && ((e = new _a).matrixAutoUpdate = !1, e.visible = !1, a[t] = e), e }, this.getDevice = function () { return i }, this.setDevice = function (t) { void 0 !== t && (i = t), E.setContext(t) }, this.setFramebufferScaleFactor = function (t) { l = t }, this.setReferenceSpaceType = function (t) { h = t }, this.getCamera = function (t) { var e = "local-floor" === h ? 1.6 : 0; if (i.depthNear = t.near, i.depthFar = t.far, i.getFrameData(o), "local-floor" === h) { var r = i.stageParameters; r ? s.fromArray(r.sittingToStandingTransform) : s.makeTranslation(0, e, 0) } var n = o.pose; f.matrix.copy(s), f.matrix.decompose(f.position, f.quaternion, f.scale), null !== n.orientation && (p.fromArray(n.orientation), f.quaternion.multiply(p)), null !== n.position && (p.setFromRotationMatrix(s), d.fromArray(n.position), d.applyQuaternion(p), f.position.add(d)), f.updateMatrixWorld(), t.matrixWorld.copy(f.matrixWorld); for (var l = t.children, y = 0, x = l.length; y < x; y++)l[y].updateMatrixWorld(!0); m.near = t.near, v.near = t.near, m.far = t.far, v.far = t.far, m.matrixWorldInverse.fromArray(o.leftViewMatrix), v.matrixWorldInverse.fromArray(o.rightViewMatrix), c.getInverse(s), "local-floor" === h && (m.matrixWorldInverse.multiply(c), v.matrixWorldInverse.multiply(c)); var b = t.parent; null !== b && (u.getInverse(b.matrixWorld), m.matrixWorldInverse.multiply(u), v.matrixWorldInverse.multiply(u)), m.matrixWorld.getInverse(m.matrixWorldInverse), v.matrixWorld.getInverse(v.matrixWorldInverse), m.projectionMatrix.fromArray(o.leftProjectionMatrix), v.projectionMatrix.fromArray(o.rightProjectionMatrix), Aa(g, m, v); var w = i.getLayers(); if (w.length) { var E = w[0]; T(m.viewport, E.leftBounds), T(v.viewport, E.rightBounds) } return function () { for (var t = 0; t < a.length; t++) { var e = a[t], r = S(t); if (void 0 !== r && void 0 !== r.pose) { if (null === r.pose) return; var n = r.pose; !1 === n.hasPosition && e.position.set(.2, -.6, -.05), null !== n.position && e.position.fromArray(n.position), null !== n.orientation && e.quaternion.fromArray(n.orientation), e.matrix.compose(e.position, e.quaternion, e.scale), e.matrix.premultiply(s), e.matrix.decompose(e.position, e.quaternion, e.scale), e.matrixWorldNeedsUpdate = !0, e.visible = !0; var i = "Daydream Controller" === r.id ? 0 : 1; void 0 === _[t] && (_[t] = !1), _[t] !== r.buttons[i].pressed && (_[t] = r.buttons[i].pressed, !0 === _[t] ? e.dispatchEvent({ type: "selectstart" }) : (e.dispatchEvent({ type: "selectend" }), e.dispatchEvent({ type: "select" }))), i = 2, void 0 === M[t] && (M[t] = !1), void 0 !== r.buttons[i] && M[t] !== r.buttons[i].pressed && (M[t] = r.buttons[i].pressed, !0 === M[t] ? e.dispatchEvent({ type: "squeezestart" }) : (e.dispatchEvent({ type: "squeezeend" }), e.dispatchEvent({ type: "squeeze" }))) } else e.visible = !1 } }(), g }, this.getStandingMatrix = function () { return s }, this.isPresenting = y; var E = new Si; this.setAnimationLoop = function (t) { E.setAnimationLoop(t), y() && E.start() }, this.submitFrame = function () { y() && i.submitFrame() }, this.dispose = function () { "undefined" != typeof window && window.removeEventListener("vrdisplaypresentchange", w) }, this.setFrameOfReferenceType = function () { console.warn("THREE.WebVRManager: setFrameOfReferenceType() has been deprecated.") } } function Pa(t, e) { var r = this, n = null, i = null, o = "local-floor", a = null, s = [], c = []; var l = new pi; l.layers.enable(1), l.viewport = new ke; var h = new pi; h.layers.enable(2), h.viewport = new ke; var u = new Ma([l, h]); function p(t) { for (var e = 0; e < s.length; e++)c[e] === t.inputSource && s[e].dispatchEvent({ type: t.type }) } function d() { t.setFramebuffer(null), t.setRenderTarget(t.getRenderTarget()), x.stop(), r.dispatchEvent({ type: "sessionend" }) } function f(t) { i = t, x.setContext(n), x.start(), r.dispatchEvent({ type: "sessionstart" }) } function m() { for (var t = 0; t < s.length; t++)c[t] = v(t) } function v(t) { for (var e = n.inputSources, r = 0; r < e.length; r++) { var i = e[r], o = i.handedness; if (0 === t && ("none" === o || "right" === o)) return i; if (1 === t && "left" === o) return i } } function g(t, e) { null === e ? t.matrixWorld.copy(t.matrix) : t.matrixWorld.multiplyMatrices(e.matrixWorld, t.matrix), t.matrixWorldInverse.getInverse(t.matrixWorld) } u.layers.enable(1), u.layers.enable(2), this.enabled = !1, this.getController = function (t) { var e = s[t]; return void 0 === e && ((e = new _a).matrixAutoUpdate = !1, e.visible = !1, s[t] = e), e }, this.setFramebufferScaleFactor = function () { }, this.setReferenceSpaceType = function (t) { o = t }, this.getSession = function () { return n }, this.setSession = function (t) { null !== (n = t) && (n.addEventListener("select", p), n.addEventListener("selectstart", p), n.addEventListener("selectend", p), n.addEventListener("squeeze", p), n.addEventListener("squeezestart", p), n.addEventListener("squeezeend", p), n.addEventListener("end", d), n.updateRenderState({ baseLayer: new XRWebGLLayer(n, e) }), n.requestReferenceSpace(o).then(f), n.addEventListener("inputsourceschange", m), m()) }, this.getCamera = function (t) { var e = t.parent, r = u.cameras; g(u, e); for (var n = 0; n < r.length; n++)g(r[n], e); t.matrixWorld.copy(u.matrixWorld); for (var i = t.children, o = (n = 0, i.length); n < o; n++)i[n].updateMatrixWorld(!0); return Aa(u, l, h), u }, this.isPresenting = function () { return null !== n && null !== i }; var y = null; var x = new Si; x.setAnimationLoop((function (e, r) { if (null !== (a = r.getViewerPose(i))) { var o = a.views, l = n.renderState.baseLayer; t.setFramebuffer(l.framebuffer); for (var h = 0; h < o.length; h++) { var p = o[h], d = l.getViewport(p), f = p.transform.inverse.matrix, m = u.cameras[h]; m.matrix.fromArray(f).getInverse(m.matrix), m.projectionMatrix.fromArray(p.projectionMatrix), m.viewport.set(d.x, d.y, d.width, d.height), 0 === h && u.matrix.copy(m.matrix) } } for (h = 0; h < s.length; h++) { var v = s[h], g = c[h]; if (g) { var x = r.getPose(g.targetRaySpace, i); if (null !== x) { v.matrix.fromArray(x.transform.matrix), v.matrix.decompose(v.position, v.rotation, v.scale), v.visible = !0; continue } } v.visible = !1 } y && y(e) })), this.setAnimationLoop = function (t) { y = t }, this.dispose = function () { }, this.getStandingMatrix = function () { return console.warn("THREE.WebXRManager: getStandingMatrix() is no longer needed."), new Je }, this.getDevice = function () { console.warn("THREE.WebXRManager: getDevice() has been deprecated.") }, this.setDevice = function () { console.warn("THREE.WebXRManager: setDevice() has been deprecated.") }, this.setFrameOfReferenceType = function () { console.warn("THREE.WebXRManager: setFrameOfReferenceType() has been deprecated.") }, this.submitFrame = function () { } } function Ra(t) { var e = void 0 !== (t = t || {}).canvas ? t.canvas : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"), r = void 0 !== t.context ? t.context : null, n = void 0 !== t.alpha && t.alpha, i = void 0 === t.depth || t.depth, o = void 0 === t.stencil || t.stencil, a = void 0 !== t.antialias && t.antialias, s = void 0 === t.premultipliedAlpha || t.premultipliedAlpha, c = void 0 !== t.preserveDrawingBuffer && t.preserveDrawingBuffer, l = void 0 !== t.powerPreference ? t.powerPreference : "default", u = void 0 !== t.failIfMajorPerformanceCaveat && t.failIfMajorPerformanceCaveat, p = null, d = null; this.domElement = e, this.debug = { checkShaderErrors: !0 }, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this.gammaFactor = 2, this.gammaInput = !1, this.gammaOutput = !1, this.physicallyCorrectLights = !1, this.toneMapping = Z, this.toneMappingExposure = 1, this.toneMappingWhitePoint = 1, this.maxMorphTargets = 8, this.maxMorphNormals = 4; var f, m, v, g, y, x, b, w, _, M, S, T, E, A, L, P, R, C, O = this, I = !1, N = null, D = 0, z = 0, F = null, U = null, B = -1, k = { geometry: null, program: null, wireframe: !1 }, j = null, G = null, V = new ke, H = new ke, W = null, q = e.width, X = e.height, Y = 1, J = new ke(0, 0, q, X), K = new ke(0, 0, q, X), Q = !1, $ = new bi, tt = new Ci, et = !1, rt = !1, nt = new Je, it = new Ie; function ot() { return null === F ? Y : 1 } try { var at = { alpha: n, depth: i, stencil: o, antialias: a, premultipliedAlpha: s, preserveDrawingBuffer: c, powerPreference: l, failIfMajorPerformanceCaveat: u, xrCompatible: !0 }; if (e.addEventListener("webglcontextlost", ut, !1), e.addEventListener("webglcontextrestored", pt, !1), null === (f = r || e.getContext("webgl", at) || e.getContext("experimental-webgl", at))) throw null !== e.getContext("webgl") ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context."); void 0 === f.getShaderPrecisionFormat && (f.getShaderPrecisionFormat = function () { return { rangeMin: 1, rangeMax: 1, precision: 1 } }) } catch (t) { throw console.error("THREE.WebGLRenderer: " + t.message), t } function st() { m = new Oi(f), !1 === (v = new Ri(f, m, t)).isWebGL2 && (m.get("WEBGL_depth_texture"), m.get("OES_texture_float"), m.get("OES_texture_half_float"), m.get("OES_texture_half_float_linear"), m.get("OES_standard_derivatives"), m.get("OES_element_index_uint"), m.get("ANGLE_instanced_arrays")), m.get("OES_texture_float_linear"), C = new xa(f, m, v), (g = new ga(f, m, v)).scissor(H.copy(K).multiplyScalar(Y).floor()), g.viewport(V.copy(J).multiplyScalar(Y).floor()), y = new Di(f), x = new ea, b = new ya(f, m, g, x, v, C, y), w = new Ti(f), _ = new Ii(f, w, y), M = new Ui(f, _, w, y), L = new Fi(f), S = new ta(O, m, v), T = new oa, E = new ua, A = new Li(O, g, M, s), P = new Pi(f, m, y, v), R = new Ni(f, m, y, v), y.programs = S.programs, O.capabilities = v, O.extensions = m, O.properties = x, O.renderLists = T, O.state = g, O.info = y } st(); var ct = "undefined" != typeof navigator && "xr" in navigator ? new Pa(O, f) : new La(O); this.vr = ct; var lt = new wa(O, f), ht = new va(O, M, v.maxTextureSize); function ut(t) { t.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), I = !0 } function pt() { console.log("THREE.WebGLRenderer: Context Restored."), I = !1, st() } function dt(t) { var e = t.target; e.removeEventListener("dispose", dt), function (t) { ft(t), x.remove(t) }(e) } function ft(t) { var e = x.get(t).program; t.program = void 0, void 0 !== e && S.releaseProgram(e) } this.shadowMap = ht, this.getContext = function () { return f }, this.getContextAttributes = function () { return f.getContextAttributes() }, this.forceContextLoss = function () { var t = m.get("WEBGL_lose_context"); t && t.loseContext() }, this.forceContextRestore = function () { var t = m.get("WEBGL_lose_context"); t && t.restoreContext() }, this.getPixelRatio = function () { return Y }, this.setPixelRatio = function (t) { void 0 !== t && (Y = t, this.setSize(q, X, !1)) }, this.getSize = function (t) { return void 0 === t && (console.warn("WebGLRenderer: .getsize() now requires a Vector2 as an argument"), t = new Pe), t.set(q, X) }, this.setSize = function (t, r, n) { ct.isPresenting() ? console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.") : (q = t, X = r, e.width = Math.floor(t * Y), e.height = Math.floor(r * Y), !1 !== n && (e.style.width = t + "px", e.style.height = r + "px"), this.setViewport(0, 0, t, r)) }, this.getDrawingBufferSize = function (t) { return void 0 === t && (console.warn("WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument"), t = new Pe), t.set(q * Y, X * Y).floor() }, this.setDrawingBufferSize = function (t, r, n) { q = t, X = r, Y = n, e.width = Math.floor(t * n), e.height = Math.floor(r * n), this.setViewport(0, 0, t, r) }, this.getCurrentViewport = function (t) { return void 0 === t && (console.warn("WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument"), t = new ke), t.copy(V) }, this.getViewport = function (t) { return t.copy(J) }, this.setViewport = function (t, e, r, n) { t.isVector4 ? J.set(t.x, t.y, t.z, t.w) : J.set(t, e, r, n), g.viewport(V.copy(J).multiplyScalar(Y).floor()) }, this.getScissor = function (t) { return t.copy(K) }, this.setScissor = function (t, e, r, n) { t.isVector4 ? K.set(t.x, t.y, t.z, t.w) : K.set(t, e, r, n), g.scissor(H.copy(K).multiplyScalar(Y).floor()) }, this.getScissorTest = function () { return Q }, this.setScissorTest = function (t) { g.setScissorTest(Q = t) }, this.getClearColor = function () { return A.getClearColor() }, this.setClearColor = function () { A.setClearColor.apply(A, arguments) }, this.getClearAlpha = function () { return A.getClearAlpha() }, this.setClearAlpha = function () { A.setClearAlpha.apply(A, arguments) }, this.clear = function (t, e, r) { var n = 0; (void 0 === t || t) && (n |= 16384), (void 0 === e || e) && (n |= 256), (void 0 === r || r) && (n |= 1024), f.clear(n) }, this.clearColor = function () { this.clear(!0, !1, !1) }, this.clearDepth = function () { this.clear(!1, !0, !1) }, this.clearStencil = function () { this.clear(!1, !1, !0) }, this.dispose = function () { e.removeEventListener("webglcontextlost", ut, !1), e.removeEventListener("webglcontextrestored", pt, !1), T.dispose(), E.dispose(), x.dispose(), M.dispose(), ct.dispose(), gt.stop() }, this.renderBufferImmediate = function (t, e) { g.initAttributes(); var r = x.get(t); t.hasPositions && !r.position && (r.position = f.createBuffer()), t.hasNormals && !r.normal && (r.normal = f.createBuffer()), t.hasUvs && !r.uv && (r.uv = f.createBuffer()), t.hasColors && !r.color && (r.color = f.createBuffer()); var n = e.getAttributes(); t.hasPositions && (f.bindBuffer(34962, r.position), f.bufferData(34962, t.positionArray, 35048), g.enableAttribute(n.position), f.vertexAttribPointer(n.position, 3, 5126, !1, 0, 0)), t.hasNormals && (f.bindBuffer(34962, r.normal), f.bufferData(34962, t.normalArray, 35048), g.enableAttribute(n.normal), f.vertexAttribPointer(n.normal, 3, 5126, !1, 0, 0)), t.hasUvs && (f.bindBuffer(34962, r.uv), f.bufferData(34962, t.uvArray, 35048), g.enableAttribute(n.uv), f.vertexAttribPointer(n.uv, 2, 5126, !1, 0, 0)), t.hasColors && (f.bindBuffer(34962, r.color), f.bufferData(34962, t.colorArray, 35048), g.enableAttribute(n.color), f.vertexAttribPointer(n.color, 3, 5126, !1, 0, 0)), g.disableUnusedAttributes(), f.drawArrays(4, 0, t.count), t.count = 0 }, this.renderBufferDirect = function (t, e, r, n, i, o) { var a = i.isMesh && i.matrixWorld.determinant() < 0; g.setMaterial(n, a); var s = St(t, e, n, i), c = !1; k.geometry === r.id && k.program === s.id && k.wireframe === (!0 === n.wireframe) || (k.geometry = r.id, k.program = s.id, k.wireframe = !0 === n.wireframe, c = !0), i.morphTargetInfluences && (L.update(i, r, n, s), c = !0); var l = r.index, h = r.attributes.position; if ((null === l || 0 !== l.count) && void 0 !== h && 0 !== h.count) { var u, p = 1; !0 === n.wireframe && (l = _.getWireframeAttribute(r), p = 2); var d = P; null !== l && (u = w.get(l), (d = R).setIndex(u)), c && (!function (t, e, r, n) { if (!1 === v.isWebGL2 && (t.isInstancedMesh || e.isInstancedBufferGeometry) && null === m.get("ANGLE_instanced_arrays")) return; g.initAttributes(); var i = e.attributes, o = n.getAttributes(), a = r.defaultAttributeValues; for (var s in o) { var c = o[s]; if (c >= 0) { var l = i[s]; if (void 0 !== l) { var h = l.normalized, u = l.itemSize; if (void 0 === (M = w.get(l))) continue; var p = M.buffer, d = M.type, y = M.bytesPerElement; if (l.isInterleavedBufferAttribute) { var x = l.data, b = x.stride, _ = l.offset; x && x.isInstancedInterleavedBuffer ? (g.enableAttributeAndDivisor(c, x.meshPerAttribute), void 0 === e.maxInstancedCount && (e.maxInstancedCount = x.meshPerAttribute * x.count)) : g.enableAttribute(c), f.bindBuffer(34962, p), f.vertexAttribPointer(c, u, d, h, b * y, _ * y) } else l.isInstancedBufferAttribute ? (g.enableAttributeAndDivisor(c, l.meshPerAttribute), void 0 === e.maxInstancedCount && (e.maxInstancedCount = l.meshPerAttribute * l.count)) : g.enableAttribute(c), f.bindBuffer(34962, p), f.vertexAttribPointer(c, u, d, h, 0, 0) } else if ("instanceMatrix" === s) { var M; if (void 0 === (M = w.get(t.instanceMatrix))) continue; p = M.buffer, d = M.type; g.enableAttributeAndDivisor(c + 0, 1), g.enableAttributeAndDivisor(c + 1, 1), g.enableAttributeAndDivisor(c + 2, 1), g.enableAttributeAndDivisor(c + 3, 1), f.bindBuffer(34962, p), f.vertexAttribPointer(c + 0, 4, d, !1, 64, 0), f.vertexAttribPointer(c + 1, 4, d, !1, 64, 16), f.vertexAttribPointer(c + 2, 4, d, !1, 64, 32), f.vertexAttribPointer(c + 3, 4, d, !1, 64, 48) } else if (void 0 !== a) { var S = a[s]; if (void 0 !== S) switch (S.length) { case 2: f.vertexAttrib2fv(c, S); break; case 3: f.vertexAttrib3fv(c, S); break; case 4: f.vertexAttrib4fv(c, S); break; default: f.vertexAttrib1fv(c, S) } } } } g.disableUnusedAttributes() }(i, r, n, s), null !== l && f.bindBuffer(34963, u.buffer)); var y = 1 / 0; null !== l ? y = l.count : void 0 !== h && (y = h.count); var x = r.drawRange.start * p, b = r.drawRange.count * p, M = null !== o ? o.start * p : 0, S = null !== o ? o.count * p : 1 / 0, T = Math.max(x, M), E = Math.min(y, x + b, M + S) - 1, A = Math.max(0, E - T + 1); if (0 !== A) { if (i.isMesh) if (!0 === n.wireframe) g.setLineWidth(n.wireframeLinewidth * ot()), d.setMode(1); else switch (i.drawMode) { case se: d.setMode(4); break; case ce: d.setMode(5); break; case le: d.setMode(6) } else if (i.isLine) { var C = n.linewidth; void 0 === C && (C = 1), g.setLineWidth(C * ot()), i.isLineSegments ? d.setMode(1) : i.isLineLoop ? d.setMode(2) : d.setMode(3) } else i.isPoints ? d.setMode(0) : i.isSprite && d.setMode(4); i.isInstancedMesh ? d.renderInstances(r, T, A, i.count) : r.isInstancedBufferGeometry ? d.renderInstances(r, T, A, r.maxInstancedCount) : d.render(T, A) } } }, this.compile = function (t, e) { (d = E.get(t, e)).init(), t.traverse((function (t) { t.isLight && (d.pushLight(t), t.castShadow && d.pushShadow(t)) })), d.setupLights(e), t.traverse((function (e) { if (e.material) if (Array.isArray(e.material)) for (var r = 0; r < e.material.length; r++)wt(e.material[r], t.fog, e); else wt(e.material, t.fog, e) })) }; var mt = null; var gt = new Si; function yt(t, e, r, n) { if (!1 !== t.visible) { if (t.layers.test(e.layers)) if (t.isGroup) r = t.renderOrder; else if (t.isLOD) !0 === t.autoUpdate && t.update(e); else if (t.isLight) d.pushLight(t), t.castShadow && d.pushShadow(t); else if (t.isSprite) { if (!t.frustumCulled || $.intersectsSprite(t)) { n && it.setFromMatrixPosition(t.matrixWorld).applyMatrix4(nt); var i = M.update(t); (o = t.material).visible && p.push(t, i, o, r, it.z, null) } } else if (t.isImmediateRenderObject) n && it.setFromMatrixPosition(t.matrixWorld).applyMatrix4(nt), p.push(t, null, t.material, r, it.z, null); else if ((t.isMesh || t.isLine || t.isPoints) && (t.isSkinnedMesh && t.skeleton.frame !== y.render.frame && (t.skeleton.update(), t.skeleton.frame = y.render.frame), !t.frustumCulled || $.intersectsObject(t))) { n && it.setFromMatrixPosition(t.matrixWorld).applyMatrix4(nt); i = M.update(t); var o = t.material; if (Array.isArray(o)) for (var a = i.groups, s = 0, c = a.length; s < c; s++) { var l = a[s], h = o[l.materialIndex]; h && h.visible && p.push(t, i, h, r, it.z, l) } else o.visible && p.push(t, i, o, r, it.z, null) } var u = t.children; for (s = 0, c = u.length; s < c; s++)yt(u[s], e, r, n) } } function xt(t, e, r, n) { for (var i = 0, o = t.length; i < o; i++) { var a = t[i], s = a.object, c = a.geometry, l = void 0 === n ? a.material : n, h = a.group; if (r.isArrayCamera) if (G = r, ct.enabled && lt.isAvailable()) bt(s, e, r, c, l, h); else for (var u = r.cameras, p = 0, f = u.length; p < f; p++) { var m = u[p]; s.layers.test(m.layers) && (g.viewport(V.copy(m.viewport)), d.setupLights(m), bt(s, e, m, c, l, h)) } else G = null, bt(s, e, r, c, l, h) } } function bt(t, e, r, n, i, o) { if (t.onBeforeRender(O, e, r, n, i, o), d = E.get(e, G || r), t.modelViewMatrix.multiplyMatrices(r.matrixWorldInverse, t.matrixWorld), t.normalMatrix.getNormalMatrix(t.modelViewMatrix), t.isImmediateRenderObject) { g.setMaterial(i); var a = St(r, e.fog, i, t); k.geometry = null, k.program = null, k.wireframe = !1, function (t, e) { t.render((function (t) { O.renderBufferImmediate(t, e) })) }(t, a) } else O.renderBufferDirect(r, e.fog, n, i, t, o); t.onAfterRender(O, e, r, n, i, o), d = E.get(e, G || r) } function wt(t, e, r) { var n = x.get(t), i = d.state.lights, o = d.state.shadowsArray, a = i.state.version, s = S.getParameters(t, i.state, o, e, tt.numPlanes, tt.numIntersection, r), c = S.getProgramCacheKey(t, s), l = n.program, h = !0; if (void 0 === l) t.addEventListener("dispose", dt); else if (l.cacheKey !== c) ft(t); else if (n.lightsStateVersion !== a) n.lightsStateVersion = a, h = !1; else { if (void 0 !== s.shaderID) return; h = !1 } if (h) { if (s.shaderID) { var u = Mi[s.shaderID]; n.shader = { name: t.type, uniforms: ai(u.uniforms), vertexShader: u.vertexShader, fragmentShader: u.fragmentShader } } else n.shader = { name: t.type, uniforms: t.uniforms, vertexShader: t.vertexShader, fragmentShader: t.fragmentShader }; t.onBeforeCompile(n.shader, O), c = S.getProgramCacheKey(t, s), l = S.acquireProgram(t, n.shader, s, c), n.program = l, t.program = l } var p = l.getAttributes(); if (t.morphTargets) { t.numSupportedMorphTargets = 0; for (var f = 0; f < O.maxMorphTargets; f++)p["morphTarget" + f] >= 0 && t.numSupportedMorphTargets++ } if (t.morphNormals) { t.numSupportedMorphNormals = 0; for (f = 0; f < O.maxMorphNormals; f++)p["morphNormal" + f] >= 0 && t.numSupportedMorphNormals++ } var m = n.shader.uniforms; (t.isShaderMaterial || t.isRawShaderMaterial) && !0 !== t.clipping || (n.numClippingPlanes = tt.numPlanes, n.numIntersection = tt.numIntersection, m.clippingPlanes = tt.uniform), n.fog = e, n.needsLights = function (t) { return t.isMeshLambertMaterial || t.isMeshPhongMaterial || t.isMeshStandardMaterial || t.isShadowMaterial || t.isShaderMaterial && !0 === t.lights }(t), n.lightsStateVersion = a, n.needsLights && (m.ambientLightColor.value = i.state.ambient, m.lightProbe.value = i.state.probe, m.directionalLights.value = i.state.directional, m.spotLights.value = i.state.spot, m.rectAreaLights.value = i.state.rectArea, m.pointLights.value = i.state.point, m.hemisphereLights.value = i.state.hemi, m.directionalShadowMap.value = i.state.directionalShadowMap, m.directionalShadowMatrix.value = i.state.directionalShadowMatrix, m.spotShadowMap.value = i.state.spotShadowMap, m.spotShadowMatrix.value = i.state.spotShadowMatrix, m.pointShadowMap.value = i.state.pointShadowMap, m.pointShadowMatrix.value = i.state.pointShadowMatrix); var v = n.program.getUniforms(), g = zo.seqWithValue(v.seq, m); n.uniformsList = g } function St(t, e, r, n) { b.resetTextureUnits(); var i = x.get(r), o = d.state.lights; if (et && (rt || t !== j)) { var a = t === j && r.id === B; tt.setState(r.clippingPlanes, r.clipIntersection, r.clipShadows, t, i, a) } r.version === i.__version && (void 0 === i.program ? r.needsUpdate = !0 : r.fog && i.fog !== e ? r.needsUpdate = !0 : i.needsLights && i.lightsStateVersion !== o.state.version ? r.needsUpdate = !0 : void 0 === i.numClippingPlanes || i.numClippingPlanes === tt.numPlanes && i.numIntersection === tt.numIntersection || (r.needsUpdate = !0)), r.version !== i.__version && (wt(r, e, n), i.__version = r.version); var s, c, l = !1, u = !1, p = !1, m = i.program, y = m.getUniforms(), w = i.shader.uniforms; if (g.useProgram(m.program) && (l = !0, u = !0, p = !0), r.id !== B && (B = r.id, u = !0), l || j !== t) { if (m.numMultiviewViews > 0 ? lt.updateCameraProjectionMatricesUniform(t, y) : y.setValue(f, "projectionMatrix", t.projectionMatrix), v.logarithmicDepthBuffer && y.setValue(f, "logDepthBufFC", 2 / (Math.log(t.far + 1) / Math.LN2)), j !== t && (j = t, u = !0, p = !0), r.isShaderMaterial || r.isMeshPhongMaterial || r.isMeshStandardMaterial || r.envMap) { var _ = y.map.cameraPosition; void 0 !== _ && _.setValue(f, it.setFromMatrixPosition(t.matrixWorld)) } (r.isMeshPhongMaterial || r.isMeshLambertMaterial || r.isMeshBasicMaterial || r.isMeshStandardMaterial || r.isShaderMaterial) && y.setValue(f, "isOrthographic", !0 === t.isOrthographicCamera), (r.isMeshPhongMaterial || r.isMeshLambertMaterial || r.isMeshBasicMaterial || r.isMeshStandardMaterial || r.isShaderMaterial || r.skinning) && (m.numMultiviewViews > 0 ? lt.updateCameraViewMatricesUniform(t, y) : y.setValue(f, "viewMatrix", t.matrixWorldInverse)) } if (r.skinning) { y.setOptional(f, n, "bindMatrix"), y.setOptional(f, n, "bindMatrixInverse"); var M = n.skeleton; if (M) { var S = M.bones; if (v.floatVertexTextures) { if (void 0 === M.boneTexture) { var T = Math.sqrt(4 * S.length); T = Le.ceilPowerOfTwo(T), T = Math.max(T, 4); var E = new Float32Array(T * T * 4); E.set(M.boneMatrices); var A = new gi(E, T, T, Rt, _t); M.boneMatrices = E, M.boneTexture = A, M.boneTextureSize = T } y.setValue(f, "boneTexture", M.boneTexture, b), y.setValue(f, "boneTextureSize", M.boneTextureSize) } else y.setOptional(f, M, "boneMatrices") } } return (u || i.receiveShadow !== n.receiveShadow) && (i.receiveShadow = n.receiveShadow, y.setValue(f, "receiveShadow", n.receiveShadow)), u && (y.setValue(f, "toneMappingExposure", O.toneMappingExposure), y.setValue(f, "toneMappingWhitePoint", O.toneMappingWhitePoint), i.needsLights && (c = p, (s = w).ambientLightColor.needsUpdate = c, s.lightProbe.needsUpdate = c, s.directionalLights.needsUpdate = c, s.pointLights.needsUpdate = c, s.spotLights.needsUpdate = c, s.rectAreaLights.needsUpdate = c, s.hemisphereLights.needsUpdate = c), e && r.fog && function (t, e) { t.fogColor.value.copy(e.color), e.isFog ? (t.fogNear.value = e.near, t.fogFar.value = e.far) : e.isFogExp2 && (t.fogDensity.value = e.density) }(w, e), r.isMeshBasicMaterial ? Tt(w, r) : r.isMeshLambertMaterial ? (Tt(w, r), function (t, e) { e.emissiveMap && (t.emissiveMap.value = e.emissiveMap) }(w, r)) : r.isMeshPhongMaterial ? (Tt(w, r), r.isMeshToonMaterial ? function (t, e) { Et(t, e), e.gradientMap && (t.gradientMap.value = e.gradientMap) }(w, r) : Et(w, r)) : r.isMeshStandardMaterial ? (Tt(w, r), r.isMeshPhysicalMaterial ? function (t, e) { At(t, e), t.reflectivity.value = e.reflectivity, t.clearcoat.value = e.clearcoat, t.clearcoatRoughness.value = e.clearcoatRoughness, e.sheen && t.sheen.value.copy(e.sheen); e.clearcoatNormalMap && (t.clearcoatNormalScale.value.copy(e.clearcoatNormalScale), t.clearcoatNormalMap.value = e.clearcoatNormalMap, e.side === h && t.clearcoatNormalScale.value.negate()); t.transparency.value = e.transparency }(w, r) : At(w, r)) : r.isMeshMatcapMaterial ? (Tt(w, r), function (t, e) { e.matcap && (t.matcap.value = e.matcap); e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, e.side === h && (t.bumpScale.value *= -1)); e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), e.side === h && t.normalScale.value.negate()); e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias) }(w, r)) : r.isMeshDepthMaterial ? (Tt(w, r), function (t, e) { e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias) }(w, r)) : r.isMeshDistanceMaterial ? (Tt(w, r), function (t, e) { e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias); t.referencePosition.value.copy(e.referencePosition), t.nearDistance.value = e.nearDistance, t.farDistance.value = e.farDistance }(w, r)) : r.isMeshNormalMaterial ? (Tt(w, r), function (t, e) { e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, e.side === h && (t.bumpScale.value *= -1)); e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), e.side === h && t.normalScale.value.negate()); e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias) }(w, r)) : r.isLineBasicMaterial ? (function (t, e) { t.diffuse.value.copy(e.color), t.opacity.value = e.opacity }(w, r), r.isLineDashedMaterial && function (t, e) { t.dashSize.value = e.dashSize, t.totalSize.value = e.dashSize + e.gapSize, t.scale.value = e.scale }(w, r)) : r.isPointsMaterial ? function (t, e) { t.diffuse.value.copy(e.color), t.opacity.value = e.opacity, t.size.value = e.size * Y, t.scale.value = .5 * X, e.map && (t.map.value = e.map); e.alphaMap && (t.alphaMap.value = e.alphaMap); var r; e.map ? r = e.map : e.alphaMap && (r = e.alphaMap); void 0 !== r && (!0 === r.matrixAutoUpdate && r.updateMatrix(), t.uvTransform.value.copy(r.matrix)) }(w, r) : r.isSpriteMaterial ? function (t, e) { t.diffuse.value.copy(e.color), t.opacity.value = e.opacity, t.rotation.value = e.rotation, e.map && (t.map.value = e.map); e.alphaMap && (t.alphaMap.value = e.alphaMap); var r; e.map ? r = e.map : e.alphaMap && (r = e.alphaMap); void 0 !== r && (!0 === r.matrixAutoUpdate && r.updateMatrix(), t.uvTransform.value.copy(r.matrix)) }(w, r) : r.isShadowMaterial && (w.color.value.copy(r.color), w.opacity.value = r.opacity), void 0 !== w.ltc_1 && (w.ltc_1.value = _i.LTC_1), void 0 !== w.ltc_2 && (w.ltc_2.value = _i.LTC_2), zo.upload(f, i.uniformsList, w, b), r.isShaderMaterial && (r.uniformsNeedUpdate = !1)), r.isShaderMaterial && !0 === r.uniformsNeedUpdate && (zo.upload(f, i.uniformsList, w, b), r.uniformsNeedUpdate = !1), r.isSpriteMaterial && y.setValue(f, "center", n.center), m.numMultiviewViews > 0 ? lt.updateObjectMatricesUniforms(n, t, y) : (y.setValue(f, "modelViewMatrix", n.modelViewMatrix), y.setValue(f, "normalMatrix", n.normalMatrix)), y.setValue(f, "modelMatrix", n.matrixWorld), m } function Tt(t, e) { var r; t.opacity.value = e.opacity, e.color && t.diffuse.value.copy(e.color), e.emissive && t.emissive.value.copy(e.emissive).multiplyScalar(e.emissiveIntensity), e.map && (t.map.value = e.map), e.alphaMap && (t.alphaMap.value = e.alphaMap), e.specularMap && (t.specularMap.value = e.specularMap), e.envMap && (t.envMap.value = e.envMap, t.flipEnvMap.value = e.envMap.isCubeTexture ? -1 : 1, t.reflectivity.value = e.reflectivity, t.refractionRatio.value = e.refractionRatio, t.maxMipLevel.value = x.get(e.envMap).__maxMipLevel), e.lightMap && (t.lightMap.value = e.lightMap, t.lightMapIntensity.value = e.lightMapIntensity), e.aoMap && (t.aoMap.value = e.aoMap, t.aoMapIntensity.value = e.aoMapIntensity), e.map ? r = e.map : e.specularMap ? r = e.specularMap : e.displacementMap ? r = e.displacementMap : e.normalMap ? r = e.normalMap : e.bumpMap ? r = e.bumpMap : e.roughnessMap ? r = e.roughnessMap : e.metalnessMap ? r = e.metalnessMap : e.alphaMap ? r = e.alphaMap : e.emissiveMap && (r = e.emissiveMap), void 0 !== r && (r.isWebGLRenderTarget && (r = r.texture), !0 === r.matrixAutoUpdate && r.updateMatrix(), t.uvTransform.value.copy(r.matrix)) } function Et(t, e) { t.specular.value.copy(e.specular), t.shininess.value = Math.max(e.shininess, 1e-4), e.emissiveMap && (t.emissiveMap.value = e.emissiveMap), e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, e.side === h && (t.bumpScale.value *= -1)), e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), e.side === h && t.normalScale.value.negate()), e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias) } function At(t, e) { t.roughness.value = e.roughness, t.metalness.value = e.metalness, e.roughnessMap && (t.roughnessMap.value = e.roughnessMap), e.metalnessMap && (t.metalnessMap.value = e.metalnessMap), e.emissiveMap && (t.emissiveMap.value = e.emissiveMap), e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, e.side === h && (t.bumpScale.value *= -1)), e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), e.side === h && t.normalScale.value.negate()), e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias), e.envMap && (t.envMapIntensity.value = e.envMapIntensity) } gt.setAnimationLoop((function (t) { ct.isPresenting() || mt && mt(t) })), "undefined" != typeof window && gt.setContext(window), this.setAnimationLoop = function (t) { mt = t, ct.setAnimationLoop(t), gt.start() }, this.render = function (t, e) { var r, n; if (void 0 !== arguments[2] && (console.warn("THREE.WebGLRenderer.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead."), r = arguments[2]), void 0 !== arguments[3] && (console.warn("THREE.WebGLRenderer.render(): the forceClear argument has been removed. Use .clear() instead."), n = arguments[3]), e && e.isCamera) { if (!I) { k.geometry = null, k.program = null, k.wireframe = !1, B = -1, j = null, !0 === t.autoUpdate && t.updateMatrixWorld(), null === e.parent && e.updateMatrixWorld(), ct.enabled && ct.isPresenting() && (e = ct.getCamera(e)), (d = E.get(t, e)).init(), t.onBeforeRender(O, t, e, r || F), nt.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse), $.setFromMatrix(nt), rt = this.localClippingEnabled, et = tt.init(this.clippingPlanes, rt, e), (p = T.get(t, e)).init(), yt(t, e, 0, O.sortObjects), !0 === O.sortObjects && p.sort(), et && tt.beginShadows(); var i = d.state.shadowsArray; ht.render(i, t, e), d.setupLights(e), et && tt.endShadows(), this.info.autoReset && this.info.reset(), void 0 !== r && this.setRenderTarget(r), ct.enabled && lt.isAvailable() && lt.attachCamera(e), A.render(p, t, e, n); var o = p.opaque, a = p.transparent; if (t.overrideMaterial) { var s = t.overrideMaterial; o.length && xt(o, t, e, s), a.length && xt(a, t, e, s) } else o.length && xt(o, t, e), a.length && xt(a, t, e); t.onAfterRender(O, t, e), null !== F && (b.updateRenderTargetMipmap(F), b.updateMultisampleRenderTarget(F)), g.buffers.depth.setTest(!0), g.buffers.depth.setMask(!0), g.buffers.color.setMask(!0), g.setPolygonOffset(!1), ct.enabled && (lt.isAvailable() && lt.detachCamera(e), ct.submitFrame()), p = null, d = null } } else console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.") }, this.setFramebuffer = function (t) { N !== t && null === F && f.bindFramebuffer(36160, t), N = t }, this.getActiveCubeFace = function () { return D }, this.getActiveMipmapLevel = function () { return z }, this.getRenderTarget = function () { return F }, this.setRenderTarget = function (t, e, r) { F = t, D = e, z = r, t && void 0 === x.get(t).__webglFramebuffer && b.setupRenderTarget(t); var n = N, i = !1; if (t) { var o = x.get(t).__webglFramebuffer; t.isWebGLRenderTargetCube ? (n = o[e || 0], i = !0) : n = t.isWebGLMultisampleRenderTarget ? x.get(t).__webglMultisampledFramebuffer : o, V.copy(t.viewport), H.copy(t.scissor), W = t.scissorTest } else V.copy(J).multiplyScalar(Y).floor(), H.copy(K).multiplyScalar(Y).floor(), W = Q; if (U !== n && (f.bindFramebuffer(36160, n), U = n), g.viewport(V), g.scissor(H), g.setScissorTest(W), i) { var a = x.get(t.texture); f.framebufferTexture2D(36160, 36064, 34069 + (e || 0), a.__webglTexture, r || 0) } }, this.readRenderTargetPixels = function (t, e, r, n, i, o, a) { if (t && t.isWebGLRenderTarget) { var s = x.get(t).__webglFramebuffer; if (t.isWebGLRenderTargetCube && void 0 !== a && (s = s[a]), s) { var c = !1; s !== U && (f.bindFramebuffer(36160, s), c = !0); try { var l = t.texture, h = l.format, u = l.type; if (h !== Rt && C.convert(h) !== f.getParameter(35739)) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format."); if (!(u === vt || C.convert(u) === f.getParameter(35738) || u === _t && (v.isWebGL2 || m.get("OES_texture_float") || m.get("WEBGL_color_buffer_float")) || u === Mt && (v.isWebGL2 ? m.get("EXT_color_buffer_float") : m.get("EXT_color_buffer_half_float")))) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type."); 36053 === f.checkFramebufferStatus(36160) ? e >= 0 && e <= t.width - n && r >= 0 && r <= t.height - i && f.readPixels(e, r, n, i, C.convert(h), C.convert(u), o) : console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.") } finally { c && f.bindFramebuffer(36160, U) } } } else console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.") }, this.copyFramebufferToTexture = function (t, e, r) { void 0 === r && (r = 0); var n = Math.pow(2, -r), i = Math.floor(e.image.width * n), o = Math.floor(e.image.height * n), a = C.convert(e.format); b.setTexture2D(e, 0), f.copyTexImage2D(3553, r, a, t.x, t.y, i, o, 0), g.unbindTexture() }, this.copyTextureToTexture = function (t, e, r, n) { var i = e.image.width, o = e.image.height, a = C.convert(r.format), s = C.convert(r.type); b.setTexture2D(r, 0), e.isDataTexture ? f.texSubImage2D(3553, n || 0, t.x, t.y, i, o, a, s, e.image.data) : f.texSubImage2D(3553, n || 0, t.x, t.y, a, s, e.image), g.unbindTexture() }, this.initTexture = function (t) { b.setTexture2D(t, 0), g.unbindTexture() }, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this })) } function Ca(t, e) { this.name = "", this.color = new an(t), this.density = void 0 !== e ? e : 25e-5 } function Oa(t, e, r) { this.name = "", this.color = new an(t), this.near = void 0 !== e ? e : 1, this.far = void 0 !== r ? r : 1e3 } function Ia(t, e) { this.array = t, this.stride = e, this.count = void 0 !== t ? t.length / e : 0, this.usage = Se, this.updateRange = { offset: 0, count: -1 }, this.version = 0 } function Na(t, e, r, n) { this.data = t, this.itemSize = e, this.offset = r, this.normalized = !0 === n } function Da(t) { pn.call(this), this.type = "SpriteMaterial", this.color = new an(16777215), this.map = null, this.alphaMap = null, this.rotation = 0, this.sizeAttenuation = !0, this.transparent = !0, this.setValues(t) } Object.assign(La.prototype, Te.prototype), Object.assign(Pa.prototype, Te.prototype), Object.assign(Ca.prototype, { isFogExp2: !0, clone: function () { return new Ca(this.color, this.density) }, toJSON: function () { return { type: "FogExp2", color: this.color.getHex(), density: this.density } } }), Object.assign(Oa.prototype, { isFog: !0, clone: function () { return new Oa(this.color, this.near, this.far) }, toJSON: function () { return { type: "Fog", color: this.color.getHex(), near: this.near, far: this.far } } }), Object.defineProperty(Ia.prototype, "needsUpdate", { set: function (t) { !0 === t && this.version++ } }), Object.assign(Ia.prototype, { isInterleavedBuffer: !0, onUploadCallback: function () { }, setUsage: function (t) { return this.usage = t, this }, copy: function (t) { return this.array = new t.array.constructor(t.array), this.count = t.count, this.stride = t.stride, this.usage = t.usage, this }, copyAt: function (t, e, r) { t *= this.stride, r *= e.stride; for (var n = 0, i = this.stride; n < i; n++)this.array[t + n] = e.array[r + n]; return this }, set: function (t, e) { return void 0 === e && (e = 0), this.array.set(t, e), this }, clone: function () { return (new this.constructor).copy(this) }, onUpload: function (t) { return this.onUploadCallback = t, this } }), Object.defineProperties(Na.prototype, { count: { get: function () { return this.data.count } }, array: { get: function () { return this.data.array } } }), Object.assign(Na.prototype, { isInterleavedBufferAttribute: !0, setX: function (t, e) { return this.data.array[t * this.data.stride + this.offset] = e, this }, setY: function (t, e) { return this.data.array[t * this.data.stride + this.offset + 1] = e, this }, setZ: function (t, e) { return this.data.array[t * this.data.stride + this.offset + 2] = e, this }, setW: function (t, e) { return this.data.array[t * this.data.stride + this.offset + 3] = e, this }, getX: function (t) { return this.data.array[t * this.data.stride + this.offset] }, getY: function (t) { return this.data.array[t * this.data.stride + this.offset + 1] }, getZ: function (t) { return this.data.array[t * this.data.stride + this.offset + 2] }, getW: function (t) { return this.data.array[t * this.data.stride + this.offset + 3] }, setXY: function (t, e, r) { return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = r, this }, setXYZ: function (t, e, r, n) { return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = r, this.data.array[t + 2] = n, this }, setXYZW: function (t, e, r, n, i) { return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = r, this.data.array[t + 2] = n, this.data.array[t + 3] = i, this } }), Da.prototype = Object.create(pn.prototype), Da.prototype.constructor = Da, Da.prototype.isSpriteMaterial = !0, Da.prototype.copy = function (t) { return pn.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.alphaMap = t.alphaMap, this.rotation = t.rotation, this.sizeAttenuation = t.sizeAttenuation, this }; var za = new Ie, Fa = new Ie, Ua = new Ie, Ba = new Pe, ka = new Pe, ja = new Je, Ga = new Ie, Va = new Ie, Ha = new Ie, Wa = new Pe, qa = new Pe, Xa = new Pe; function Ya(t) { if (fr.call(this), this.type = "Sprite", void 0 === Sa) { Sa = new In; var e = new Ia(new Float32Array([-.5, -.5, 0, 0, 0, .5, -.5, 0, 1, 0, .5, .5, 0, 1, 1, -.5, .5, 0, 0, 1]), 5); Sa.setIndex([0, 1, 2, 0, 2, 3]), Sa.setAttribute("position", new Na(e, 3, 0, !1)), Sa.setAttribute("uv", new Na(e, 2, 3, !1)) } this.geometry = Sa, this.material = void 0 !== t ? t : new Da, this.center = new Pe(.5, .5) } function Za(t, e, r, n, i, o) { Ba.subVectors(t, r).addScalar(.5).multiply(n), void 0 !== i ? (ka.x = o * Ba.x - i * Ba.y, ka.y = i * Ba.x + o * Ba.y) : ka.copy(Ba), t.copy(e), t.x += ka.x, t.y += ka.y, t.applyMatrix4(ja) } Ya.prototype = Object.assign(Object.create(fr.prototype), { constructor: Ya, isSprite: !0, raycast: function (t, e) { null === t.camera && console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'), Fa.setFromMatrixScale(this.matrixWorld), ja.copy(t.camera.matrixWorld), this.modelViewMatrix.multiplyMatrices(t.camera.matrixWorldInverse, this.matrixWorld), Ua.setFromMatrixPosition(this.modelViewMatrix), t.camera.isPerspectiveCamera && !1 === this.material.sizeAttenuation && Fa.multiplyScalar(-Ua.z); var r, n, i = this.material.rotation; 0 !== i && (n = Math.cos(i), r = Math.sin(i)); var o = this.center; Za(Ga.set(-.5, -.5, 0), Ua, o, Fa, r, n), Za(Va.set(.5, -.5, 0), Ua, o, Fa, r, n), Za(Ha.set(.5, .5, 0), Ua, o, Fa, r, n), Wa.set(0, 0), qa.set(1, 0), Xa.set(1, 1); var a = t.ray.intersectTriangle(Ga, Va, Ha, !1, za); if (null !== a || (Za(Va.set(-.5, .5, 0), Ua, o, Fa, r, n), qa.set(0, 1), null !== (a = t.ray.intersectTriangle(Ga, Ha, Va, !1, za)))) { var s = t.ray.origin.distanceTo(za); s < t.near || s > t.far || e.push({ distance: s, point: za.clone(), uv: en.getUV(za, Ga, Va, Ha, Wa, qa, Xa, new Pe), face: null, object: this }) } }, clone: function () { return new this.constructor(this.material).copy(this) }, copy: function (t) { return fr.prototype.copy.call(this, t), void 0 !== t.center && this.center.copy(t.center), this } }); var Ja = new Ie, Ka = new Ie; function Qa() { fr.call(this), this.type = "LOD", Object.defineProperties(this, { levels: { enumerable: !0, value: [] } }), this.autoUpdate = !0 } function $a(t, e) { t && t.isGeometry && console.error("THREE.SkinnedMesh no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."), Kn.call(this, t, e), this.type = "SkinnedMesh", this.bindMode = "attached", this.bindMatrix = new Je, this.bindMatrixInverse = new Je } Qa.prototype = Object.assign(Object.create(fr.prototype), { constructor: Qa, isLOD: !0, copy: function (t) { fr.prototype.copy.call(this, t, !1); for (var e = t.levels, r = 0, n = e.length; r < n; r++) { var i = e[r]; this.addLevel(i.object.clone(), i.distance) } return this.autoUpdate = t.autoUpdate, this }, addLevel: function (t, e) { void 0 === e && (e = 0), e = Math.abs(e); for (var r = this.levels, n = 0; n < r.length && !(e < r[n].distance); n++); return r.splice(n, 0, { distance: e, object: t }), this.add(t), this }, getObjectForDistance: function (t) { var e = this.levels; if (e.length > 0) { for (var r = 1, n = e.length; r < n && !(t < e[r].distance); r++); return e[r - 1].object } return null }, raycast: function (t, e) { if (this.levels.length > 0) { Ja.setFromMatrixPosition(this.matrixWorld); var r = t.ray.origin.distanceTo(Ja); this.getObjectForDistance(r).raycast(t, e) } }, update: function (t) { var e = this.levels; if (e.length > 1) { Ja.setFromMatrixPosition(t.matrixWorld), Ka.setFromMatrixPosition(this.matrixWorld); var r = Ja.distanceTo(Ka); e[0].object.visible = !0; for (var n = 1, i = e.length; n < i && r >= e[n].distance; n++)e[n - 1].object.visible = !1, e[n].object.visible = !0; for (; n < i; n++)e[n].object.visible = !1 } }, toJSON: function (t) { var e = fr.prototype.toJSON.call(this, t); !1 === this.autoUpdate && (e.object.autoUpdate = !1), e.object.levels = []; for (var r = this.levels, n = 0, i = r.length; n < i; n++) { var o = r[n]; e.object.levels.push({ object: o.object.uuid, distance: o.distance }) } return e } }), $a.prototype = Object.assign(Object.create(Kn.prototype), { constructor: $a, isSkinnedMesh: !0, bind: function (t, e) { this.skeleton = t, void 0 === e && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), e = this.matrixWorld), this.bindMatrix.copy(e), this.bindMatrixInverse.getInverse(e) }, pose: function () { this.skeleton.pose() }, normalizeSkinWeights: function () { for (var t = new ke, e = this.geometry.attributes.skinWeight, r = 0, n = e.count; r < n; r++) { t.x = e.getX(r), t.y = e.getY(r), t.z = e.getZ(r), t.w = e.getW(r); var i = 1 / t.manhattanLength(); i !== 1 / 0 ? t.multiplyScalar(i) : t.set(1, 0, 0, 0), e.setXYZW(r, t.x, t.y, t.z, t.w) } }, updateMatrixWorld: function (t) { Kn.prototype.updateMatrixWorld.call(this, t), "attached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.matrixWorld) : "detached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.bindMatrix) : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode) }, clone: function () { return new this.constructor(this.geometry, this.material).copy(this) } }); var ts = new Je, es = new Je; function rs(t, e) { if (t = t || [], this.bones = t.slice(0), this.boneMatrices = new Float32Array(16 * this.bones.length), this.frame = -1, void 0 === e) this.calculateInverses(); else if (this.bones.length === e.length) this.boneInverses = e.slice(0); else { console.warn("THREE.Skeleton boneInverses is the wrong length."), this.boneInverses = []; for (var r = 0, n = this.bones.length; r < n; r++)this.boneInverses.push(new Je) } } function ns() { fr.call(this), this.type = "Bone" } Object.assign(rs.prototype, { calculateInverses: function () { this.boneInverses = []; for (var t = 0, e = this.bones.length; t < e; t++) { var r = new Je; this.bones[t] && r.getInverse(this.bones[t].matrixWorld), this.boneInverses.push(r) } }, pose: function () { var t, e, r; for (e = 0, r = this.bones.length; e < r; e++)(t = this.bones[e]) && t.matrixWorld.getInverse(this.boneInverses[e]); for (e = 0, r = this.bones.length; e < r; e++)(t = this.bones[e]) && (t.parent && t.parent.isBone ? (t.matrix.getInverse(t.parent.matrixWorld), t.matrix.multiply(t.matrixWorld)) : t.matrix.copy(t.matrixWorld), t.matrix.decompose(t.position, t.quaternion, t.scale)) }, update: function () { for (var t = this.bones, e = this.boneInverses, r = this.boneMatrices, n = this.boneTexture, i = 0, o = t.length; i < o; i++) { var a = t[i] ? t[i].matrixWorld : es; ts.multiplyMatrices(a, e[i]), ts.toArray(r, 16 * i) } void 0 !== n && (n.needsUpdate = !0) }, clone: function () { return new rs(this.bones, this.boneInverses) }, getBoneByName: function (t) { for (var e = 0, r = this.bones.length; e < r; e++) { var n = this.bones[e]; if (n.name === t) return n } } }), ns.prototype = Object.assign(Object.create(fr.prototype), { constructor: ns, isBone: !0 }); var is = new Je, os = new Je, as = [], ss = new Kn; function cs(t, e, r) { Kn.call(this, t, e), this.instanceMatrix = new fn(new Float32Array(16 * r), 16), this.count = r } function ls(t) { pn.call(this), this.type = "LineBasicMaterial", this.color = new an(16777215), this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.setValues(t) } cs.prototype = Object.assign(Object.create(Kn.prototype), { constructor: cs, isInstancedMesh: !0, getMatrixAt: function (t, e) { e.fromArray(this.instanceMatrix.array, 16 * t) }, raycast: function (t, e) { var r = this.matrixWorld, n = this.count; if (ss.geometry = this.geometry, ss.material = this.material, void 0 !== ss.material) for (var i = 0; i < n; i++)this.getMatrixAt(i, is), os.multiplyMatrices(r, is), ss.matrixWorld = os, ss.raycast(t, as), as.length > 0 && (as[0].instanceId = i, as[0].object = this, e.push(as[0]), as.length = 0) }, setMatrixAt: function (t, e) { e.toArray(this.instanceMatrix.array, 16 * t) }, updateMorphTargets: function () { } }), ls.prototype = Object.create(pn.prototype), ls.prototype.constructor = ls, ls.prototype.isLineBasicMaterial = !0, ls.prototype.copy = function (t) { return pn.prototype.copy.call(this, t), this.color.copy(t.color), this.linewidth = t.linewidth, this.linecap = t.linecap, this.linejoin = t.linejoin, this }; var hs = new Ie, us = new Ie, ps = new Je, ds = new kr, fs = new Or; function ms(t, e, r) { 1 === r && console.error("THREE.Line: parameter THREE.LinePieces no longer supported. Use THREE.LineSegments instead."), fr.call(this), this.type = "Line", this.geometry = void 0 !== t ? t : new In, this.material = void 0 !== e ? e : new ls({ color: 16777215 * Math.random() }) } ms.prototype = Object.assign(Object.create(fr.prototype), { constructor: ms, isLine: !0, computeLineDistances: function () { var t = this.geometry; if (t.isBufferGeometry) if (null === t.index) { for (var e = t.attributes.position, r = [0], n = 1, i = e.count; n < i; n++)hs.fromBufferAttribute(e, n - 1), us.fromBufferAttribute(e, n), r[n] = r[n - 1], r[n] += hs.distanceTo(us); t.setAttribute("lineDistance", new _n(r, 1)) } else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."); else if (t.isGeometry) { var o = t.vertices; (r = t.lineDistances)[0] = 0; for (n = 1, i = o.length; n < i; n++)r[n] = r[n - 1], r[n] += o[n - 1].distanceTo(o[n]) } return this }, raycast: function (t, e) { var r = t.linePrecision, n = this.geometry, i = this.matrixWorld; if (null === n.boundingSphere && n.computeBoundingSphere(), fs.copy(n.boundingSphere), fs.applyMatrix4(i), fs.radius += r, !1 !== t.ray.intersectsSphere(fs)) { ps.getInverse(i), ds.copy(t.ray).applyMatrix4(ps); var o = r / ((this.scale.x + this.scale.y + this.scale.z) / 3), a = o * o, s = new Ie, c = new Ie, l = new Ie, h = new Ie, u = this && this.isLineSegments ? 2 : 1; if (n.isBufferGeometry) { var p = n.index, d = n.attributes.position.array; if (null !== p) for (var f = p.array, m = 0, v = f.length - 1; m < v; m += u) { var g = f[m], y = f[m + 1]; if (s.fromArray(d, 3 * g), c.fromArray(d, 3 * y), !(ds.distanceSqToSegment(s, c, h, l) > a)) h.applyMatrix4(this.matrixWorld), (w = t.ray.origin.distanceTo(h)) < t.near || w > t.far || e.push({ distance: w, point: l.clone().applyMatrix4(this.matrixWorld), index: m, face: null, faceIndex: null, object: this }) } else for (m = 0, v = d.length / 3 - 1; m < v; m += u) { if (s.fromArray(d, 3 * m), c.fromArray(d, 3 * m + 3), !(ds.distanceSqToSegment(s, c, h, l) > a)) h.applyMatrix4(this.matrixWorld), (w = t.ray.origin.distanceTo(h)) < t.near || w > t.far || e.push({ distance: w, point: l.clone().applyMatrix4(this.matrixWorld), index: m, face: null, faceIndex: null, object: this }) } } else if (n.isGeometry) { var x = n.vertices, b = x.length; for (m = 0; m < b - 1; m += u) { var w; if (!(ds.distanceSqToSegment(x[m], x[m + 1], h, l) > a)) h.applyMatrix4(this.matrixWorld), (w = t.ray.origin.distanceTo(h)) < t.near || w > t.far || e.push({ distance: w, point: l.clone().applyMatrix4(this.matrixWorld), index: m, face: null, faceIndex: null, object: this }) } } } }, clone: function () { return new this.constructor(this.geometry, this.material).copy(this) } }); var vs = new Ie, gs = new Ie; function ys(t, e) { ms.call(this, t, e), this.type = "LineSegments" } function xs(t, e) { ms.call(this, t, e), this.type = "LineLoop" } function bs(t) { pn.call(this), this.type = "PointsMaterial", this.color = new an(16777215), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = !0, this.morphTargets = !1, this.setValues(t) } ys.prototype = Object.assign(Object.create(ms.prototype), { constructor: ys, isLineSegments: !0, computeLineDistances: function () { var t = this.geometry; if (t.isBufferGeometry) if (null === t.index) { for (var e = t.attributes.position, r = [], n = 0, i = e.count; n < i; n += 2)vs.fromBufferAttribute(e, n), gs.fromBufferAttribute(e, n + 1), r[n] = 0 === n ? 0 : r[n - 1], r[n + 1] = r[n] + vs.distanceTo(gs); t.setAttribute("lineDistance", new _n(r, 1)) } else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."); else if (t.isGeometry) { var o = t.vertices; for (r = t.lineDistances, n = 0, i = o.length; n < i; n += 2)vs.copy(o[n]), gs.copy(o[n + 1]), r[n] = 0 === n ? 0 : r[n - 1], r[n + 1] = r[n] + vs.distanceTo(gs) } return this } }), xs.prototype = Object.assign(Object.create(ms.prototype), { constructor: xs, isLineLoop: !0 }), bs.prototype = Object.create(pn.prototype), bs.prototype.constructor = bs, bs.prototype.isPointsMaterial = !0, bs.prototype.copy = function (t) { return pn.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.alphaMap = t.alphaMap, this.size = t.size, this.sizeAttenuation = t.sizeAttenuation, this.morphTargets = t.morphTargets, this }; var ws = new Je, _s = new kr, Ms = new Or, Ss = new Ie; function Ts(t, e) { fr.call(this), this.type = "Points", this.geometry = void 0 !== t ? t : new In, this.material = void 0 !== e ? e : new bs({ color: 16777215 * Math.random() }), this.updateMorphTargets() } function Es(t, e, r, n, i, o, a) { var s = _s.distanceSqToPoint(t); if (s < r) { var c = new Ie; _s.closestPointToPoint(t, c), c.applyMatrix4(n); var l = i.ray.origin.distanceTo(c); if (l < i.near || l > i.far) return; o.push({ distance: l, distanceToRay: Math.sqrt(s), point: c, index: e, face: null, object: a }) } } function As(t, e, r, n, i, o, a, s, c) { Be.call(this, t, e, r, n, i, o, a, s, c), this.format = void 0 !== a ? a : Pt, this.minFilter = void 0 !== o ? o : dt, this.magFilter = void 0 !== i ? i : dt, this.generateMipmaps = !1 } function Ls(t, e, r, n, i, o, a, s, c, l, h, u) { Be.call(this, null, o, a, s, c, l, n, i, h, u), this.image = { width: e, height: r }, this.mipmaps = t, this.flipY = !1, this.generateMipmaps = !1 } function Ps(t, e, r, n, i, o, a, s, c) { Be.call(this, t, e, r, n, i, o, a, s, c), this.needsUpdate = !0 } function Rs(t, e, r, n, i, o, a, s, c, l) { if ((l = void 0 !== l ? l : It) !== It && l !== Nt) throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat"); void 0 === r && l === It && (r = xt), void 0 === r && l === Nt && (r = At), Be.call(this, null, n, i, o, a, s, l, r, c), this.image = { width: t, height: e }, this.magFilter = void 0 !== a ? a : ht, this.minFilter = void 0 !== s ? s : ht, this.flipY = !1, this.generateMipmaps = !1 } function Cs(t) { In.call(this), this.type = "WireframeGeometry"; var e, r, n, i, o, a, s, c, l, h, u = [], p = [0, 0], d = {}, f = ["a", "b", "c"]; if (t && t.isGeometry) { var m = t.faces; for (e = 0, n = m.length; e < n; e++) { var v = m[e]; for (r = 0; r < 3; r++)s = v[f[r]], c = v[f[(r + 1) % 3]], p[0] = Math.min(s, c), p[1] = Math.max(s, c), void 0 === d[l = p[0] + "," + p[1]] && (d[l] = { index1: p[0], index2: p[1] }) } for (l in d) a = d[l], h = t.vertices[a.index1], u.push(h.x, h.y, h.z), h = t.vertices[a.index2], u.push(h.x, h.y, h.z) } else if (t && t.isBufferGeometry) { var g, y, x, b, w, _, M; if (h = new Ie, null !== t.index) { for (g = t.attributes.position, y = t.index, 0 === (x = t.groups).length && (x = [{ start: 0, count: y.count, materialIndex: 0 }]), i = 0, o = x.length; i < o; ++i)for (e = w = (b = x[i]).start, n = w + b.count; e < n; e += 3)for (r = 0; r < 3; r++)s = y.getX(e + r), c = y.getX(e + (r + 1) % 3), p[0] = Math.min(s, c), p[1] = Math.max(s, c), void 0 === d[l = p[0] + "," + p[1]] && (d[l] = { index1: p[0], index2: p[1] }); for (l in d) a = d[l], h.fromBufferAttribute(g, a.index1), u.push(h.x, h.y, h.z), h.fromBufferAttribute(g, a.index2), u.push(h.x, h.y, h.z) } else for (e = 0, n = (g = t.attributes.position).count / 3; e < n; e++)for (r = 0; r < 3; r++)_ = 3 * e + r, h.fromBufferAttribute(g, _), u.push(h.x, h.y, h.z), M = 3 * e + (r + 1) % 3, h.fromBufferAttribute(g, M), u.push(h.x, h.y, h.z) } this.setAttribute("position", new _n(u, 3)) } function Os(t, e, r) { ii.call(this), this.type = "ParametricGeometry", this.parameters = { func: t, slices: e, stacks: r }, this.fromBufferGeometry(new Is(t, e, r)), this.mergeVertices() } function Is(t, e, r) { In.call(this), this.type = "ParametricBufferGeometry", this.parameters = { func: t, slices: e, stacks: r }; var n, i, o = [], a = [], s = [], c = [], l = new Ie, h = new Ie, u = new Ie, p = new Ie, d = new Ie; t.length < 3 && console.error("THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter."); var f = e + 1; for (n = 0; n <= r; n++) { var m = n / r; for (i = 0; i <= e; i++) { var v = i / e; t(v, m, h), a.push(h.x, h.y, h.z), v - 1e-5 >= 0 ? (t(v - 1e-5, m, u), p.subVectors(h, u)) : (t(v + 1e-5, m, u), p.subVectors(u, h)), m - 1e-5 >= 0 ? (t(v, m - 1e-5, u), d.subVectors(h, u)) : (t(v, m + 1e-5, u), d.subVectors(u, h)), l.crossVectors(p, d).normalize(), s.push(l.x, l.y, l.z), c.push(v, m) } } for (n = 0; n < r; n++)for (i = 0; i < e; i++) { var g = n * f + i, y = n * f + i + 1, x = (n + 1) * f + i + 1, b = (n + 1) * f + i; o.push(g, y, b), o.push(y, x, b) } this.setIndex(o), this.setAttribute("position", new _n(a, 3)), this.setAttribute("normal", new _n(s, 3)), this.setAttribute("uv", new _n(c, 2)) } function Ns(t, e, r, n) { ii.call(this), this.type = "PolyhedronGeometry", this.parameters = { vertices: t, indices: e, radius: r, detail: n }, this.fromBufferGeometry(new Ds(t, e, r, n)), this.mergeVertices() } function Ds(t, e, r, n) { In.call(this), this.type = "PolyhedronBufferGeometry", this.parameters = { vertices: t, indices: e, radius: r, detail: n }, r = r || 1; var i = [], o = []; function a(t, e, r, n) { var i, o, a = Math.pow(2, n), c = []; for (i = 0; i <= a; i++) { c[i] = []; var l = t.clone().lerp(r, i / a), h = e.clone().lerp(r, i / a), u = a - i; for (o = 0; o <= u; o++)c[i][o] = 0 === o && i === a ? l : l.clone().lerp(h, o / u) } for (i = 0; i < a; i++)for (o = 0; o < 2 * (a - i) - 1; o++) { var p = Math.floor(o / 2); o % 2 == 0 ? (s(c[i][p + 1]), s(c[i + 1][p]), s(c[i][p])) : (s(c[i][p + 1]), s(c[i + 1][p + 1]), s(c[i + 1][p])) } } function s(t) { i.push(t.x, t.y, t.z) } function c(e, r) { var n = 3 * e; r.x = t[n + 0], r.y = t[n + 1], r.z = t[n + 2] } function l(t, e, r, n) { n < 0 && 1 === t.x && (o[e] = t.x - 1), 0 === r.x && 0 === r.z && (o[e] = n / 2 / Math.PI + .5) } function h(t) { return Math.atan2(t.z, -t.x) } !function (t) { for (var r = new Ie, n = new Ie, i = new Ie, o = 0; o < e.length; o += 3)c(e[o + 0], r), c(e[o + 1], n), c(e[o + 2], i), a(r, n, i, t) }(n = n || 0), function (t) { for (var e = new Ie, r = 0; r < i.length; r += 3)e.x = i[r + 0], e.y = i[r + 1], e.z = i[r + 2], e.normalize().multiplyScalar(t), i[r + 0] = e.x, i[r + 1] = e.y, i[r + 2] = e.z }(r), function () { for (var t = new Ie, e = 0; e < i.length; e += 3) { t.x = i[e + 0], t.y = i[e + 1], t.z = i[e + 2]; var r = h(t) / 2 / Math.PI + .5, n = (a = t, Math.atan2(-a.y, Math.sqrt(a.x * a.x + a.z * a.z)) / Math.PI + .5); o.push(r, 1 - n) } var a; (function () { for (var t = new Ie, e = new Ie, r = new Ie, n = new Ie, a = new Pe, s = new Pe, c = new Pe, u = 0, p = 0; u < i.length; u += 9, p += 6) { t.set(i[u + 0], i[u + 1], i[u + 2]), e.set(i[u + 3], i[u + 4], i[u + 5]), r.set(i[u + 6], i[u + 7], i[u + 8]), a.set(o[p + 0], o[p + 1]), s.set(o[p + 2], o[p + 3]), c.set(o[p + 4], o[p + 5]), n.copy(t).add(e).add(r).divideScalar(3); var d = h(n); l(a, p + 0, t, d), l(s, p + 2, e, d), l(c, p + 4, r, d) } })(), function () { for (var t = 0; t < o.length; t += 6) { var e = o[t + 0], r = o[t + 2], n = o[t + 4], i = Math.max(e, r, n), a = Math.min(e, r, n); i > .9 && a < .1 && (e < .2 && (o[t + 0] += 1), r < .2 && (o[t + 2] += 1), n < .2 && (o[t + 4] += 1)) } }() }(), this.setAttribute("position", new _n(i, 3)), this.setAttribute("normal", new _n(i.slice(), 3)), this.setAttribute("uv", new _n(o, 2)), 0 === n ? this.computeVertexNormals() : this.normalizeNormals() } function zs(t, e) { ii.call(this), this.type = "TetrahedronGeometry", this.parameters = { radius: t, detail: e }, this.fromBufferGeometry(new Fs(t, e)), this.mergeVertices() } function Fs(t, e) { Ds.call(this, [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1], [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1], t, e), this.type = "TetrahedronBufferGeometry", this.parameters = { radius: t, detail: e } } function Us(t, e) { ii.call(this), this.type = "OctahedronGeometry", this.parameters = { radius: t, detail: e }, this.fromBufferGeometry(new Bs(t, e)), this.mergeVertices() } function Bs(t, e) { Ds.call(this, [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1], [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2], t, e), this.type = "OctahedronBufferGeometry", this.parameters = { radius: t, detail: e } } function ks(t, e) { ii.call(this), this.type = "IcosahedronGeometry", this.parameters = { radius: t, detail: e }, this.fromBufferGeometry(new js(t, e)), this.mergeVertices() } function js(t, e) { var r = (1 + Math.sqrt(5)) / 2, n = [-1, r, 0, 1, r, 0, -1, -r, 0, 1, -r, 0, 0, -1, r, 0, 1, r, 0, -1, -r, 0, 1, -r, r, 0, -1, r, 0, 1, -r, 0, -1, -r, 0, 1]; Ds.call(this, n, [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1], t, e), this.type = "IcosahedronBufferGeometry", this.parameters = { radius: t, detail: e } } function Gs(t, e) { ii.call(this), this.type = "DodecahedronGeometry", this.parameters = { radius: t, detail: e }, this.fromBufferGeometry(new Vs(t, e)), this.mergeVertices() } function Vs(t, e) { var r = (1 + Math.sqrt(5)) / 2, n = 1 / r, i = [-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -n, -r, 0, -n, r, 0, n, -r, 0, n, r, -n, -r, 0, -n, r, 0, n, -r, 0, n, r, 0, -r, 0, -n, r, 0, -n, -r, 0, n, r, 0, n]; Ds.call(this, i, [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9], t, e), this.type = "DodecahedronBufferGeometry", this.parameters = { radius: t, detail: e } } function Hs(t, e, r, n, i, o) { ii.call(this), this.type = "TubeGeometry", this.parameters = { path: t, tubularSegments: e, radius: r, radialSegments: n, closed: i }, void 0 !== o && console.warn("THREE.TubeGeometry: taper has been removed."); var a = new Ws(t, e, r, n, i); this.tangents = a.tangents, this.normals = a.normals, this.binormals = a.binormals, this.fromBufferGeometry(a), this.mergeVertices() } function Ws(t, e, r, n, i) { In.call(this), this.type = "TubeBufferGeometry", this.parameters = { path: t, tubularSegments: e, radius: r, radialSegments: n, closed: i }, e = e || 64, r = r || 1, n = n || 8, i = i || !1; var o = t.computeFrenetFrames(e, i); this.tangents = o.tangents, this.normals = o.normals, this.binormals = o.binormals; var a, s, c = new Ie, l = new Ie, h = new Pe, u = new Ie, p = [], d = [], f = [], m = []; function v(i) { u = t.getPointAt(i / e, u); var a = o.normals[i], h = o.binormals[i]; for (s = 0; s <= n; s++) { var f = s / n * Math.PI * 2, m = Math.sin(f), v = -Math.cos(f); l.x = v * a.x + m * h.x, l.y = v * a.y + m * h.y, l.z = v * a.z + m * h.z, l.normalize(), d.push(l.x, l.y, l.z), c.x = u.x + r * l.x, c.y = u.y + r * l.y, c.z = u.z + r * l.z, p.push(c.x, c.y, c.z) } } !function () { for (a = 0; a < e; a++)v(a); v(!1 === i ? e : 0), function () { for (a = 0; a <= e; a++)for (s = 0; s <= n; s++)h.x = a / e, h.y = s / n, f.push(h.x, h.y) }(), function () { for (s = 1; s <= e; s++)for (a = 1; a <= n; a++) { var t = (n + 1) * (s - 1) + (a - 1), r = (n + 1) * s + (a - 1), i = (n + 1) * s + a, o = (n + 1) * (s - 1) + a; m.push(t, r, o), m.push(r, i, o) } }() }(), this.setIndex(m), this.setAttribute("position", new _n(p, 3)), this.setAttribute("normal", new _n(d, 3)), this.setAttribute("uv", new _n(f, 2)) } function qs(t, e, r, n, i, o, a) { ii.call(this), this.type = "TorusKnotGeometry", this.parameters = { radius: t, tube: e, tubularSegments: r, radialSegments: n, p: i, q: o }, void 0 !== a && console.warn("THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead."), this.fromBufferGeometry(new Xs(t, e, r, n, i, o)), this.mergeVertices() } function Xs(t, e, r, n, i, o) { In.call(this), this.type = "TorusKnotBufferGeometry", this.parameters = { radius: t, tube: e, tubularSegments: r, radialSegments: n, p: i, q: o }, t = t || 1, e = e || .4, r = Math.floor(r) || 64, n = Math.floor(n) || 8, i = i || 2, o = o || 3; var a, s, c = [], l = [], h = [], u = [], p = new Ie, d = new Ie, f = new Ie, m = new Ie, v = new Ie, g = new Ie, y = new Ie; for (a = 0; a <= r; ++a) { var x = a / r * i * Math.PI * 2; for (A(x, i, o, t, f), A(x + .01, i, o, t, m), g.subVectors(m, f), y.addVectors(m, f), v.crossVectors(g, y), y.crossVectors(v, g), v.normalize(), y.normalize(), s = 0; s <= n; ++s) { var b = s / n * Math.PI * 2, w = -e * Math.cos(b), _ = e * Math.sin(b); p.x = f.x + (w * y.x + _ * v.x), p.y = f.y + (w * y.y + _ * v.y), p.z = f.z + (w * y.z + _ * v.z), l.push(p.x, p.y, p.z), d.subVectors(p, f).normalize(), h.push(d.x, d.y, d.z), u.push(a / r), u.push(s / n) } } for (s = 1; s <= r; s++)for (a = 1; a <= n; a++) { var M = (n + 1) * (s - 1) + (a - 1), S = (n + 1) * s + (a - 1), T = (n + 1) * s + a, E = (n + 1) * (s - 1) + a; c.push(M, S, E), c.push(S, T, E) } function A(t, e, r, n, i) { var o = Math.cos(t), a = Math.sin(t), s = r / e * t, c = Math.cos(s); i.x = n * (2 + c) * .5 * o, i.y = n * (2 + c) * a * .5, i.z = n * Math.sin(s) * .5 } this.setIndex(c), this.setAttribute("position", new _n(l, 3)), this.setAttribute("normal", new _n(h, 3)), this.setAttribute("uv", new _n(u, 2)) } function Ys(t, e, r, n, i) { ii.call(this), this.type = "TorusGeometry", this.parameters = { radius: t, tube: e, radialSegments: r, tubularSegments: n, arc: i }, this.fromBufferGeometry(new Zs(t, e, r, n, i)), this.mergeVertices() } function Zs(t, e, r, n, i) { In.call(this), this.type = "TorusBufferGeometry", this.parameters = { radius: t, tube: e, radialSegments: r, tubularSegments: n, arc: i }, t = t || 1, e = e || .4, r = Math.floor(r) || 8, n = Math.floor(n) || 6, i = i || 2 * Math.PI; var o, a, s = [], c = [], l = [], h = [], u = new Ie, p = new Ie, d = new Ie; for (o = 0; o <= r; o++)for (a = 0; a <= n; a++) { var f = a / n * i, m = o / r * Math.PI * 2; p.x = (t + e * Math.cos(m)) * Math.cos(f), p.y = (t + e * Math.cos(m)) * Math.sin(f), p.z = e * Math.sin(m), c.push(p.x, p.y, p.z), u.x = t * Math.cos(f), u.y = t * Math.sin(f), d.subVectors(p, u).normalize(), l.push(d.x, d.y, d.z), h.push(a / n), h.push(o / r) } for (o = 1; o <= r; o++)for (a = 1; a <= n; a++) { var v = (n + 1) * o + a - 1, g = (n + 1) * (o - 1) + a - 1, y = (n + 1) * (o - 1) + a, x = (n + 1) * o + a; s.push(v, g, x), s.push(g, y, x) } this.setIndex(s), this.setAttribute("position", new _n(c, 3)), this.setAttribute("normal", new _n(l, 3)), this.setAttribute("uv", new _n(h, 2)) } Ts.prototype = Object.assign(Object.create(fr.prototype), { constructor: Ts, isPoints: !0, raycast: function (t, e) { var r = this.geometry, n = this.matrixWorld, i = t.params.Points.threshold; if (null === r.boundingSphere && r.computeBoundingSphere(), Ms.copy(r.boundingSphere), Ms.applyMatrix4(n), Ms.radius += i, !1 !== t.ray.intersectsSphere(Ms)) { ws.getInverse(n), _s.copy(t.ray).applyMatrix4(ws); var o = i / ((this.scale.x + this.scale.y + this.scale.z) / 3), a = o * o; if (r.isBufferGeometry) { var s = r.index, c = r.attributes.position.array; if (null !== s) for (var l = s.array, h = 0, u = l.length; h < u; h++) { var p = l[h]; Ss.fromArray(c, 3 * p), Es(Ss, p, a, n, t, e, this) } else { h = 0; for (var d = c.length / 3; h < d; h++)Ss.fromArray(c, 3 * h), Es(Ss, h, a, n, t, e, this) } } else { var f = r.vertices; for (h = 0, d = f.length; h < d; h++)Es(f[h], h, a, n, t, e, this) } } }, updateMorphTargets: function () { var t, e, r, n = this.geometry; if (n.isBufferGeometry) { var i = n.morphAttributes, o = Object.keys(i); if (o.length > 0) { var a = i[o[0]]; if (void 0 !== a) for (this.morphTargetInfluences = [], this.morphTargetDictionary = {}, t = 0, e = a.length; t < e; t++)r = a[t].name || String(t), this.morphTargetInfluences.push(0), this.morphTargetDictionary[r] = t } } else { var s = n.morphTargets; void 0 !== s && s.length > 0 && console.error("THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.") } }, clone: function () { return new this.constructor(this.geometry, this.material).copy(this) } }), As.prototype = Object.assign(Object.create(Be.prototype), { constructor: As, isVideoTexture: !0, update: function () { var t = this.image; t.readyState >= t.HAVE_CURRENT_DATA && (this.needsUpdate = !0) } }), Ls.prototype = Object.create(Be.prototype), Ls.prototype.constructor = Ls, Ls.prototype.isCompressedTexture = !0, Ps.prototype = Object.create(Be.prototype), Ps.prototype.constructor = Ps, Ps.prototype.isCanvasTexture = !0, Rs.prototype = Object.create(Be.prototype), Rs.prototype.constructor = Rs, Rs.prototype.isDepthTexture = !0, Cs.prototype = Object.create(In.prototype), Cs.prototype.constructor = Cs, Os.prototype = Object.create(ii.prototype), Os.prototype.constructor = Os, Is.prototype = Object.create(In.prototype), Is.prototype.constructor = Is, Ns.prototype = Object.create(ii.prototype), Ns.prototype.constructor = Ns, Ds.prototype = Object.create(In.prototype), Ds.prototype.constructor = Ds, zs.prototype = Object.create(ii.prototype), zs.prototype.constructor = zs, Fs.prototype = Object.create(Ds.prototype), Fs.prototype.constructor = Fs, Us.prototype = Object.create(ii.prototype), Us.prototype.constructor = Us, Bs.prototype = Object.create(Ds.prototype), Bs.prototype.constructor = Bs, ks.prototype = Object.create(ii.prototype), ks.prototype.constructor = ks, js.prototype = Object.create(Ds.prototype), js.prototype.constructor = js, Gs.prototype = Object.create(ii.prototype), Gs.prototype.constructor = Gs, Vs.prototype = Object.create(Ds.prototype), Vs.prototype.constructor = Vs, Hs.prototype = Object.create(ii.prototype), Hs.prototype.constructor = Hs, Ws.prototype = Object.create(In.prototype), Ws.prototype.constructor = Ws, Ws.prototype.toJSON = function () { var t = In.prototype.toJSON.call(this); return t.path = this.parameters.path.toJSON(), t }, qs.prototype = Object.create(ii.prototype), qs.prototype.constructor = qs, Xs.prototype = Object.create(In.prototype), Xs.prototype.constructor = Xs, Ys.prototype = Object.create(ii.prototype), Ys.prototype.constructor = Ys, Zs.prototype = Object.create(In.prototype), Zs.prototype.constructor = Zs; var Js = function (t, e, r) { r = r || 2; var n, i, o, a, s, c, l, h = e && e.length, u = h ? e[0] * r : t.length, p = Ks(t, 0, u, r, !0), d = []; if (!p || p.next === p.prev) return d; if (h && (p = function (t, e, r, n) { var i, o, a, s, c, l = []; for (i = 0, o = e.length; i < o; i++)a = e[i] * n, s = i < o - 1 ? e[i + 1] * n : t.length, (c = Ks(t, a, s, n, !1)) === c.next && (c.steiner = !0), l.push(sc(c)); for (l.sort(ic), i = 0; i < l.length; i++)oc(l[i], r), r = Qs(r, r.next); return r }(t, e, p, r)), t.length > 80 * r) { n = o = t[0], i = a = t[1]; for (var f = r; f < u; f += r)(s = t[f]) < n && (n = s), (c = t[f + 1]) < i && (i = c), s > o && (o = s), c > a && (a = c); l = 0 !== (l = Math.max(o - n, a - i)) ? 1 / l : 0 } return $s(p, d, r, n, i, l), d }; function Ks(t, e, r, n, i) { var o, a; if (i === function (t, e, r, n) { for (var i = 0, o = e, a = r - n; o < r; o += n)i += (t[a] - t[o]) * (t[o + 1] + t[a + 1]), a = o; return i }(t, e, r, n) > 0) for (o = e; o < r; o += n)a = mc(o, t[o], t[o + 1], a); else for (o = r - n; o >= e; o -= n)a = mc(o, t[o], t[o + 1], a); return a && uc(a, a.next) && (vc(a), a = a.next), a } function Qs(t, e) { if (!t) return t; e || (e = t); var r, n = t; do { if (r = !1, n.steiner || !uc(n, n.next) && 0 !== hc(n.prev, n, n.next)) n = n.next; else { if (vc(n), (n = e = n.prev) === n.next) break; r = !0 } } while (r || n !== e); return e } function $s(t, e, r, n, i, o, a) { if (t) { !a && o && function (t, e, r, n) { var i = t; do { null === i.z && (i.z = ac(i.x, i.y, e, r, n)), i.prevZ = i.prev, i.nextZ = i.next, i = i.next } while (i !== t); i.prevZ.nextZ = null, i.prevZ = null, function (t) { var e, r, n, i, o, a, s, c, l = 1; do { for (r = t, t = null, o = null, a = 0; r;) { for (a++, n = r, s = 0, e = 0; e < l && (s++, n = n.nextZ); e++); for (c = l; s > 0 || c > 0 && n;)0 !== s && (0 === c || !n || r.z <= n.z) ? (i = r, r = r.nextZ, s--) : (i = n, n = n.nextZ, c--), o ? o.nextZ = i : t = i, i.prevZ = o, o = i; r = n } o.nextZ = null, l *= 2 } while (a > 1) }(i) }(t, n, i, o); for (var s, c, l = t; t.prev !== t.next;)if (s = t.prev, c = t.next, o ? ec(t, n, i, o) : tc(t)) e.push(s.i / r), e.push(t.i / r), e.push(c.i / r), vc(t), t = c.next, l = c.next; else if ((t = c) === l) { a ? 1 === a ? $s(t = rc(t, e, r), e, r, n, i, o, 2) : 2 === a && nc(t, e, r, n, i, o) : $s(Qs(t), e, r, n, i, o, 1); break } } } function tc(t) { var e = t.prev, r = t, n = t.next; if (hc(e, r, n) >= 0) return !1; for (var i = t.next.next; i !== t.prev;) { if (cc(e.x, e.y, r.x, r.y, n.x, n.y, i.x, i.y) && hc(i.prev, i, i.next) >= 0) return !1; i = i.next } return !0 } function ec(t, e, r, n) { var i = t.prev, o = t, a = t.next; if (hc(i, o, a) >= 0) return !1; for (var s = i.x < o.x ? i.x < a.x ? i.x : a.x : o.x < a.x ? o.x : a.x, c = i.y < o.y ? i.y < a.y ? i.y : a.y : o.y < a.y ? o.y : a.y, l = i.x > o.x ? i.x > a.x ? i.x : a.x : o.x > a.x ? o.x : a.x, h = i.y > o.y ? i.y > a.y ? i.y : a.y : o.y > a.y ? o.y : a.y, u = ac(s, c, e, r, n), p = ac(l, h, e, r, n), d = t.prevZ, f = t.nextZ; d && d.z >= u && f && f.z <= p;) { if (d !== t.prev && d !== t.next && cc(i.x, i.y, o.x, o.y, a.x, a.y, d.x, d.y) && hc(d.prev, d, d.next) >= 0) return !1; if (d = d.prevZ, f !== t.prev && f !== t.next && cc(i.x, i.y, o.x, o.y, a.x, a.y, f.x, f.y) && hc(f.prev, f, f.next) >= 0) return !1; f = f.nextZ } for (; d && d.z >= u;) { if (d !== t.prev && d !== t.next && cc(i.x, i.y, o.x, o.y, a.x, a.y, d.x, d.y) && hc(d.prev, d, d.next) >= 0) return !1; d = d.prevZ } for (; f && f.z <= p;) { if (f !== t.prev && f !== t.next && cc(i.x, i.y, o.x, o.y, a.x, a.y, f.x, f.y) && hc(f.prev, f, f.next) >= 0) return !1; f = f.nextZ } return !0 } function rc(t, e, r) { var n = t; do { var i = n.prev, o = n.next.next; !uc(i, o) && pc(i, n, n.next, o) && dc(i, o) && dc(o, i) && (e.push(i.i / r), e.push(n.i / r), e.push(o.i / r), vc(n), vc(n.next), n = t = o), n = n.next } while (n !== t); return n } function nc(t, e, r, n, i, o) { var a = t; do { for (var s = a.next.next; s !== a.prev;) { if (a.i !== s.i && lc(a, s)) { var c = fc(a, s); return a = Qs(a, a.next), c = Qs(c, c.next), $s(a, e, r, n, i, o), void $s(c, e, r, n, i, o) } s = s.next } a = a.next } while (a !== t) } function ic(t, e) { return t.x - e.x } function oc(t, e) { if (e = function (t, e) { var r, n = e, i = t.x, o = t.y, a = -1 / 0; do { if (o <= n.y && o >= n.next.y && n.next.y !== n.y) { var s = n.x + (o - n.y) * (n.next.x - n.x) / (n.next.y - n.y); if (s <= i && s > a) { if (a = s, s === i) { if (o === n.y) return n; if (o === n.next.y) return n.next } r = n.x < n.next.x ? n : n.next } } n = n.next } while (n !== e); if (!r) return null; if (i === a) return r.prev; var c, l = r, h = r.x, u = r.y, p = 1 / 0; n = r.next; for (; n !== l;)i >= n.x && n.x >= h && i !== n.x && cc(o < u ? i : a, o, h, u, o < u ? a : i, o, n.x, n.y) && ((c = Math.abs(o - n.y) / (i - n.x)) < p || c === p && n.x > r.x) && dc(n, t) && (r = n, p = c), n = n.next; return r }(t, e)) { var r = fc(e, t); Qs(r, r.next) } } function ac(t, e, r, n, i) { return (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = 32767 * (t - r) * i) | t << 8)) | t << 4)) | t << 2)) | t << 1)) | (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = 32767 * (e - n) * i) | e << 8)) | e << 4)) | e << 2)) | e << 1)) << 1 } function sc(t) { var e = t, r = t; do { (e.x < r.x || e.x === r.x && e.y < r.y) && (r = e), e = e.next } while (e !== t); return r } function cc(t, e, r, n, i, o, a, s) { return (i - a) * (e - s) - (t - a) * (o - s) >= 0 && (t - a) * (n - s) - (r - a) * (e - s) >= 0 && (r - a) * (o - s) - (i - a) * (n - s) >= 0 } function lc(t, e) { return t.next.i !== e.i && t.prev.i !== e.i && !function (t, e) { var r = t; do { if (r.i !== t.i && r.next.i !== t.i && r.i !== e.i && r.next.i !== e.i && pc(r, r.next, t, e)) return !0; r = r.next } while (r !== t); return !1 }(t, e) && dc(t, e) && dc(e, t) && function (t, e) { var r = t, n = !1, i = (t.x + e.x) / 2, o = (t.y + e.y) / 2; do { r.y > o != r.next.y > o && r.next.y !== r.y && i < (r.next.x - r.x) * (o - r.y) / (r.next.y - r.y) + r.x && (n = !n), r = r.next } while (r !== t); return n }(t, e) } function hc(t, e, r) { return (e.y - t.y) * (r.x - e.x) - (e.x - t.x) * (r.y - e.y) } function uc(t, e) { return t.x === e.x && t.y === e.y } function pc(t, e, r, n) { return !!(uc(t, r) && uc(e, n) || uc(t, n) && uc(r, e)) || hc(t, e, r) > 0 != hc(t, e, n) > 0 && hc(r, n, t) > 0 != hc(r, n, e) > 0 } function dc(t, e) { return hc(t.prev, t, t.next) < 0 ? hc(t, e, t.next) >= 0 && hc(t, t.prev, e) >= 0 : hc(t, e, t.prev) < 0 || hc(t, t.next, e) < 0 } function fc(t, e) { var r = new gc(t.i, t.x, t.y), n = new gc(e.i, e.x, e.y), i = t.next, o = e.prev; return t.next = e, e.prev = t, r.next = i, i.prev = r, n.next = r, r.prev = n, o.next = n, n.prev = o, n } function mc(t, e, r, n) { var i = new gc(t, e, r); return n ? (i.next = n.next, i.prev = n, n.next.prev = i, n.next = i) : (i.prev = i, i.next = i), i } function vc(t) { t.next.prev = t.prev, t.prev.next = t.next, t.prevZ && (t.prevZ.nextZ = t.nextZ), t.nextZ && (t.nextZ.prevZ = t.prevZ) } function gc(t, e, r) { this.i = t, this.x = e, this.y = r, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1 } var yc = { area: function (t) { for (var e = t.length, r = 0, n = e - 1, i = 0; i < e; n = i++)r += t[n].x * t[i].y - t[i].x * t[n].y; return .5 * r }, isClockWise: function (t) { return yc.area(t) < 0 }, triangulateShape: function (t, e) { var r = [], n = [], i = []; xc(t), bc(r, t); var o = t.length; e.forEach(xc); for (var a = 0; a < e.length; a++)n.push(o), o += e[a].length, bc(r, e[a]); var s = Js(r, n); for (a = 0; a < s.length; a += 3)i.push(s.slice(a, a + 3)); return i } }; function xc(t) { var e = t.length; e > 2 && t[e - 1].equals(t[0]) && t.pop() } function bc(t, e) { for (var r = 0; r < e.length; r++)t.push(e[r].x), t.push(e[r].y) } function wc(t, e) { ii.call(this), this.type = "ExtrudeGeometry", this.parameters = { shapes: t, options: e }, this.fromBufferGeometry(new _c(t, e)), this.mergeVertices() } function _c(t, e) { In.call(this), this.type = "ExtrudeBufferGeometry", this.parameters = { shapes: t, options: e }, t = Array.isArray(t) ? t : [t]; for (var r = this, n = [], i = [], o = 0, a = t.length; o < a; o++) { s(t[o]) } function s(t) { var o = [], a = void 0 !== e.curveSegments ? e.curveSegments : 12, s = void 0 !== e.steps ? e.steps : 1, c = void 0 !== e.depth ? e.depth : 100, l = void 0 === e.bevelEnabled || e.bevelEnabled, h = void 0 !== e.bevelThickness ? e.bevelThickness : 6, u = void 0 !== e.bevelSize ? e.bevelSize : h - 2, p = void 0 !== e.bevelOffset ? e.bevelOffset : 0, d = void 0 !== e.bevelSegments ? e.bevelSegments : 3, f = e.extrudePath, m = void 0 !== e.UVGenerator ? e.UVGenerator : Mc; void 0 !== e.amount && (console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth."), c = e.amount); var v, g, y, x, b, w, _, M, S = !1; f && (v = f.getSpacedPoints(s), S = !0, l = !1, g = f.computeFrenetFrames(s, !1), y = new Ie, x = new Ie, b = new Ie), l || (d = 0, h = 0, u = 0, p = 0); var T = t.extractPoints(a), E = T.shape, A = T.holes; if (!yc.isClockWise(E)) for (E = E.reverse(), _ = 0, M = A.length; _ < M; _++)w = A[_], yc.isClockWise(w) && (A[_] = w.reverse()); var L = yc.triangulateShape(E, A), P = E; for (_ = 0, M = A.length; _ < M; _++)w = A[_], E = E.concat(w); function R(t, e, r) { return e || console.error("THREE.ExtrudeGeometry: vec does not exist"), e.clone().multiplyScalar(r).add(t) } var C, O, I, N, D, z, F = E.length, U = L.length; function B(t, e, r) { var n, i, o, a = t.x - e.x, s = t.y - e.y, c = r.x - t.x, l = r.y - t.y, h = a * a + s * s, u = a * l - s * c; if (Math.abs(u) > Number.EPSILON) { var p = Math.sqrt(h), d = Math.sqrt(c * c + l * l), f = e.x - s / p, m = e.y + a / p, v = ((r.x - l / d - f) * l - (r.y + c / d - m) * c) / (a * l - s * c), g = (n = f + a * v - t.x) * n + (i = m + s * v - t.y) * i; if (g <= 2) return new Pe(n, i); o = Math.sqrt(g / 2) } else { var y = !1; a > Number.EPSILON ? c > Number.EPSILON && (y = !0) : a < -Number.EPSILON ? c < -Number.EPSILON && (y = !0) : Math.sign(s) === Math.sign(l) && (y = !0), y ? (n = -s, i = a, o = Math.sqrt(h)) : (n = a, i = s, o = Math.sqrt(h / 2)) } return new Pe(n / o, i / o) } for (var k = [], j = 0, G = P.length, V = G - 1, H = j + 1; j < G; j++, V++, H++)V === G && (V = 0), H === G && (H = 0), k[j] = B(P[j], P[V], P[H]); var W, q, X = [], Y = k.concat(); for (_ = 0, M = A.length; _ < M; _++) { for (w = A[_], W = [], j = 0, V = (G = w.length) - 1, H = j + 1; j < G; j++, V++, H++)V === G && (V = 0), H === G && (H = 0), W[j] = B(w[j], w[V], w[H]); X.push(W), Y = Y.concat(W) } for (C = 0; C < d; C++) { for (I = C / d, N = h * Math.cos(I * Math.PI / 2), O = u * Math.sin(I * Math.PI / 2) + p, j = 0, G = P.length; j < G; j++)J((D = R(P[j], k[j], O)).x, D.y, -N); for (_ = 0, M = A.length; _ < M; _++)for (w = A[_], W = X[_], j = 0, G = w.length; j < G; j++)J((D = R(w[j], W[j], O)).x, D.y, -N) } for (O = u + p, j = 0; j < F; j++)D = l ? R(E[j], Y[j], O) : E[j], S ? (x.copy(g.normals[0]).multiplyScalar(D.x), y.copy(g.binormals[0]).multiplyScalar(D.y), b.copy(v[0]).add(x).add(y), J(b.x, b.y, b.z)) : J(D.x, D.y, 0); for (q = 1; q <= s; q++)for (j = 0; j < F; j++)D = l ? R(E[j], Y[j], O) : E[j], S ? (x.copy(g.normals[q]).multiplyScalar(D.x), y.copy(g.binormals[q]).multiplyScalar(D.y), b.copy(v[q]).add(x).add(y), J(b.x, b.y, b.z)) : J(D.x, D.y, c / s * q); for (C = d - 1; C >= 0; C--) { for (I = C / d, N = h * Math.cos(I * Math.PI / 2), O = u * Math.sin(I * Math.PI / 2) + p, j = 0, G = P.length; j < G; j++)J((D = R(P[j], k[j], O)).x, D.y, c + N); for (_ = 0, M = A.length; _ < M; _++)for (w = A[_], W = X[_], j = 0, G = w.length; j < G; j++)D = R(w[j], W[j], O), S ? J(D.x, D.y + v[s - 1].y, v[s - 1].x + N) : J(D.x, D.y, c + N) } function Z(t, e) { var r, n; for (j = t.length; --j >= 0;) { r = j, (n = j - 1) < 0 && (n = t.length - 1); var i = 0, o = s + 2 * d; for (i = 0; i < o; i++) { var a = F * i, c = F * (i + 1); Q(e + r + a, e + n + a, e + n + c, e + r + c) } } } function J(t, e, r) { o.push(t), o.push(e), o.push(r) } function K(t, e, i) { $(t), $(e), $(i); var o = n.length / 3, a = m.generateTopUV(r, n, o - 3, o - 2, o - 1); tt(a[0]), tt(a[1]), tt(a[2]) } function Q(t, e, i, o) { $(t), $(e), $(o), $(e), $(i), $(o); var a = n.length / 3, s = m.generateSideWallUV(r, n, a - 6, a - 3, a - 2, a - 1); tt(s[0]), tt(s[1]), tt(s[3]), tt(s[1]), tt(s[2]), tt(s[3]) } function $(t) { n.push(o[3 * t + 0]), n.push(o[3 * t + 1]), n.push(o[3 * t + 2]) } function tt(t) { i.push(t.x), i.push(t.y) } !function () { var t = n.length / 3; if (l) { var e = 0, i = F * e; for (j = 0; j < U; j++)K((z = L[j])[2] + i, z[1] + i, z[0] + i); for (i = F * (e = s + 2 * d), j = 0; j < U; j++)K((z = L[j])[0] + i, z[1] + i, z[2] + i) } else { for (j = 0; j < U; j++)K((z = L[j])[2], z[1], z[0]); for (j = 0; j < U; j++)K((z = L[j])[0] + F * s, z[1] + F * s, z[2] + F * s) } r.addGroup(t, n.length / 3 - t, 0) }(), function () { var t = n.length / 3, e = 0; for (Z(P, e), e += P.length, _ = 0, M = A.length; _ < M; _++)Z(w = A[_], e), e += w.length; r.addGroup(t, n.length / 3 - t, 1) }() } this.setAttribute("position", new _n(n, 3)), this.setAttribute("uv", new _n(i, 2)), this.computeVertexNormals() } wc.prototype = Object.create(ii.prototype), wc.prototype.constructor = wc, wc.prototype.toJSON = function () { var t = ii.prototype.toJSON.call(this); return Sc(this.parameters.shapes, this.parameters.options, t) }, _c.prototype = Object.create(In.prototype), _c.prototype.constructor = _c, _c.prototype.toJSON = function () { var t = In.prototype.toJSON.call(this); return Sc(this.parameters.shapes, this.parameters.options, t) }; var Mc = { generateTopUV: function (t, e, r, n, i) { var o = e[3 * r], a = e[3 * r + 1], s = e[3 * n], c = e[3 * n + 1], l = e[3 * i], h = e[3 * i + 1]; return [new Pe(o, a), new Pe(s, c), new Pe(l, h)] }, generateSideWallUV: function (t, e, r, n, i, o) { var a = e[3 * r], s = e[3 * r + 1], c = e[3 * r + 2], l = e[3 * n], h = e[3 * n + 1], u = e[3 * n + 2], p = e[3 * i], d = e[3 * i + 1], f = e[3 * i + 2], m = e[3 * o], v = e[3 * o + 1], g = e[3 * o + 2]; return Math.abs(s - h) < .01 ? [new Pe(a, 1 - c), new Pe(l, 1 - u), new Pe(p, 1 - f), new Pe(m, 1 - g)] : [new Pe(s, 1 - c), new Pe(h, 1 - u), new Pe(d, 1 - f), new Pe(v, 1 - g)] } }; function Sc(t, e, r) { if (r.shapes = [], Array.isArray(t)) for (var n = 0, i = t.length; n < i; n++) { var o = t[n]; r.shapes.push(o.uuid) } else r.shapes.push(t.uuid); return void 0 !== e.extrudePath && (r.options.extrudePath = e.extrudePath.toJSON()), r } function Tc(t, e) { ii.call(this), this.type = "TextGeometry", this.parameters = { text: t, parameters: e }, this.fromBufferGeometry(new Ec(t, e)), this.mergeVertices() } function Ec(t, e) { var r = (e = e || {}).font; if (!r || !r.isFont) return console.error("THREE.TextGeometry: font parameter is not an instance of THREE.Font."), new ii; var n = r.generateShapes(t, e.size); e.depth = void 0 !== e.height ? e.height : 50, void 0 === e.bevelThickness && (e.bevelThickness = 10), void 0 === e.bevelSize && (e.bevelSize = 8), void 0 === e.bevelEnabled && (e.bevelEnabled = !1), _c.call(this, n, e), this.type = "TextBufferGeometry" } function Ac(t, e, r, n, i, o, a) { ii.call(this), this.type = "SphereGeometry", this.parameters = { radius: t, widthSegments: e, heightSegments: r, phiStart: n, phiLength: i, thetaStart: o, thetaLength: a }, this.fromBufferGeometry(new Lc(t, e, r, n, i, o, a)), this.mergeVertices() } function Lc(t, e, r, n, i, o, a) { In.call(this), this.type = "SphereBufferGeometry", this.parameters = { radius: t, widthSegments: e, heightSegments: r, phiStart: n, phiLength: i, thetaStart: o, thetaLength: a }, t = t || 1, e = Math.max(3, Math.floor(e) || 8), r = Math.max(2, Math.floor(r) || 6), n = void 0 !== n ? n : 0, i = void 0 !== i ? i : 2 * Math.PI, o = void 0 !== o ? o : 0, a = void 0 !== a ? a : Math.PI; var s, c, l = Math.min(o + a, Math.PI), h = 0, u = [], p = new Ie, d = new Ie, f = [], m = [], v = [], g = []; for (c = 0; c <= r; c++) { var y = [], x = c / r, b = 0; for (0 == c && 0 == o ? b = .5 / e : c == r && l == Math.PI && (b = -.5 / e), s = 0; s <= e; s++) { var w = s / e; p.x = -t * Math.cos(n + w * i) * Math.sin(o + x * a), p.y = t * Math.cos(o + x * a), p.z = t * Math.sin(n + w * i) * Math.sin(o + x * a), m.push(p.x, p.y, p.z), d.copy(p).normalize(), v.push(d.x, d.y, d.z), g.push(w + b, 1 - x), y.push(h++) } u.push(y) } for (c = 0; c < r; c++)for (s = 0; s < e; s++) { var _ = u[c][s + 1], M = u[c][s], S = u[c + 1][s], T = u[c + 1][s + 1]; (0 !== c || o > 0) && f.push(_, M, T), (c !== r - 1 || l < Math.PI) && f.push(M, S, T) } this.setIndex(f), this.setAttribute("position", new _n(m, 3)), this.setAttribute("normal", new _n(v, 3)), this.setAttribute("uv", new _n(g, 2)) } function Pc(t, e, r, n, i, o) { ii.call(this), this.type = "RingGeometry", this.parameters = { innerRadius: t, outerRadius: e, thetaSegments: r, phiSegments: n, thetaStart: i, thetaLength: o }, this.fromBufferGeometry(new Rc(t, e, r, n, i, o)), this.mergeVertices() } function Rc(t, e, r, n, i, o) { In.call(this), this.type = "RingBufferGeometry", this.parameters = { innerRadius: t, outerRadius: e, thetaSegments: r, phiSegments: n, thetaStart: i, thetaLength: o }, t = t || .5, e = e || 1, i = void 0 !== i ? i : 0, o = void 0 !== o ? o : 2 * Math.PI, r = void 0 !== r ? Math.max(3, r) : 8; var a, s, c, l = [], h = [], u = [], p = [], d = t, f = (e - t) / (n = void 0 !== n ? Math.max(1, n) : 1), m = new Ie, v = new Pe; for (s = 0; s <= n; s++) { for (c = 0; c <= r; c++)a = i + c / r * o, m.x = d * Math.cos(a), m.y = d * Math.sin(a), h.push(m.x, m.y, m.z), u.push(0, 0, 1), v.x = (m.x / e + 1) / 2, v.y = (m.y / e + 1) / 2, p.push(v.x, v.y); d += f } for (s = 0; s < n; s++) { var g = s * (r + 1); for (c = 0; c < r; c++) { var y = a = c + g, x = a + r + 1, b = a + r + 2, w = a + 1; l.push(y, x, w), l.push(x, b, w) } } this.setIndex(l), this.setAttribute("position", new _n(h, 3)), this.setAttribute("normal", new _n(u, 3)), this.setAttribute("uv", new _n(p, 2)) } function Cc(t, e, r, n) { ii.call(this), this.type = "LatheGeometry", this.parameters = { points: t, segments: e, phiStart: r, phiLength: n }, this.fromBufferGeometry(new Oc(t, e, r, n)), this.mergeVertices() } function Oc(t, e, r, n) { In.call(this), this.type = "LatheBufferGeometry", this.parameters = { points: t, segments: e, phiStart: r, phiLength: n }, e = Math.floor(e) || 12, r = r || 0, n = n || 2 * Math.PI, n = Le.clamp(n, 0, 2 * Math.PI); var i, o, a, s = [], c = [], l = [], h = 1 / e, u = new Ie, p = new Pe; for (o = 0; o <= e; o++) { var d = r + o * h * n, f = Math.sin(d), m = Math.cos(d); for (a = 0; a <= t.length - 1; a++)u.x = t[a].x * f, u.y = t[a].y, u.z = t[a].x * m, c.push(u.x, u.y, u.z), p.x = o / e, p.y = a / (t.length - 1), l.push(p.x, p.y) } for (o = 0; o < e; o++)for (a = 0; a < t.length - 1; a++) { var v = i = a + o * t.length, g = i + t.length, y = i + t.length + 1, x = i + 1; s.push(v, g, x), s.push(g, y, x) } if (this.setIndex(s), this.setAttribute("position", new _n(c, 3)), this.setAttribute("uv", new _n(l, 2)), this.computeVertexNormals(), n === 2 * Math.PI) { var b = this.attributes.normal.array, w = new Ie, _ = new Ie, M = new Ie; for (i = e * t.length * 3, o = 0, a = 0; o < t.length; o++, a += 3)w.x = b[a + 0], w.y = b[a + 1], w.z = b[a + 2], _.x = b[i + a + 0], _.y = b[i + a + 1], _.z = b[i + a + 2], M.addVectors(w, _).normalize(), b[a + 0] = b[i + a + 0] = M.x, b[a + 1] = b[i + a + 1] = M.y, b[a + 2] = b[i + a + 2] = M.z } } function Ic(t, e) { ii.call(this), this.type = "ShapeGeometry", "object" == typeof e && (console.warn("THREE.ShapeGeometry: Options parameter has been removed."), e = e.curveSegments), this.parameters = { shapes: t, curveSegments: e }, this.fromBufferGeometry(new Nc(t, e)), this.mergeVertices() } function Nc(t, e) { In.call(this), this.type = "ShapeBufferGeometry", this.parameters = { shapes: t, curveSegments: e }, e = e || 12; var r = [], n = [], i = [], o = [], a = 0, s = 0; if (!1 === Array.isArray(t)) l(t); else for (var c = 0; c < t.length; c++)l(t[c]), this.addGroup(a, s, c), a += s, s = 0; function l(t) { var a, c, l, h = n.length / 3, u = t.extractPoints(e), p = u.shape, d = u.holes; for (!1 === yc.isClockWise(p) && (p = p.reverse()), a = 0, c = d.length; a < c; a++)l = d[a], !0 === yc.isClockWise(l) && (d[a] = l.reverse()); var f = yc.triangulateShape(p, d); for (a = 0, c = d.length; a < c; a++)l = d[a], p = p.concat(l); for (a = 0, c = p.length; a < c; a++) { var m = p[a]; n.push(m.x, m.y, 0), i.push(0, 0, 1), o.push(m.x, m.y) } for (a = 0, c = f.length; a < c; a++) { var v = f[a], g = v[0] + h, y = v[1] + h, x = v[2] + h; r.push(g, y, x), s += 3 } } this.setIndex(r), this.setAttribute("position", new _n(n, 3)), this.setAttribute("normal", new _n(i, 3)), this.setAttribute("uv", new _n(o, 2)) } function Dc(t, e) { if (e.shapes = [], Array.isArray(t)) for (var r = 0, n = t.length; r < n; r++) { var i = t[r]; e.shapes.push(i.uuid) } else e.shapes.push(t.uuid); return e } function zc(t, e) { In.call(this), this.type = "EdgesGeometry", this.parameters = { thresholdAngle: e }, e = void 0 !== e ? e : 1; var r, n, i, o, a = [], s = Math.cos(Le.DEG2RAD * e), c = [0, 0], l = {}, h = ["a", "b", "c"]; t.isBufferGeometry ? (o = new ii).fromBufferGeometry(t) : o = t.clone(), o.mergeVertices(), o.computeFaceNormals(); for (var u = o.vertices, p = o.faces, d = 0, f = p.length; d < f; d++)for (var m = p[d], v = 0; v < 3; v++)r = m[h[v]], n = m[h[(v + 1) % 3]], c[0] = Math.min(r, n), c[1] = Math.max(r, n), void 0 === l[i = c[0] + "," + c[1]] ? l[i] = { index1: c[0], index2: c[1], face1: d, face2: void 0 } : l[i].face2 = d; for (i in l) { var g = l[i]; if (void 0 === g.face2 || p[g.face1].normal.dot(p[g.face2].normal) <= s) { var y = u[g.index1]; a.push(y.x, y.y, y.z), y = u[g.index2], a.push(y.x, y.y, y.z) } } this.setAttribute("position", new _n(a, 3)) } function Fc(t, e, r, n, i, o, a, s) { ii.call(this), this.type = "CylinderGeometry", this.parameters = { radiusTop: t, radiusBottom: e, height: r, radialSegments: n, heightSegments: i, openEnded: o, thetaStart: a, thetaLength: s }, this.fromBufferGeometry(new Uc(t, e, r, n, i, o, a, s)), this.mergeVertices() } function Uc(t, e, r, n, i, o, a, s) { In.call(this), this.type = "CylinderBufferGeometry", this.parameters = { radiusTop: t, radiusBottom: e, height: r, radialSegments: n, heightSegments: i, openEnded: o, thetaStart: a, thetaLength: s }; var c = this; t = void 0 !== t ? t : 1, e = void 0 !== e ? e : 1, r = r || 1, n = Math.floor(n) || 8, i = Math.floor(i) || 1, o = void 0 !== o && o, a = void 0 !== a ? a : 0, s = void 0 !== s ? s : 2 * Math.PI; var l = [], h = [], u = [], p = [], d = 0, f = [], m = r / 2, v = 0; function g(r) { var i, o, f, g = new Pe, y = new Ie, x = 0, b = !0 === r ? t : e, w = !0 === r ? 1 : -1; for (o = d, i = 1; i <= n; i++)h.push(0, m * w, 0), u.push(0, w, 0), p.push(.5, .5), d++; for (f = d, i = 0; i <= n; i++) { var _ = i / n * s + a, M = Math.cos(_), S = Math.sin(_); y.x = b * S, y.y = m * w, y.z = b * M, h.push(y.x, y.y, y.z), u.push(0, w, 0), g.x = .5 * M + .5, g.y = .5 * S * w + .5, p.push(g.x, g.y), d++ } for (i = 0; i < n; i++) { var T = o + i, E = f + i; !0 === r ? l.push(E, E + 1, T) : l.push(E + 1, E, T), x += 3 } c.addGroup(v, x, !0 === r ? 1 : 2), v += x } !function () { var o, g, y = new Ie, x = new Ie, b = 0, w = (e - t) / r; for (g = 0; g <= i; g++) { var _ = [], M = g / i, S = M * (e - t) + t; for (o = 0; o <= n; o++) { var T = o / n, E = T * s + a, A = Math.sin(E), L = Math.cos(E); x.x = S * A, x.y = -M * r + m, x.z = S * L, h.push(x.x, x.y, x.z), y.set(A, w, L).normalize(), u.push(y.x, y.y, y.z), p.push(T, 1 - M), _.push(d++) } f.push(_) } for (o = 0; o < n; o++)for (g = 0; g < i; g++) { var P = f[g][o], R = f[g + 1][o], C = f[g + 1][o + 1], O = f[g][o + 1]; l.push(P, R, O), l.push(R, C, O), b += 6 } c.addGroup(v, b, 0), v += b }(), !1 === o && (t > 0 && g(!0), e > 0 && g(!1)), this.setIndex(l), this.setAttribute("position", new _n(h, 3)), this.setAttribute("normal", new _n(u, 3)), this.setAttribute("uv", new _n(p, 2)) } function Bc(t, e, r, n, i, o, a) { Fc.call(this, 0, t, e, r, n, i, o, a), this.type = "ConeGeometry", this.parameters = { radius: t, height: e, radialSegments: r, heightSegments: n, openEnded: i, thetaStart: o, thetaLength: a } } function kc(t, e, r, n, i, o, a) { Uc.call(this, 0, t, e, r, n, i, o, a), this.type = "ConeBufferGeometry", this.parameters = { radius: t, height: e, radialSegments: r, heightSegments: n, openEnded: i, thetaStart: o, thetaLength: a } } function jc(t, e, r, n) { ii.call(this), this.type = "CircleGeometry", this.parameters = { radius: t, segments: e, thetaStart: r, thetaLength: n }, this.fromBufferGeometry(new Gc(t, e, r, n)), this.mergeVertices() } function Gc(t, e, r, n) { In.call(this), this.type = "CircleBufferGeometry", this.parameters = { radius: t, segments: e, thetaStart: r, thetaLength: n }, t = t || 1, e = void 0 !== e ? Math.max(3, e) : 8, r = void 0 !== r ? r : 0, n = void 0 !== n ? n : 2 * Math.PI; var i, o, a = [], s = [], c = [], l = [], h = new Ie, u = new Pe; for (s.push(0, 0, 0), c.push(0, 0, 1), l.push(.5, .5), o = 0, i = 3; o <= e; o++, i += 3) { var p = r + o / e * n; h.x = t * Math.cos(p), h.y = t * Math.sin(p), s.push(h.x, h.y, h.z), c.push(0, 0, 1), u.x = (s[i] / t + 1) / 2, u.y = (s[i + 1] / t + 1) / 2, l.push(u.x, u.y) } for (i = 1; i <= e; i++)a.push(i, i + 1, 0); this.setIndex(a), this.setAttribute("position", new _n(s, 3)), this.setAttribute("normal", new _n(c, 3)), this.setAttribute("uv", new _n(l, 2)) } Tc.prototype = Object.create(ii.prototype), Tc.prototype.constructor = Tc, Ec.prototype = Object.create(_c.prototype), Ec.prototype.constructor = Ec, Ac.prototype = Object.create(ii.prototype), Ac.prototype.constructor = Ac, Lc.prototype = Object.create(In.prototype), Lc.prototype.constructor = Lc, Pc.prototype = Object.create(ii.prototype), Pc.prototype.constructor = Pc, Rc.prototype = Object.create(In.prototype), Rc.prototype.constructor = Rc, Cc.prototype = Object.create(ii.prototype), Cc.prototype.constructor = Cc, Oc.prototype = Object.create(In.prototype), Oc.prototype.constructor = Oc, Ic.prototype = Object.create(ii.prototype), Ic.prototype.constructor = Ic, Ic.prototype.toJSON = function () { var t = ii.prototype.toJSON.call(this); return Dc(this.parameters.shapes, t) }, Nc.prototype = Object.create(In.prototype), Nc.prototype.constructor = Nc, Nc.prototype.toJSON = function () { var t = In.prototype.toJSON.call(this); return Dc(this.parameters.shapes, t) }, zc.prototype = Object.create(In.prototype), zc.prototype.constructor = zc, Fc.prototype = Object.create(ii.prototype), Fc.prototype.constructor = Fc, Uc.prototype = Object.create(In.prototype), Uc.prototype.constructor = Uc, Bc.prototype = Object.create(Fc.prototype), Bc.prototype.constructor = Bc, kc.prototype = Object.create(Uc.prototype), kc.prototype.constructor = kc, jc.prototype = Object.create(ii.prototype), jc.prototype.constructor = jc, Gc.prototype = Object.create(In.prototype), Gc.prototype.constructor = Gc; var Vc = Object.freeze({ __proto__: null, WireframeGeometry: Cs, ParametricGeometry: Os, ParametricBufferGeometry: Is, TetrahedronGeometry: zs, TetrahedronBufferGeometry: Fs, OctahedronGeometry: Us, OctahedronBufferGeometry: Bs, IcosahedronGeometry: ks, IcosahedronBufferGeometry: js, DodecahedronGeometry: Gs, DodecahedronBufferGeometry: Vs, PolyhedronGeometry: Ns, PolyhedronBufferGeometry: Ds, TubeGeometry: Hs, TubeBufferGeometry: Ws, TorusKnotGeometry: qs, TorusKnotBufferGeometry: Xs, TorusGeometry: Ys, TorusBufferGeometry: Zs, TextGeometry: Tc, TextBufferGeometry: Ec, SphereGeometry: Ac, SphereBufferGeometry: Lc, RingGeometry: Pc, RingBufferGeometry: Rc, PlaneGeometry: Ei, PlaneBufferGeometry: Ai, LatheGeometry: Cc, LatheBufferGeometry: Oc, ShapeGeometry: Ic, ShapeBufferGeometry: Nc, ExtrudeGeometry: wc, ExtrudeBufferGeometry: _c, EdgesGeometry: zc, ConeGeometry: Bc, ConeBufferGeometry: kc, CylinderGeometry: Fc, CylinderBufferGeometry: Uc, CircleGeometry: jc, CircleBufferGeometry: Gc, BoxGeometry: class extends ii { constructor(t, e, r, n, i, o) { super(), this.type = "BoxGeometry", this.parameters = { width: t, height: e, depth: r, widthSegments: n, heightSegments: i, depthSegments: o }, this.fromBufferGeometry(new oi(t, e, r, n, i, o)), this.mergeVertices() } }, BoxBufferGeometry: oi }); function Hc(t) { pn.call(this), this.type = "ShadowMaterial", this.color = new an(0), this.transparent = !0, this.setValues(t) } function Wc(t) { hi.call(this, t), this.type = "RawShaderMaterial" } function qc(t) { pn.call(this), this.defines = { STANDARD: "" }, this.type = "MeshStandardMaterial", this.color = new an(16777215), this.roughness = .5, this.metalness = .5, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new an(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = be, this.normalScale = new Pe(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapIntensity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(t) } function Xc(t) { qc.call(this), this.defines = { STANDARD: "", PHYSICAL: "" }, this.type = "MeshPhysicalMaterial", this.reflectivity = .5, this.clearcoat = 0, this.clearcoatRoughness = 0, this.sheen = null, this.clearcoatNormalScale = new Pe(1, 1), this.clearcoatNormalMap = null, this.transparency = 0, this.setValues(t) } function Yc(t) { pn.call(this), this.type = "MeshPhongMaterial", this.color = new an(16777215), this.specular = new an(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new an(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = be, this.normalScale = new Pe(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = W, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(t) } function Zc(t) { Yc.call(this), this.defines = { TOON: "" }, this.type = "MeshToonMaterial", this.gradientMap = null, this.setValues(t) } function Jc(t) { pn.call(this), this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = be, this.normalScale = new Pe(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(t) } function Kc(t) { pn.call(this), this.type = "MeshLambertMaterial", this.color = new an(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new an(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = W, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(t) } function Qc(t) { pn.call(this), this.defines = { MATCAP: "" }, this.type = "MeshMatcapMaterial", this.color = new an(16777215), this.matcap = null, this.map = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = be, this.normalScale = new Pe(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(t) } function $c(t) { ls.call(this), this.type = "LineDashedMaterial", this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.setValues(t) } Hc.prototype = Object.create(pn.prototype), Hc.prototype.constructor = Hc, Hc.prototype.isShadowMaterial = !0, Hc.prototype.copy = function (t) { return pn.prototype.copy.call(this, t), this.color.copy(t.color), this }, Wc.prototype = Object.create(hi.prototype), Wc.prototype.constructor = Wc, Wc.prototype.isRawShaderMaterial = !0, qc.prototype = Object.create(pn.prototype), qc.prototype.constructor = qc, qc.prototype.isMeshStandardMaterial = !0, qc.prototype.copy = function (t) { return pn.prototype.copy.call(this, t), this.defines = { STANDARD: "" }, this.color.copy(t.color), this.roughness = t.roughness, this.metalness = t.metalness, this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.roughnessMap = t.roughnessMap, this.metalnessMap = t.metalnessMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.envMapIntensity = t.envMapIntensity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this }, Xc.prototype = Object.create(qc.prototype), Xc.prototype.constructor = Xc, Xc.prototype.isMeshPhysicalMaterial = !0, Xc.prototype.copy = function (t) { return qc.prototype.copy.call(this, t), this.defines = { STANDARD: "", PHYSICAL: "" }, this.reflectivity = t.reflectivity, this.clearcoat = t.clearcoat, this.clearcoatRoughness = t.clearcoatRoughness, t.sheen ? this.sheen = (this.sheen || new an).copy(t.sheen) : this.sheen = null, this.clearcoatNormalMap = t.clearcoatNormalMap, this.clearcoatNormalScale.copy(t.clearcoatNormalScale), this.transparency = t.transparency, this }, Yc.prototype = Object.create(pn.prototype), Yc.prototype.constructor = Yc, Yc.prototype.isMeshPhongMaterial = !0, Yc.prototype.copy = function (t) { return pn.prototype.copy.call(this, t), this.color.copy(t.color), this.specular.copy(t.specular), this.shininess = t.shininess, this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this }, Zc.prototype = Object.create(Yc.prototype), Zc.prototype.constructor = Zc, Zc.prototype.isMeshToonMaterial = !0, Zc.prototype.copy = function (t) { return Yc.prototype.copy.call(this, t), this.gradientMap = t.gradientMap, this }, Jc.prototype = Object.create(pn.prototype), Jc.prototype.constructor = Jc, Jc.prototype.isMeshNormalMaterial = !0, Jc.prototype.copy = function (t) { return pn.prototype.copy.call(this, t), this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this }, Kc.prototype = Object.create(pn.prototype), Kc.prototype.constructor = Kc, Kc.prototype.isMeshLambertMaterial = !0, Kc.prototype.copy = function (t) { return pn.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this }, Qc.prototype = Object.create(pn.prototype), Qc.prototype.constructor = Qc, Qc.prototype.isMeshMatcapMaterial = !0, Qc.prototype.copy = function (t) { return pn.prototype.copy.call(this, t), this.defines = { MATCAP: "" }, this.color.copy(t.color), this.matcap = t.matcap, this.map = t.map, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.alphaMap = t.alphaMap, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this }, $c.prototype = Object.create(ls.prototype), $c.prototype.constructor = $c, $c.prototype.isLineDashedMaterial = !0, $c.prototype.copy = function (t) { return ls.prototype.copy.call(this, t), this.scale = t.scale, this.dashSize = t.dashSize, this.gapSize = t.gapSize, this }; var tl = Object.freeze({ __proto__: null, ShadowMaterial: Hc, SpriteMaterial: Da, RawShaderMaterial: Wc, ShaderMaterial: hi, PointsMaterial: bs, MeshPhysicalMaterial: Xc, MeshStandardMaterial: qc, MeshPhongMaterial: Yc, MeshToonMaterial: Zc, MeshNormalMaterial: Jc, MeshLambertMaterial: Kc, MeshDepthMaterial: pa, MeshDistanceMaterial: da, MeshBasicMaterial: dn, MeshMatcapMaterial: Qc, LineDashedMaterial: $c, LineBasicMaterial: ls, Material: pn }), el = { arraySlice: function (t, e, r) { return el.isTypedArray(t) ? new t.constructor(t.subarray(e, void 0 !== r ? r : t.length)) : t.slice(e, r) }, convertArray: function (t, e, r) { return !t || !r && t.constructor === e ? t : "number" == typeof e.BYTES_PER_ELEMENT ? new e(t) : Array.prototype.slice.call(t) }, isTypedArray: function (t) { return ArrayBuffer.isView(t) && !(t instanceof DataView) }, getKeyframeOrder: function (t) { for (var e = t.length, r = new Array(e), n = 0; n !== e; ++n)r[n] = n; return r.sort((function (e, r) { return t[e] - t[r] })), r }, sortedArray: function (t, e, r) { for (var n = t.length, i = new t.constructor(n), o = 0, a = 0; a !== n; ++o)for (var s = r[o] * e, c = 0; c !== e; ++c)i[a++] = t[s + c]; return i }, flattenJSON: function (t, e, r, n) { for (var i = 1, o = t[0]; void 0 !== o && void 0 === o[n];)o = t[i++]; if (void 0 !== o) { var a = o[n]; if (void 0 !== a) if (Array.isArray(a)) do { void 0 !== (a = o[n]) && (e.push(o.time), r.push.apply(r, a)), o = t[i++] } while (void 0 !== o); else if (void 0 !== a.toArray) do { void 0 !== (a = o[n]) && (e.push(o.time), a.toArray(r, r.length)), o = t[i++] } while (void 0 !== o); else do { void 0 !== (a = o[n]) && (e.push(o.time), r.push(a)), o = t[i++] } while (void 0 !== o) } }, subclip: function (t, e, r, n, i) { i = i || 30; var o = t.clone(); o.name = e; for (var a = [], s = 0; s < o.tracks.length; ++s) { for (var c = o.tracks[s], l = c.getValueSize(), h = [], u = [], p = 0; p < c.times.length; ++p) { var d = c.times[p] * i; if (!(d < r || d >= n)) { h.push(c.times[p]); for (var f = 0; f < l; ++f)u.push(c.values[p * l + f]) } } 0 !== h.length && (c.times = el.convertArray(h, c.times.constructor), c.values = el.convertArray(u, c.values.constructor), a.push(c)) } o.tracks = a; var m = 1 / 0; for (s = 0; s < o.tracks.length; ++s)m > o.tracks[s].times[0] && (m = o.tracks[s].times[0]); for (s = 0; s < o.tracks.length; ++s)o.tracks[s].shift(-1 * m); return o.resetDuration(), o } }; function rl(t, e, r, n) { this.parameterPositions = t, this._cachedIndex = 0, this.resultBuffer = void 0 !== n ? n : new e.constructor(r), this.sampleValues = e, this.valueSize = r } function nl(t, e, r, n) { rl.call(this, t, e, r, n), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0 } function il(t, e, r, n) { rl.call(this, t, e, r, n) } function ol(t, e, r, n) { rl.call(this, t, e, r, n) } function al(t, e, r, n) { if (void 0 === t) throw new Error("THREE.KeyframeTrack: track name is undefined"); if (void 0 === e || 0 === e.length) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + t); this.name = t, this.times = el.convertArray(e, this.TimeBufferType), this.values = el.convertArray(r, this.ValueBufferType), this.setInterpolation(n || this.DefaultInterpolation) } function sl(t, e, r) { al.call(this, t, e, r) } function cl(t, e, r, n) { al.call(this, t, e, r, n) } function ll(t, e, r, n) { al.call(this, t, e, r, n) } function hl(t, e, r, n) { rl.call(this, t, e, r, n) } function ul(t, e, r, n) { al.call(this, t, e, r, n) } function pl(t, e, r, n) { al.call(this, t, e, r, n) } function dl(t, e, r, n) { al.call(this, t, e, r, n) } function fl(t, e, r) { this.name = t, this.tracks = r, this.duration = void 0 !== e ? e : -1, this.uuid = Le.generateUUID(), this.duration < 0 && this.resetDuration() } function ml(t) { if (void 0 === t.type) throw new Error("THREE.KeyframeTrack: track type undefined, can not parse"); var e = function (t) { switch (t.toLowerCase()) { case "scalar": case "double": case "float": case "number": case "integer": return ll; case "vector": case "vector2": case "vector3": case "vector4": return dl; case "color": return cl; case "quaternion": return ul; case "bool": case "boolean": return sl; case "string": return pl }throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + t) }(t.type); if (void 0 === t.times) { var r = [], n = []; el.flattenJSON(t.keys, r, n, "value"), t.times = r, t.values = n } return void 0 !== e.parse ? e.parse(t) : new e(t.name, t.times, t.values, t.interpolation) } Object.assign(rl.prototype, { evaluate: function (t) { var e = this.parameterPositions, r = this._cachedIndex, n = e[r], i = e[r - 1]; t: { e: { var o; r: { n: if (!(t < n)) { for (var a = r + 2; ;) { if (void 0 === n) { if (t < i) break n; return r = e.length, this._cachedIndex = r, this.afterEnd_(r - 1, t, i) } if (r === a) break; if (i = n, t < (n = e[++r])) break e } o = e.length; break r } if (t >= i) break t; var s = e[1]; t < s && (r = 2, i = s); for (a = r - 2; ;) { if (void 0 === i) return this._cachedIndex = 0, this.beforeStart_(0, t, n); if (r === a) break; if (n = i, t >= (i = e[--r - 1])) break e } o = r, r = 0 } for (; r < o;) { var c = r + o >>> 1; t < e[c] ? o = c : r = c + 1 } if (n = e[r], void 0 === (i = e[r - 1])) return this._cachedIndex = 0, this.beforeStart_(0, t, n); if (void 0 === n) return r = e.length, this._cachedIndex = r, this.afterEnd_(r - 1, i, t) } this._cachedIndex = r, this.intervalChanged_(r, i, n) } return this.interpolate_(r, i, t, n) }, settings: null, DefaultSettings_: {}, getSettings_: function () { return this.settings || this.DefaultSettings_ }, copySampleValue_: function (t) { for (var e = this.resultBuffer, r = this.sampleValues, n = this.valueSize, i = t * n, o = 0; o !== n; ++o)e[o] = r[i + o]; return e }, interpolate_: function () { throw new Error("call to abstract method") }, intervalChanged_: function () { } }), Object.assign(rl.prototype, { beforeStart_: rl.prototype.copySampleValue_, afterEnd_: rl.prototype.copySampleValue_ }), nl.prototype = Object.assign(Object.create(rl.prototype), { constructor: nl, DefaultSettings_: { endingStart: ae, endingEnd: ae }, intervalChanged_: function (t, e, r) { var n = this.parameterPositions, i = t - 2, o = t + 1, a = n[i], s = n[o]; if (void 0 === a) switch (this.getSettings_().endingStart) { case 2401: i = t, a = 2 * e - r; break; case 2402: a = e + n[i = n.length - 2] - n[i + 1]; break; default: i = t, a = r }if (void 0 === s) switch (this.getSettings_().endingEnd) { case 2401: o = t, s = 2 * r - e; break; case 2402: o = 1, s = r + n[1] - n[0]; break; default: o = t - 1, s = e }var c = .5 * (r - e), l = this.valueSize; this._weightPrev = c / (e - a), this._weightNext = c / (s - r), this._offsetPrev = i * l, this._offsetNext = o * l }, interpolate_: function (t, e, r, n) { for (var i = this.resultBuffer, o = this.sampleValues, a = this.valueSize, s = t * a, c = s - a, l = this._offsetPrev, h = this._offsetNext, u = this._weightPrev, p = this._weightNext, d = (r - e) / (n - e), f = d * d, m = f * d, v = -u * m + 2 * u * f - u * d, g = (1 + u) * m + (-1.5 - 2 * u) * f + (-.5 + u) * d + 1, y = (-1 - p) * m + (1.5 + p) * f + .5 * d, x = p * m - p * f, b = 0; b !== a; ++b)i[b] = v * o[l + b] + g * o[c + b] + y * o[s + b] + x * o[h + b]; return i } }), il.prototype = Object.assign(Object.create(rl.prototype), { constructor: il, interpolate_: function (t, e, r, n) { for (var i = this.resultBuffer, o = this.sampleValues, a = this.valueSize, s = t * a, c = s - a, l = (r - e) / (n - e), h = 1 - l, u = 0; u !== a; ++u)i[u] = o[c + u] * h + o[s + u] * l; return i } }), ol.prototype = Object.assign(Object.create(rl.prototype), { constructor: ol, interpolate_: function (t) { return this.copySampleValue_(t - 1) } }), Object.assign(al, { toJSON: function (t) { var e, r = t.constructor; if (void 0 !== r.toJSON) e = r.toJSON(t); else { e = { name: t.name, times: el.convertArray(t.times, Array), values: el.convertArray(t.values, Array) }; var n = t.getInterpolation(); n !== t.DefaultInterpolation && (e.interpolation = n) } return e.type = t.ValueTypeName, e } }), Object.assign(al.prototype, { constructor: al, TimeBufferType: Float32Array, ValueBufferType: Float32Array, DefaultInterpolation: 2301, InterpolantFactoryMethodDiscrete: function (t) { return new ol(this.times, this.values, this.getValueSize(), t) }, InterpolantFactoryMethodLinear: function (t) { return new il(this.times, this.values, this.getValueSize(), t) }, InterpolantFactoryMethodSmooth: function (t) { return new nl(this.times, this.values, this.getValueSize(), t) }, setInterpolation: function (t) { var e; switch (t) { case 2300: e = this.InterpolantFactoryMethodDiscrete; break; case 2301: e = this.InterpolantFactoryMethodLinear; break; case 2302: e = this.InterpolantFactoryMethodSmooth }if (void 0 === e) { var r = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name; if (void 0 === this.createInterpolant) { if (t === this.DefaultInterpolation) throw new Error(r); this.setInterpolation(this.DefaultInterpolation) } return console.warn("THREE.KeyframeTrack:", r), this } return this.createInterpolant = e, this }, getInterpolation: function () { switch (this.createInterpolant) { case this.InterpolantFactoryMethodDiscrete: return 2300; case this.InterpolantFactoryMethodLinear: return 2301; case this.InterpolantFactoryMethodSmooth: return 2302 } }, getValueSize: function () { return this.values.length / this.times.length }, shift: function (t) { if (0 !== t) for (var e = this.times, r = 0, n = e.length; r !== n; ++r)e[r] += t; return this }, scale: function (t) { if (1 !== t) for (var e = this.times, r = 0, n = e.length; r !== n; ++r)e[r] *= t; return this }, trim: function (t, e) { for (var r = this.times, n = r.length, i = 0, o = n - 1; i !== n && r[i] < t;)++i; for (; -1 !== o && r[o] > e;)--o; if (++o, 0 !== i || o !== n) { i >= o && (i = (o = Math.max(o, 1)) - 1); var a = this.getValueSize(); this.times = el.arraySlice(r, i, o), this.values = el.arraySlice(this.values, i * a, o * a) } return this }, validate: function () { var t = !0, e = this.getValueSize(); e - Math.floor(e) != 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), t = !1); var r = this.times, n = this.values, i = r.length; 0 === i && (console.error("THREE.KeyframeTrack: Track is empty.", this), t = !1); for (var o = null, a = 0; a !== i; a++) { var s = r[a]; if ("number" == typeof s && isNaN(s)) { console.error("THREE.KeyframeTrack: Time is not a valid number.", this, a, s), t = !1; break } if (null !== o && o > s) { console.error("THREE.KeyframeTrack: Out of order keys.", this, a, s, o), t = !1; break } o = s } if (void 0 !== n && el.isTypedArray(n)) { a = 0; for (var c = n.length; a !== c; ++a) { var l = n[a]; if (isNaN(l)) { console.error("THREE.KeyframeTrack: Value is not a valid number.", this, a, l), t = !1; break } } } return t }, optimize: function () { for (var t = this.times, e = this.values, r = this.getValueSize(), n = 2302 === this.getInterpolation(), i = 1, o = t.length - 1, a = 1; a < o; ++a) { var s = !1, c = t[a]; if (c !== t[a + 1] && (1 !== a || c !== c[0])) if (n) s = !0; else for (var l = a * r, h = l - r, u = l + r, p = 0; p !== r; ++p) { var d = e[l + p]; if (d !== e[h + p] || d !== e[u + p]) { s = !0; break } } if (s) { if (a !== i) { t[i] = t[a]; var f = a * r, m = i * r; for (p = 0; p !== r; ++p)e[m + p] = e[f + p] } ++i } } if (o > 0) { t[i] = t[o]; for (f = o * r, m = i * r, p = 0; p !== r; ++p)e[m + p] = e[f + p]; ++i } return i !== t.length && (this.times = el.arraySlice(t, 0, i), this.values = el.arraySlice(e, 0, i * r)), this }, clone: function () { var t = el.arraySlice(this.times, 0), e = el.arraySlice(this.values, 0), r = new (0, this.constructor)(this.name, t, e); return r.createInterpolant = this.createInterpolant, r } }), sl.prototype = Object.assign(Object.create(al.prototype), { constructor: sl, ValueTypeName: "bool", ValueBufferType: Array, DefaultInterpolation: 2300, InterpolantFactoryMethodLinear: void 0, InterpolantFactoryMethodSmooth: void 0 }), cl.prototype = Object.assign(Object.create(al.prototype), { constructor: cl, ValueTypeName: "color" }), ll.prototype = Object.assign(Object.create(al.prototype), { constructor: ll, ValueTypeName: "number" }), hl.prototype = Object.assign(Object.create(rl.prototype), { constructor: hl, interpolate_: function (t, e, r, n) { for (var i = this.resultBuffer, o = this.sampleValues, a = this.valueSize, s = t * a, c = (r - e) / (n - e), l = s + a; s !== l; s += 4)Re.slerpFlat(i, 0, o, s - a, o, s, c); return i } }), ul.prototype = Object.assign(Object.create(al.prototype), { constructor: ul, ValueTypeName: "quaternion", DefaultInterpolation: 2301, InterpolantFactoryMethodLinear: function (t) { return new hl(this.times, this.values, this.getValueSize(), t) }, InterpolantFactoryMethodSmooth: void 0 }), pl.prototype = Object.assign(Object.create(al.prototype), { constructor: pl, ValueTypeName: "string", ValueBufferType: Array, DefaultInterpolation: 2300, InterpolantFactoryMethodLinear: void 0, InterpolantFactoryMethodSmooth: void 0 }), dl.prototype = Object.assign(Object.create(al.prototype), { constructor: dl, ValueTypeName: "vector" }), Object.assign(fl, { parse: function (t) { for (var e = [], r = t.tracks, n = 1 / (t.fps || 1), i = 0, o = r.length; i !== o; ++i)e.push(ml(r[i]).scale(n)); return new fl(t.name, t.duration, e) }, toJSON: function (t) { for (var e = [], r = t.tracks, n = { name: t.name, duration: t.duration, tracks: e, uuid: t.uuid }, i = 0, o = r.length; i !== o; ++i)e.push(al.toJSON(r[i])); return n }, CreateFromMorphTargetSequence: function (t, e, r, n) { for (var i = e.length, o = [], a = 0; a < i; a++) { var s = [], c = []; s.push((a + i - 1) % i, a, (a + 1) % i), c.push(0, 1, 0); var l = el.getKeyframeOrder(s); s = el.sortedArray(s, 1, l), c = el.sortedArray(c, 1, l), n || 0 !== s[0] || (s.push(i), c.push(c[0])), o.push(new ll(".morphTargetInfluences[" + e[a].name + "]", s, c).scale(1 / r)) } return new fl(t, -1, o) }, findByName: function (t, e) { var r = t; if (!Array.isArray(t)) { var n = t; r = n.geometry && n.geometry.animations || n.animations } for (var i = 0; i < r.length; i++)if (r[i].name === e) return r[i]; return null }, CreateClipsFromMorphTargetSequences: function (t, e, r) { for (var n = {}, i = /^([\w-]*?)([\d]+)$/, o = 0, a = t.length; o < a; o++) { var s = t[o], c = s.name.match(i); if (c && c.length > 1) { var l = n[u = c[1]]; l || (n[u] = l = []), l.push(s) } } var h = []; for (var u in n) h.push(fl.CreateFromMorphTargetSequence(u, n[u], e, r)); return h }, parseAnimation: function (t, e) { if (!t) return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null; for (var r = function (t, e, r, n, i) { if (0 !== r.length) { var o = [], a = []; el.flattenJSON(r, o, a, n), 0 !== o.length && i.push(new t(e, o, a)) } }, n = [], i = t.name || "default", o = t.length || -1, a = t.fps || 30, s = t.hierarchy || [], c = 0; c < s.length; c++) { var l = s[c].keys; if (l && 0 !== l.length) if (l[0].morphTargets) { for (var h = {}, u = 0; u < l.length; u++)if (l[u].morphTargets) for (var p = 0; p < l[u].morphTargets.length; p++)h[l[u].morphTargets[p]] = -1; for (var d in h) { var f = [], m = []; for (p = 0; p !== l[u].morphTargets.length; ++p) { var v = l[u]; f.push(v.time), m.push(v.morphTarget === d ? 1 : 0) } n.push(new ll(".morphTargetInfluence[" + d + "]", f, m)) } o = h.length * (a || 1) } else { var g = ".bones[" + e[c].name + "]"; r(dl, g + ".position", l, "pos", n), r(ul, g + ".quaternion", l, "rot", n), r(dl, g + ".scale", l, "scl", n) } } return 0 === n.length ? null : new fl(i, o, n) } }), Object.assign(fl.prototype, { resetDuration: function () { for (var t = 0, e = 0, r = this.tracks.length; e !== r; ++e) { var n = this.tracks[e]; t = Math.max(t, n.times[n.times.length - 1]) } return this.duration = t, this }, trim: function () { for (var t = 0; t < this.tracks.length; t++)this.tracks[t].trim(0, this.duration); return this }, validate: function () { for (var t = !0, e = 0; e < this.tracks.length; e++)t = t && this.tracks[e].validate(); return t }, optimize: function () { for (var t = 0; t < this.tracks.length; t++)this.tracks[t].optimize(); return this }, clone: function () { for (var t = [], e = 0; e < this.tracks.length; e++)t.push(this.tracks[e].clone()); return new fl(this.name, this.duration, t) } }); var vl = { enabled: !1, files: {}, add: function (t, e) { !1 !== this.enabled && (this.files[t] = e) }, get: function (t) { if (!1 !== this.enabled) return this.files[t] }, remove: function (t) { delete this.files[t] }, clear: function () { this.files = {} } }; function gl(t, e, r) { var n = this, i = !1, o = 0, a = 0, s = void 0, c = []; this.onStart = void 0, this.onLoad = t, this.onProgress = e, this.onError = r, this.itemStart = function (t) { a++, !1 === i && void 0 !== n.onStart && n.onStart(t, o, a), i = !0 }, this.itemEnd = function (t) { o++, void 0 !== n.onProgress && n.onProgress(t, o, a), o === a && (i = !1, void 0 !== n.onLoad && n.onLoad()) }, this.itemError = function (t) { void 0 !== n.onError && n.onError(t) }, this.resolveURL = function (t) { return s ? s(t) : t }, this.setURLModifier = function (t) { return s = t, this }, this.addHandler = function (t, e) { return c.push(t, e), this }, this.removeHandler = function (t) { var e = c.indexOf(t); return -1 !== e && c.splice(e, 2), this }, this.getHandler = function (t) { for (var e = 0, r = c.length; e < r; e += 2) { var n = c[e], i = c[e + 1]; if (n.global && (n.lastIndex = 0), n.test(t)) return i } return null } } var yl = new gl; function xl(t) { this.manager = void 0 !== t ? t : yl, this.crossOrigin = "anonymous", this.path = "", this.resourcePath = "" } Object.assign(xl.prototype, { load: function () { }, parse: function () { }, setCrossOrigin: function (t) { return this.crossOrigin = t, this }, setPath: function (t) { return this.path = t, this }, setResourcePath: function (t) { return this.resourcePath = t, this } }); var bl = {}; function wl(t) { xl.call(this, t) } function _l(t) { xl.call(this, t) } function Ml(t) { xl.call(this, t) } function Sl(t) { xl.call(this, t) } function Tl(t) { xl.call(this, t) } function El(t) { xl.call(this, t) } function Al(t) { xl.call(this, t) } function Ll() { this.type = "Curve", this.arcLengthDivisions = 200 } function Pl(t, e, r, n, i, o, a, s) { Ll.call(this), this.type = "EllipseCurve", this.aX = t || 0, this.aY = e || 0, this.xRadius = r || 1, this.yRadius = n || 1, this.aStartAngle = i || 0, this.aEndAngle = o || 2 * Math.PI, this.aClockwise = a || !1, this.aRotation = s || 0 } function Rl(t, e, r, n, i, o) { Pl.call(this, t, e, r, r, n, i, o), this.type = "ArcCurve" } function Cl() { var t = 0, e = 0, r = 0, n = 0; function i(i, o, a, s) { t = i, e = a, r = -3 * i + 3 * o - 2 * a - s, n = 2 * i - 2 * o + a + s } return { initCatmullRom: function (t, e, r, n, o) { i(e, r, o * (r - t), o * (n - e)) }, initNonuniformCatmullRom: function (t, e, r, n, o, a, s) { var c = (e - t) / o - (r - t) / (o + a) + (r - e) / a, l = (r - e) / a - (n - e) / (a + s) + (n - r) / s; i(e, r, c *= a, l *= a) }, calc: function (i) { var o = i * i; return t + e * i + r * o + n * (o * i) } } } wl.prototype = Object.assign(Object.create(xl.prototype), { constructor: wl, load: function (t, e, r, n) { void 0 === t && (t = ""), void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t); var i = this, o = vl.get(t); if (void 0 !== o) return i.manager.itemStart(t), setTimeout((function () { e && e(o), i.manager.itemEnd(t) }), 0), o; if (void 0 === bl[t]) { var a = t.match(/^data:(.*?)(;base64)?,(.*)$/); if (a) { var s = a[1], c = !!a[2], l = a[3]; l = decodeURIComponent(l), c && (l = atob(l)); try { var h, u = (this.responseType || "").toLowerCase(); switch (u) { case "arraybuffer": case "blob": for (var p = new Uint8Array(l.length), d = 0; d < l.length; d++)p[d] = l.charCodeAt(d); h = "blob" === u ? new Blob([p.buffer], { type: s }) : p.buffer; break; case "document": var f = new DOMParser; h = f.parseFromString(l, s); break; case "json": h = JSON.parse(l); break; default: h = l }setTimeout((function () { e && e(h), i.manager.itemEnd(t) }), 0) } catch (e) { setTimeout((function () { n && n(e), i.manager.itemError(t), i.manager.itemEnd(t) }), 0) } } else { bl[t] = [], bl[t].push({ onLoad: e, onProgress: r, onError: n }); var m = new XMLHttpRequest; for (var v in m.open("GET", t, !0), m.addEventListener("load", (function (e) { var r = this.response, n = bl[t]; if (delete bl[t], 200 === this.status || 0 === this.status) { 0 === this.status && console.warn("THREE.FileLoader: HTTP Status 0 received."), vl.add(t, r); for (var o = 0, a = n.length; o < a; o++) { (s = n[o]).onLoad && s.onLoad(r) } i.manager.itemEnd(t) } else { for (o = 0, a = n.length; o < a; o++) { var s; (s = n[o]).onError && s.onError(e) } i.manager.itemError(t), i.manager.itemEnd(t) } }), !1), m.addEventListener("progress", (function (e) { for (var r = bl[t], n = 0, i = r.length; n < i; n++) { var o = r[n]; o.onProgress && o.onProgress(e) } }), !1), m.addEventListener("error", (function (e) { var r = bl[t]; delete bl[t]; for (var n = 0, o = r.length; n < o; n++) { var a = r[n]; a.onError && a.onError(e) } i.manager.itemError(t), i.manager.itemEnd(t) }), !1), m.addEventListener("abort", (function (e) { var r = bl[t]; delete bl[t]; for (var n = 0, o = r.length; n < o; n++) { var a = r[n]; a.onError && a.onError(e) } i.manager.itemError(t), i.manager.itemEnd(t) }), !1), void 0 !== this.responseType && (m.responseType = this.responseType), void 0 !== this.withCredentials && (m.withCredentials = this.withCredentials), m.overrideMimeType && m.overrideMimeType(void 0 !== this.mimeType ? this.mimeType : "text/plain"), this.requestHeader) m.setRequestHeader(v, this.requestHeader[v]); m.send(null) } return i.manager.itemStart(t), m } bl[t].push({ onLoad: e, onProgress: r, onError: n }) }, setResponseType: function (t) { return this.responseType = t, this }, setWithCredentials: function (t) { return this.withCredentials = t, this }, setMimeType: function (t) { return this.mimeType = t, this }, setRequestHeader: function (t) { return this.requestHeader = t, this } }), _l.prototype = Object.assign(Object.create(xl.prototype), { constructor: _l, load: function (t, e, r, n) { var i = this, o = new wl(i.manager); o.setPath(i.path), o.load(t, (function (t) { e(i.parse(JSON.parse(t))) }), r, n) }, parse: function (t) { for (var e = [], r = 0; r < t.length; r++) { var n = fl.parse(t[r]); e.push(n) } return e } }), Ml.prototype = Object.assign(Object.create(xl.prototype), { constructor: Ml, load: function (t, e, r, n) { var i = this, o = [], a = new Ls; a.image = o; var s = new wl(this.manager); function c(c) { s.load(t[c], (function (t) { var r = i.parse(t, !0); o[c] = { width: r.width, height: r.height, format: r.format, mipmaps: r.mipmaps }, 6 === (l += 1) && (1 === r.mipmapCount && (a.minFilter = dt), a.format = r.format, a.needsUpdate = !0, e && e(a)) }), r, n) } if (s.setPath(this.path), s.setResponseType("arraybuffer"), Array.isArray(t)) for (var l = 0, h = 0, u = t.length; h < u; ++h)c(h); else s.load(t, (function (t) { var r = i.parse(t, !0); if (r.isCubemap) for (var n = r.mipmaps.length / r.mipmapCount, s = 0; s < n; s++) { o[s] = { mipmaps: [] }; for (var c = 0; c < r.mipmapCount; c++)o[s].mipmaps.push(r.mipmaps[s * r.mipmapCount + c]), o[s].format = r.format, o[s].width = r.width, o[s].height = r.height } else a.image.width = r.width, a.image.height = r.height, a.mipmaps = r.mipmaps; 1 === r.mipmapCount && (a.minFilter = dt), a.format = r.format, a.needsUpdate = !0, e && e(a) }), r, n); return a } }), Sl.prototype = Object.assign(Object.create(xl.prototype), { constructor: Sl, load: function (t, e, r, n) { var i = this, o = new gi, a = new wl(this.manager); return a.setResponseType("arraybuffer"), a.setPath(this.path), a.load(t, (function (t) { var r = i.parse(t); r && (void 0 !== r.image ? o.image = r.image : void 0 !== r.data && (o.image.width = r.width, o.image.height = r.height, o.image.data = r.data), o.wrapS = void 0 !== r.wrapS ? r.wrapS : ct, o.wrapT = void 0 !== r.wrapT ? r.wrapT : ct, o.magFilter = void 0 !== r.magFilter ? r.magFilter : dt, o.minFilter = void 0 !== r.minFilter ? r.minFilter : dt, o.anisotropy = void 0 !== r.anisotropy ? r.anisotropy : 1, void 0 !== r.format && (o.format = r.format), void 0 !== r.type && (o.type = r.type), void 0 !== r.mipmaps && (o.mipmaps = r.mipmaps, o.minFilter = mt), 1 === r.mipmapCount && (o.minFilter = dt), o.needsUpdate = !0, e && e(o, r)) }), r, n), o } }), Tl.prototype = Object.assign(Object.create(xl.prototype), { constructor: Tl, load: function (t, e, r, n) { void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t); var i = this, o = vl.get(t); if (void 0 !== o) return i.manager.itemStart(t), setTimeout((function () { e && e(o), i.manager.itemEnd(t) }), 0), o; var a = document.createElementNS("http://www.w3.org/1999/xhtml", "img"); function s() { a.removeEventListener("load", s, !1), a.removeEventListener("error", c, !1), vl.add(t, this), e && e(this), i.manager.itemEnd(t) } function c(e) { a.removeEventListener("load", s, !1), a.removeEventListener("error", c, !1), n && n(e), i.manager.itemError(t), i.manager.itemEnd(t) } return a.addEventListener("load", s, !1), a.addEventListener("error", c, !1), "data:" !== t.substr(0, 5) && void 0 !== this.crossOrigin && (a.crossOrigin = this.crossOrigin), i.manager.itemStart(t), a.src = t, a } }), El.prototype = Object.assign(Object.create(xl.prototype), { constructor: El, load: function (t, e, r, n) { var i = new Bi, o = new Tl(this.manager); o.setCrossOrigin(this.crossOrigin), o.setPath(this.path); var a = 0; function s(r) { o.load(t[r], (function (t) { i.images[r] = t, 6 === ++a && (i.needsUpdate = !0, e && e(i)) }), void 0, n) } for (var c = 0; c < t.length; ++c)s(c); return i } }), Al.prototype = Object.assign(Object.create(xl.prototype), { constructor: Al, load: function (t, e, r, n) { var i = new Be, o = new Tl(this.manager); return o.setCrossOrigin(this.crossOrigin), o.setPath(this.path), o.load(t, (function (r) { i.image = r; var n = t.search(/\.jpe?g($|\?)/i) > 0 || 0 === t.search(/^data\:image\/jpeg/); i.format = n ? Pt : Rt, i.needsUpdate = !0, void 0 !== e && e(i) }), r, n), i } }), Object.assign(Ll.prototype, { getPoint: function () { return console.warn("THREE.Curve: .getPoint() not implemented."), null }, getPointAt: function (t, e) { var r = this.getUtoTmapping(t); return this.getPoint(r, e) }, getPoints: function (t) { void 0 === t && (t = 5); for (var e = [], r = 0; r <= t; r++)e.push(this.getPoint(r / t)); return e }, getSpacedPoints: function (t) { void 0 === t && (t = 5); for (var e = [], r = 0; r <= t; r++)e.push(this.getPointAt(r / t)); return e }, getLength: function () { var t = this.getLengths(); return t[t.length - 1] }, getLengths: function (t) { if (void 0 === t && (t = this.arcLengthDivisions), this.cacheArcLengths && this.cacheArcLengths.length === t + 1 && !this.needsUpdate) return this.cacheArcLengths; this.needsUpdate = !1; var e, r, n = [], i = this.getPoint(0), o = 0; for (n.push(0), r = 1; r <= t; r++)o += (e = this.getPoint(r / t)).distanceTo(i), n.push(o), i = e; return this.cacheArcLengths = n, n }, updateArcLengths: function () { this.needsUpdate = !0, this.getLengths() }, getUtoTmapping: function (t, e) { var r, n = this.getLengths(), i = 0, o = n.length; r = e || t * n[o - 1]; for (var a, s = 0, c = o - 1; s <= c;)if ((a = n[i = Math.floor(s + (c - s) / 2)] - r) < 0) s = i + 1; else { if (!(a > 0)) { c = i; break } c = i - 1 } if (n[i = c] === r) return i / (o - 1); var l = n[i]; return (i + (r - l) / (n[i + 1] - l)) / (o - 1) }, getTangent: function (t) { var e = t - 1e-4, r = t + 1e-4; e < 0 && (e = 0), r > 1 && (r = 1); var n = this.getPoint(e); return this.getPoint(r).clone().sub(n).normalize() }, getTangentAt: function (t) { var e = this.getUtoTmapping(t); return this.getTangent(e) }, computeFrenetFrames: function (t, e) { var r, n, i, o = new Ie, a = [], s = [], c = [], l = new Ie, h = new Je; for (r = 0; r <= t; r++)n = r / t, a[r] = this.getTangentAt(n), a[r].normalize(); s[0] = new Ie, c[0] = new Ie; var u = Number.MAX_VALUE, p = Math.abs(a[0].x), d = Math.abs(a[0].y), f = Math.abs(a[0].z); for (p <= u && (u = p, o.set(1, 0, 0)), d <= u && (u = d, o.set(0, 1, 0)), f <= u && o.set(0, 0, 1), l.crossVectors(a[0], o).normalize(), s[0].crossVectors(a[0], l), c[0].crossVectors(a[0], s[0]), r = 1; r <= t; r++)s[r] = s[r - 1].clone(), c[r] = c[r - 1].clone(), l.crossVectors(a[r - 1], a[r]), l.length() > Number.EPSILON && (l.normalize(), i = Math.acos(Le.clamp(a[r - 1].dot(a[r]), -1, 1)), s[r].applyMatrix4(h.makeRotationAxis(l, i))), c[r].crossVectors(a[r], s[r]); if (!0 === e) for (i = Math.acos(Le.clamp(s[0].dot(s[t]), -1, 1)), i /= t, a[0].dot(l.crossVectors(s[0], s[t])) > 0 && (i = -i), r = 1; r <= t; r++)s[r].applyMatrix4(h.makeRotationAxis(a[r], i * r)), c[r].crossVectors(a[r], s[r]); return { tangents: a, normals: s, binormals: c } }, clone: function () { return (new this.constructor).copy(this) }, copy: function (t) { return this.arcLengthDivisions = t.arcLengthDivisions, this }, toJSON: function () { var t = { metadata: { version: 4.5, type: "Curve", generator: "Curve.toJSON" } }; return t.arcLengthDivisions = this.arcLengthDivisions, t.type = this.type, t }, fromJSON: function (t) { return this.arcLengthDivisions = t.arcLengthDivisions, this } }), Pl.prototype = Object.create(Ll.prototype), Pl.prototype.constructor = Pl, Pl.prototype.isEllipseCurve = !0, Pl.prototype.getPoint = function (t, e) { for (var r = e || new Pe, n = 2 * Math.PI, i = this.aEndAngle - this.aStartAngle, o = Math.abs(i) < Number.EPSILON; i < 0;)i += n; for (; i > n;)i -= n; i < Number.EPSILON && (i = o ? 0 : n), !0 !== this.aClockwise || o || (i === n ? i = -n : i -= n); var a = this.aStartAngle + t * i, s = this.aX + this.xRadius * Math.cos(a), c = this.aY + this.yRadius * Math.sin(a); if (0 !== this.aRotation) { var l = Math.cos(this.aRotation), h = Math.sin(this.aRotation), u = s - this.aX, p = c - this.aY; s = u * l - p * h + this.aX, c = u * h + p * l + this.aY } return r.set(s, c) }, Pl.prototype.copy = function (t) { return Ll.prototype.copy.call(this, t), this.aX = t.aX, this.aY = t.aY, this.xRadius = t.xRadius, this.yRadius = t.yRadius, this.aStartAngle = t.aStartAngle, this.aEndAngle = t.aEndAngle, this.aClockwise = t.aClockwise, this.aRotation = t.aRotation, this }, Pl.prototype.toJSON = function () { var t = Ll.prototype.toJSON.call(this); return t.aX = this.aX, t.aY = this.aY, t.xRadius = this.xRadius, t.yRadius = this.yRadius, t.aStartAngle = this.aStartAngle, t.aEndAngle = this.aEndAngle, t.aClockwise = this.aClockwise, t.aRotation = this.aRotation, t }, Pl.prototype.fromJSON = function (t) { return Ll.prototype.fromJSON.call(this, t), this.aX = t.aX, this.aY = t.aY, this.xRadius = t.xRadius, this.yRadius = t.yRadius, this.aStartAngle = t.aStartAngle, this.aEndAngle = t.aEndAngle, this.aClockwise = t.aClockwise, this.aRotation = t.aRotation, this }, Rl.prototype = Object.create(Pl.prototype), Rl.prototype.constructor = Rl, Rl.prototype.isArcCurve = !0; var Ol = new Ie, Il = new Cl, Nl = new Cl, Dl = new Cl; function zl(t, e, r, n) { Ll.call(this), this.type = "CatmullRomCurve3", this.points = t || [], this.closed = e || !1, this.curveType = r || "centripetal", this.tension = n || .5 } function Fl(t, e, r, n, i) { var o = .5 * (n - e), a = .5 * (i - r), s = t * t; return (2 * r - 2 * n + o + a) * (t * s) + (-3 * r + 3 * n - 2 * o - a) * s + o * t + r } function Ul(t, e, r, n) { return function (t, e) { var r = 1 - t; return r * r * e }(t, e) + function (t, e) { return 2 * (1 - t) * t * e }(t, r) + function (t, e) { return t * t * e }(t, n) } function Bl(t, e, r, n, i) { return function (t, e) { var r = 1 - t; return r * r * r * e }(t, e) + function (t, e) { var r = 1 - t; return 3 * r * r * t * e }(t, r) + function (t, e) { return 3 * (1 - t) * t * t * e }(t, n) + function (t, e) { return t * t * t * e }(t, i) } function kl(t, e, r, n) { Ll.call(this), this.type = "CubicBezierCurve", this.v0 = t || new Pe, this.v1 = e || new Pe, this.v2 = r || new Pe, this.v3 = n || new Pe } function jl(t, e, r, n) { Ll.call(this), this.type = "CubicBezierCurve3", this.v0 = t || new Ie, this.v1 = e || new Ie, this.v2 = r || new Ie, this.v3 = n || new Ie } function Gl(t, e) { Ll.call(this), this.type = "LineCurve", this.v1 = t || new Pe, this.v2 = e || new Pe } function Vl(t, e) { Ll.call(this), this.type = "LineCurve3", this.v1 = t || new Ie, this.v2 = e || new Ie } function Hl(t, e, r) { Ll.call(this), this.type = "QuadraticBezierCurve", this.v0 = t || new Pe, this.v1 = e || new Pe, this.v2 = r || new Pe } function Wl(t, e, r) { Ll.call(this), this.type = "QuadraticBezierCurve3", this.v0 = t || new Ie, this.v1 = e || new Ie, this.v2 = r || new Ie } function ql(t) { Ll.call(this), this.type = "SplineCurve", this.points = t || [] } zl.prototype = Object.create(Ll.prototype), zl.prototype.constructor = zl, zl.prototype.isCatmullRomCurve3 = !0, zl.prototype.getPoint = function (t, e) { var r, n, i, o, a = e || new Ie, s = this.points, c = s.length, l = (c - (this.closed ? 0 : 1)) * t, h = Math.floor(l), u = l - h; if (this.closed ? h += h > 0 ? 0 : (Math.floor(Math.abs(h) / c) + 1) * c : 0 === u && h === c - 1 && (h = c - 2, u = 1), this.closed || h > 0 ? r = s[(h - 1) % c] : (Ol.subVectors(s[0], s[1]).add(s[0]), r = Ol), n = s[h % c], i = s[(h + 1) % c], this.closed || h + 2 < c ? o = s[(h + 2) % c] : (Ol.subVectors(s[c - 1], s[c - 2]).add(s[c - 1]), o = Ol), "centripetal" === this.curveType || "chordal" === this.curveType) { var p = "chordal" === this.curveType ? .5 : .25, d = Math.pow(r.distanceToSquared(n), p), f = Math.pow(n.distanceToSquared(i), p), m = Math.pow(i.distanceToSquared(o), p); f < 1e-4 && (f = 1), d < 1e-4 && (d = f), m < 1e-4 && (m = f), Il.initNonuniformCatmullRom(r.x, n.x, i.x, o.x, d, f, m), Nl.initNonuniformCatmullRom(r.y, n.y, i.y, o.y, d, f, m), Dl.initNonuniformCatmullRom(r.z, n.z, i.z, o.z, d, f, m) } else "catmullrom" === this.curveType && (Il.initCatmullRom(r.x, n.x, i.x, o.x, this.tension), Nl.initCatmullRom(r.y, n.y, i.y, o.y, this.tension), Dl.initCatmullRom(r.z, n.z, i.z, o.z, this.tension)); return a.set(Il.calc(u), Nl.calc(u), Dl.calc(u)), a }, zl.prototype.copy = function (t) { Ll.prototype.copy.call(this, t), this.points = []; for (var e = 0, r = t.points.length; e < r; e++) { var n = t.points[e]; this.points.push(n.clone()) } return this.closed = t.closed, this.curveType = t.curveType, this.tension = t.tension, this }, zl.prototype.toJSON = function () { var t = Ll.prototype.toJSON.call(this); t.points = []; for (var e = 0, r = this.points.length; e < r; e++) { var n = this.points[e]; t.points.push(n.toArray()) } return t.closed = this.closed, t.curveType = this.curveType, t.tension = this.tension, t }, zl.prototype.fromJSON = function (t) { Ll.prototype.fromJSON.call(this, t), this.points = []; for (var e = 0, r = t.points.length; e < r; e++) { var n = t.points[e]; this.points.push((new Ie).fromArray(n)) } return this.closed = t.closed, this.curveType = t.curveType, this.tension = t.tension, this }, kl.prototype = Object.create(Ll.prototype), kl.prototype.constructor = kl, kl.prototype.isCubicBezierCurve = !0, kl.prototype.getPoint = function (t, e) { var r = e || new Pe, n = this.v0, i = this.v1, o = this.v2, a = this.v3; return r.set(Bl(t, n.x, i.x, o.x, a.x), Bl(t, n.y, i.y, o.y, a.y)), r }, kl.prototype.copy = function (t) { return Ll.prototype.copy.call(this, t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this.v3.copy(t.v3), this }, kl.prototype.toJSON = function () { var t = Ll.prototype.toJSON.call(this); return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t.v3 = this.v3.toArray(), t }, kl.prototype.fromJSON = function (t) { return Ll.prototype.fromJSON.call(this, t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this.v3.fromArray(t.v3), this }, jl.prototype = Object.create(Ll.prototype), jl.prototype.constructor = jl, jl.prototype.isCubicBezierCurve3 = !0, jl.prototype.getPoint = function (t, e) { var r = e || new Ie, n = this.v0, i = this.v1, o = this.v2, a = this.v3; return r.set(Bl(t, n.x, i.x, o.x, a.x), Bl(t, n.y, i.y, o.y, a.y), Bl(t, n.z, i.z, o.z, a.z)), r }, jl.prototype.copy = function (t) { return Ll.prototype.copy.call(this, t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this.v3.copy(t.v3), this }, jl.prototype.toJSON = function () { var t = Ll.prototype.toJSON.call(this); return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t.v3 = this.v3.toArray(), t }, jl.prototype.fromJSON = function (t) { return Ll.prototype.fromJSON.call(this, t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this.v3.fromArray(t.v3), this }, Gl.prototype = Object.create(Ll.prototype), Gl.prototype.constructor = Gl, Gl.prototype.isLineCurve = !0, Gl.prototype.getPoint = function (t, e) { var r = e || new Pe; return 1 === t ? r.copy(this.v2) : (r.copy(this.v2).sub(this.v1), r.multiplyScalar(t).add(this.v1)), r }, Gl.prototype.getPointAt = function (t, e) { return this.getPoint(t, e) }, Gl.prototype.getTangent = function () { return this.v2.clone().sub(this.v1).normalize() }, Gl.prototype.copy = function (t) { return Ll.prototype.copy.call(this, t), this.v1.copy(t.v1), this.v2.copy(t.v2), this }, Gl.prototype.toJSON = function () { var t = Ll.prototype.toJSON.call(this); return t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t }, Gl.prototype.fromJSON = function (t) { return Ll.prototype.fromJSON.call(this, t), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this }, Vl.prototype = Object.create(Ll.prototype), Vl.prototype.constructor = Vl, Vl.prototype.isLineCurve3 = !0, Vl.prototype.getPoint = function (t, e) { var r = e || new Ie; return 1 === t ? r.copy(this.v2) : (r.copy(this.v2).sub(this.v1), r.multiplyScalar(t).add(this.v1)), r }, Vl.prototype.getPointAt = function (t, e) { return this.getPoint(t, e) }, Vl.prototype.copy = function (t) { return Ll.prototype.copy.call(this, t), this.v1.copy(t.v1), this.v2.copy(t.v2), this }, Vl.prototype.toJSON = function () { var t = Ll.prototype.toJSON.call(this); return t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t }, Vl.prototype.fromJSON = function (t) { return Ll.prototype.fromJSON.call(this, t), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this }, Hl.prototype = Object.create(Ll.prototype), Hl.prototype.constructor = Hl, Hl.prototype.isQuadraticBezierCurve = !0, Hl.prototype.getPoint = function (t, e) { var r = e || new Pe, n = this.v0, i = this.v1, o = this.v2; return r.set(Ul(t, n.x, i.x, o.x), Ul(t, n.y, i.y, o.y)), r }, Hl.prototype.copy = function (t) { return Ll.prototype.copy.call(this, t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this }, Hl.prototype.toJSON = function () { var t = Ll.prototype.toJSON.call(this); return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t }, Hl.prototype.fromJSON = function (t) { return Ll.prototype.fromJSON.call(this, t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this }, Wl.prototype = Object.create(Ll.prototype), Wl.prototype.constructor = Wl, Wl.prototype.isQuadraticBezierCurve3 = !0, Wl.prototype.getPoint = function (t, e) { var r = e || new Ie, n = this.v0, i = this.v1, o = this.v2; return r.set(Ul(t, n.x, i.x, o.x), Ul(t, n.y, i.y, o.y), Ul(t, n.z, i.z, o.z)), r }, Wl.prototype.copy = function (t) { return Ll.prototype.copy.call(this, t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this }, Wl.prototype.toJSON = function () { var t = Ll.prototype.toJSON.call(this); return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t }, Wl.prototype.fromJSON = function (t) { return Ll.prototype.fromJSON.call(this, t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this }, ql.prototype = Object.create(Ll.prototype), ql.prototype.constructor = ql, ql.prototype.isSplineCurve = !0, ql.prototype.getPoint = function (t, e) { var r = e || new Pe, n = this.points, i = (n.length - 1) * t, o = Math.floor(i), a = i - o, s = n[0 === o ? o : o - 1], c = n[o], l = n[o > n.length - 2 ? n.length - 1 : o + 1], h = n[o > n.length - 3 ? n.length - 1 : o + 2]; return r.set(Fl(a, s.x, c.x, l.x, h.x), Fl(a, s.y, c.y, l.y, h.y)), r }, ql.prototype.copy = function (t) { Ll.prototype.copy.call(this, t), this.points = []; for (var e = 0, r = t.points.length; e < r; e++) { var n = t.points[e]; this.points.push(n.clone()) } return this }, ql.prototype.toJSON = function () { var t = Ll.prototype.toJSON.call(this); t.points = []; for (var e = 0, r = this.points.length; e < r; e++) { var n = this.points[e]; t.points.push(n.toArray()) } return t }, ql.prototype.fromJSON = function (t) { Ll.prototype.fromJSON.call(this, t), this.points = []; for (var e = 0, r = t.points.length; e < r; e++) { var n = t.points[e]; this.points.push((new Pe).fromArray(n)) } return this }; var Xl = Object.freeze({ __proto__: null, ArcCurve: Rl, CatmullRomCurve3: zl, CubicBezierCurve: kl, CubicBezierCurve3: jl, EllipseCurve: Pl, LineCurve: Gl, LineCurve3: Vl, QuadraticBezierCurve: Hl, QuadraticBezierCurve3: Wl, SplineCurve: ql }); function Yl() { Ll.call(this), this.type = "CurvePath", this.curves = [], this.autoClose = !1 } function Zl(t) { Yl.call(this), this.type = "Path", this.currentPoint = new Pe, t && this.setFromPoints(t) } function Jl(t) { Zl.call(this, t), this.uuid = Le.generateUUID(), this.type = "Shape", this.holes = [] } function Kl(t, e) { fr.call(this), this.type = "Light", this.color = new an(t), this.intensity = void 0 !== e ? e : 1, this.receiveShadow = void 0 } function Ql(t, e, r) { Kl.call(this, t, r), this.type = "HemisphereLight", this.castShadow = void 0, this.position.copy(fr.DefaultUp), this.updateMatrix(), this.groundColor = new an(e) } function $l(t) { this.camera = t, this.bias = 0, this.radius = 1, this.mapSize = new Pe(512, 512), this.map = null, this.mapPass = null, this.matrix = new Je, this._frustum = new bi, this._frameExtents = new Pe(1, 1), this._viewportCount = 1, this._viewports = [new ke(0, 0, 1, 1)] } function th() { $l.call(this, new pi(50, 1, .5, 500)) } function eh(t, e, r, n, i, o) { Kl.call(this, t, e), this.type = "SpotLight", this.position.copy(fr.DefaultUp), this.updateMatrix(), this.target = new fr, Object.defineProperty(this, "power", { get: function () { return this.intensity * Math.PI }, set: function (t) { this.intensity = t / Math.PI } }), this.distance = void 0 !== r ? r : 0, this.angle = void 0 !== n ? n : Math.PI / 3, this.penumbra = void 0 !== i ? i : 0, this.decay = void 0 !== o ? o : 1, this.shadow = new th } function rh() { $l.call(this, new pi(90, 1, .5, 500)), this._frameExtents = new Pe(4, 2), this._viewportCount = 6, this._viewports = [new ke(2, 1, 1, 1), new ke(0, 1, 1, 1), new ke(3, 1, 1, 1), new ke(1, 1, 1, 1), new ke(3, 0, 1, 1), new ke(1, 0, 1, 1)], this._cubeDirections = [new Ie(1, 0, 0), new Ie(-1, 0, 0), new Ie(0, 0, 1), new Ie(0, 0, -1), new Ie(0, 1, 0), new Ie(0, -1, 0)], this._cubeUps = [new Ie(0, 1, 0), new Ie(0, 1, 0), new Ie(0, 1, 0), new Ie(0, 1, 0), new Ie(0, 0, 1), new Ie(0, 0, -1)] } function nh(t, e, r, n) { Kl.call(this, t, e), this.type = "PointLight", Object.defineProperty(this, "power", { get: function () { return 4 * this.intensity * Math.PI }, set: function (t) { this.intensity = t / (4 * Math.PI) } }), this.distance = void 0 !== r ? r : 0, this.decay = void 0 !== n ? n : 1, this.shadow = new rh } function ih(t, e, r, n, i, o) { ui.call(this), this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = void 0 !== t ? t : -1, this.right = void 0 !== e ? e : 1, this.top = void 0 !== r ? r : 1, this.bottom = void 0 !== n ? n : -1, this.near = void 0 !== i ? i : .1, this.far = void 0 !== o ? o : 2e3, this.updateProjectionMatrix() } function oh() { $l.call(this, new ih(-5, 5, 5, -5, .5, 500)) } function ah(t, e) { Kl.call(this, t, e), this.type = "DirectionalLight", this.position.copy(fr.DefaultUp), this.updateMatrix(), this.target = new fr, this.shadow = new oh } function sh(t, e) { Kl.call(this, t, e), this.type = "AmbientLight", this.castShadow = void 0 } function ch(t, e, r, n) { Kl.call(this, t, e), this.type = "RectAreaLight", this.width = void 0 !== r ? r : 10, this.height = void 0 !== n ? n : 10 } function lh(t) { xl.call(this, t), this.textures = {} } Yl.prototype = Object.assign(Object.create(Ll.prototype), { constructor: Yl, add: function (t) { this.curves.push(t) }, closePath: function () { var t = this.curves[0].getPoint(0), e = this.curves[this.curves.length - 1].getPoint(1); t.equals(e) || this.curves.push(new Gl(e, t)) }, getPoint: function (t) { for (var e = t * this.getLength(), r = this.getCurveLengths(), n = 0; n < r.length;) { if (r[n] >= e) { var i = r[n] - e, o = this.curves[n], a = o.getLength(), s = 0 === a ? 0 : 1 - i / a; return o.getPointAt(s) } n++ } return null }, getLength: function () { var t = this.getCurveLengths(); return t[t.length - 1] }, updateArcLengths: function () { this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths() }, getCurveLengths: function () { if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths; for (var t = [], e = 0, r = 0, n = this.curves.length; r < n; r++)e += this.curves[r].getLength(), t.push(e); return this.cacheLengths = t, t }, getSpacedPoints: function (t) { void 0 === t && (t = 40); for (var e = [], r = 0; r <= t; r++)e.push(this.getPoint(r / t)); return this.autoClose && e.push(e[0]), e }, getPoints: function (t) { t = t || 12; for (var e, r = [], n = 0, i = this.curves; n < i.length; n++)for (var o = i[n], a = o && o.isEllipseCurve ? 2 * t : o && (o.isLineCurve || o.isLineCurve3) ? 1 : o && o.isSplineCurve ? t * o.points.length : t, s = o.getPoints(a), c = 0; c < s.length; c++) { var l = s[c]; e && e.equals(l) || (r.push(l), e = l) } return this.autoClose && r.length > 1 && !r[r.length - 1].equals(r[0]) && r.push(r[0]), r }, copy: function (t) { Ll.prototype.copy.call(this, t), this.curves = []; for (var e = 0, r = t.curves.length; e < r; e++) { var n = t.curves[e]; this.curves.push(n.clone()) } return this.autoClose = t.autoClose, this }, toJSON: function () { var t = Ll.prototype.toJSON.call(this); t.autoClose = this.autoClose, t.curves = []; for (var e = 0, r = this.curves.length; e < r; e++) { var n = this.curves[e]; t.curves.push(n.toJSON()) } return t }, fromJSON: function (t) { Ll.prototype.fromJSON.call(this, t), this.autoClose = t.autoClose, this.curves = []; for (var e = 0, r = t.curves.length; e < r; e++) { var n = t.curves[e]; this.curves.push((new Xl[n.type]).fromJSON(n)) } return this } }), Zl.prototype = Object.assign(Object.create(Yl.prototype), { constructor: Zl, setFromPoints: function (t) { this.moveTo(t[0].x, t[0].y); for (var e = 1, r = t.length; e < r; e++)this.lineTo(t[e].x, t[e].y); return this }, moveTo: function (t, e) { return this.currentPoint.set(t, e), this }, lineTo: function (t, e) { var r = new Gl(this.currentPoint.clone(), new Pe(t, e)); return this.curves.push(r), this.currentPoint.set(t, e), this }, quadraticCurveTo: function (t, e, r, n) { var i = new Hl(this.currentPoint.clone(), new Pe(t, e), new Pe(r, n)); return this.curves.push(i), this.currentPoint.set(r, n), this }, bezierCurveTo: function (t, e, r, n, i, o) { var a = new kl(this.currentPoint.clone(), new Pe(t, e), new Pe(r, n), new Pe(i, o)); return this.curves.push(a), this.currentPoint.set(i, o), this }, splineThru: function (t) { var e = new ql([this.currentPoint.clone()].concat(t)); return this.curves.push(e), this.currentPoint.copy(t[t.length - 1]), this }, arc: function (t, e, r, n, i, o) { var a = this.currentPoint.x, s = this.currentPoint.y; return this.absarc(t + a, e + s, r, n, i, o), this }, absarc: function (t, e, r, n, i, o) { return this.absellipse(t, e, r, r, n, i, o), this }, ellipse: function (t, e, r, n, i, o, a, s) { var c = this.currentPoint.x, l = this.currentPoint.y; return this.absellipse(t + c, e + l, r, n, i, o, a, s), this }, absellipse: function (t, e, r, n, i, o, a, s) { var c = new Pl(t, e, r, n, i, o, a, s); if (this.curves.length > 0) { var l = c.getPoint(0); l.equals(this.currentPoint) || this.lineTo(l.x, l.y) } this.curves.push(c); var h = c.getPoint(1); return this.currentPoint.copy(h), this }, copy: function (t) { return Yl.prototype.copy.call(this, t), this.currentPoint.copy(t.currentPoint), this }, toJSON: function () { var t = Yl.prototype.toJSON.call(this); return t.currentPoint = this.currentPoint.toArray(), t }, fromJSON: function (t) { return Yl.prototype.fromJSON.call(this, t), this.currentPoint.fromArray(t.currentPoint), this } }), Jl.prototype = Object.assign(Object.create(Zl.prototype), { constructor: Jl, getPointsHoles: function (t) { for (var e = [], r = 0, n = this.holes.length; r < n; r++)e[r] = this.holes[r].getPoints(t); return e }, extractPoints: function (t) { return { shape: this.getPoints(t), holes: this.getPointsHoles(t) } }, copy: function (t) { Zl.prototype.copy.call(this, t), this.holes = []; for (var e = 0, r = t.holes.length; e < r; e++) { var n = t.holes[e]; this.holes.push(n.clone()) } return this }, toJSON: function () { var t = Zl.prototype.toJSON.call(this); t.uuid = this.uuid, t.holes = []; for (var e = 0, r = this.holes.length; e < r; e++) { var n = this.holes[e]; t.holes.push(n.toJSON()) } return t }, fromJSON: function (t) { Zl.prototype.fromJSON.call(this, t), this.uuid = t.uuid, this.holes = []; for (var e = 0, r = t.holes.length; e < r; e++) { var n = t.holes[e]; this.holes.push((new Zl).fromJSON(n)) } return this } }), Kl.prototype = Object.assign(Object.create(fr.prototype), { constructor: Kl, isLight: !0, copy: function (t) { return fr.prototype.copy.call(this, t), this.color.copy(t.color), this.intensity = t.intensity, this }, toJSON: function (t) { var e = fr.prototype.toJSON.call(this, t); return e.object.color = this.color.getHex(), e.object.intensity = this.intensity, void 0 !== this.groundColor && (e.object.groundColor = this.groundColor.getHex()), void 0 !== this.distance && (e.object.distance = this.distance), void 0 !== this.angle && (e.object.angle = this.angle), void 0 !== this.decay && (e.object.decay = this.decay), void 0 !== this.penumbra && (e.object.penumbra = this.penumbra), void 0 !== this.shadow && (e.object.shadow = this.shadow.toJSON()), e } }), Ql.prototype = Object.assign(Object.create(Kl.prototype), { constructor: Ql, isHemisphereLight: !0, copy: function (t) { return Kl.prototype.copy.call(this, t), this.groundColor.copy(t.groundColor), this } }), Object.assign($l.prototype, { _projScreenMatrix: new Je, _lightPositionWorld: new Ie, _lookTarget: new Ie, getViewportCount: function () { return this._viewportCount }, getFrustum: function () { return this._frustum }, updateMatrices: function (t) { var e = this.camera, r = this.matrix, n = this._projScreenMatrix, i = this._lookTarget, o = this._lightPositionWorld; o.setFromMatrixPosition(t.matrixWorld), e.position.copy(o), i.setFromMatrixPosition(t.target.matrixWorld), e.lookAt(i), e.updateMatrixWorld(), n.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse), this._frustum.setFromMatrix(n), r.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), r.multiply(e.projectionMatrix), r.multiply(e.matrixWorldInverse) }, getViewport: function (t) { return this._viewports[t] }, getFrameExtents: function () { return this._frameExtents }, copy: function (t) { return this.camera = t.camera.clone(), this.bias = t.bias, this.radius = t.radius, this.mapSize.copy(t.mapSize), this }, clone: function () { return (new this.constructor).copy(this) }, toJSON: function () { var t = {}; return 0 !== this.bias && (t.bias = this.bias), 1 !== this.radius && (t.radius = this.radius), 512 === this.mapSize.x && 512 === this.mapSize.y || (t.mapSize = this.mapSize.toArray()), t.camera = this.camera.toJSON(!1).object, delete t.camera.matrix, t } }), th.prototype = Object.assign(Object.create($l.prototype), { constructor: th, isSpotLightShadow: !0, updateMatrices: function (t) { var e = this.camera, r = 2 * Le.RAD2DEG * t.angle, n = this.mapSize.width / this.mapSize.height, i = t.distance || e.far; r === e.fov && n === e.aspect && i === e.far || (e.fov = r, e.aspect = n, e.far = i, e.updateProjectionMatrix()), $l.prototype.updateMatrices.call(this, t) } }), eh.prototype = Object.assign(Object.create(Kl.prototype), { constructor: eh, isSpotLight: !0, copy: function (t) { return Kl.prototype.copy.call(this, t), this.distance = t.distance, this.angle = t.angle, this.penumbra = t.penumbra, this.decay = t.decay, this.target = t.target.clone(), this.shadow = t.shadow.clone(), this } }), rh.prototype = Object.assign(Object.create($l.prototype), { constructor: rh, isPointLightShadow: !0, updateMatrices: function (t, e) { void 0 === e && (e = 0); var r = this.camera, n = this.matrix, i = this._lightPositionWorld, o = this._lookTarget, a = this._projScreenMatrix; i.setFromMatrixPosition(t.matrixWorld), r.position.copy(i), o.copy(r.position), o.add(this._cubeDirections[e]), r.up.copy(this._cubeUps[e]), r.lookAt(o), r.updateMatrixWorld(), n.makeTranslation(-i.x, -i.y, -i.z), a.multiplyMatrices(r.projectionMatrix, r.matrixWorldInverse), this._frustum.setFromMatrix(a) } }), nh.prototype = Object.assign(Object.create(Kl.prototype), { constructor: nh, isPointLight: !0, copy: function (t) { return Kl.prototype.copy.call(this, t), this.distance = t.distance, this.decay = t.decay, this.shadow = t.shadow.clone(), this } }), ih.prototype = Object.assign(Object.create(ui.prototype), { constructor: ih, isOrthographicCamera: !0, copy: function (t, e) { return ui.prototype.copy.call(this, t, e), this.left = t.left, this.right = t.right, this.top = t.top, this.bottom = t.bottom, this.near = t.near, this.far = t.far, this.zoom = t.zoom, this.view = null === t.view ? null : Object.assign({}, t.view), this }, setViewOffset: function (t, e, r, n, i, o) { null === this.view && (this.view = { enabled: !0, fullWidth: 1, fullHeight: 1, offsetX: 0, offsetY: 0, width: 1, height: 1 }), this.view.enabled = !0, this.view.fullWidth = t, this.view.fullHeight = e, this.view.offsetX = r, this.view.offsetY = n, this.view.width = i, this.view.height = o, this.updateProjectionMatrix() }, clearViewOffset: function () { null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix() }, updateProjectionMatrix: function () { var t = (this.right - this.left) / (2 * this.zoom), e = (this.top - this.bottom) / (2 * this.zoom), r = (this.right + this.left) / 2, n = (this.top + this.bottom) / 2, i = r - t, o = r + t, a = n + e, s = n - e; if (null !== this.view && this.view.enabled) { var c = this.zoom / (this.view.width / this.view.fullWidth), l = this.zoom / (this.view.height / this.view.fullHeight), h = (this.right - this.left) / this.view.width, u = (this.top - this.bottom) / this.view.height; o = (i += h * (this.view.offsetX / c)) + h * (this.view.width / c), s = (a -= u * (this.view.offsetY / l)) - u * (this.view.height / l) } this.projectionMatrix.makeOrthographic(i, o, a, s, this.near, this.far), this.projectionMatrixInverse.getInverse(this.projectionMatrix) }, toJSON: function (t) { var e = fr.prototype.toJSON.call(this, t); return e.object.zoom = this.zoom, e.object.left = this.left, e.object.right = this.right, e.object.top = this.top, e.object.bottom = this.bottom, e.object.near = this.near, e.object.far = this.far, null !== this.view && (e.object.view = Object.assign({}, this.view)), e } }), oh.prototype = Object.assign(Object.create($l.prototype), { constructor: oh, isDirectionalLightShadow: !0, updateMatrices: function (t) { $l.prototype.updateMatrices.call(this, t) } }), ah.prototype = Object.assign(Object.create(Kl.prototype), { constructor: ah, isDirectionalLight: !0, copy: function (t) { return Kl.prototype.copy.call(this, t), this.target = t.target.clone(), this.shadow = t.shadow.clone(), this } }), sh.prototype = Object.assign(Object.create(Kl.prototype), { constructor: sh, isAmbientLight: !0 }), ch.prototype = Object.assign(Object.create(Kl.prototype), { constructor: ch, isRectAreaLight: !0, copy: function (t) { return Kl.prototype.copy.call(this, t), this.width = t.width, this.height = t.height, this }, toJSON: function (t) { var e = Kl.prototype.toJSON.call(this, t); return e.object.width = this.width, e.object.height = this.height, e } }), lh.prototype = Object.assign(Object.create(xl.prototype), { constructor: lh, load: function (t, e, r, n) { var i = this, o = new wl(i.manager); o.setPath(i.path), o.load(t, (function (t) { e(i.parse(JSON.parse(t))) }), r, n) }, parse: function (t) { var e = this.textures; function r(t) { return void 0 === e[t] && console.warn("THREE.MaterialLoader: Undefined texture", t), e[t] } var n = new tl[t.type]; if (void 0 !== t.uuid && (n.uuid = t.uuid), void 0 !== t.name && (n.name = t.name), void 0 !== t.color && n.color.setHex(t.color), void 0 !== t.roughness && (n.roughness = t.roughness), void 0 !== t.metalness && (n.metalness = t.metalness), void 0 !== t.sheen && (n.sheen = (new an).setHex(t.sheen)), void 0 !== t.emissive && n.emissive.setHex(t.emissive), void 0 !== t.specular && n.specular.setHex(t.specular), void 0 !== t.shininess && (n.shininess = t.shininess), void 0 !== t.clearcoat && (n.clearcoat = t.clearcoat), void 0 !== t.clearcoatRoughness && (n.clearcoatRoughness = t.clearcoatRoughness), void 0 !== t.vertexColors && (n.vertexColors = t.vertexColors), void 0 !== t.fog && (n.fog = t.fog), void 0 !== t.flatShading && (n.flatShading = t.flatShading), void 0 !== t.blending && (n.blending = t.blending), void 0 !== t.combine && (n.combine = t.combine), void 0 !== t.side && (n.side = t.side), void 0 !== t.opacity && (n.opacity = t.opacity), void 0 !== t.transparent && (n.transparent = t.transparent), void 0 !== t.alphaTest && (n.alphaTest = t.alphaTest), void 0 !== t.depthTest && (n.depthTest = t.depthTest), void 0 !== t.depthWrite && (n.depthWrite = t.depthWrite), void 0 !== t.colorWrite && (n.colorWrite = t.colorWrite), void 0 !== t.stencilWrite && (n.stencilWrite = t.stencilWrite), void 0 !== t.stencilWriteMask && (n.stencilWriteMask = t.stencilWriteMask), void 0 !== t.stencilFunc && (n.stencilFunc = t.stencilFunc), void 0 !== t.stencilRef && (n.stencilRef = t.stencilRef), void 0 !== t.stencilFuncMask && (n.stencilFuncMask = t.stencilFuncMask), void 0 !== t.stencilFail && (n.stencilFail = t.stencilFail), void 0 !== t.stencilZFail && (n.stencilZFail = t.stencilZFail), void 0 !== t.stencilZPass && (n.stencilZPass = t.stencilZPass), void 0 !== t.wireframe && (n.wireframe = t.wireframe), void 0 !== t.wireframeLinewidth && (n.wireframeLinewidth = t.wireframeLinewidth), void 0 !== t.wireframeLinecap && (n.wireframeLinecap = t.wireframeLinecap), void 0 !== t.wireframeLinejoin && (n.wireframeLinejoin = t.wireframeLinejoin), void 0 !== t.rotation && (n.rotation = t.rotation), 1 !== t.linewidth && (n.linewidth = t.linewidth), void 0 !== t.dashSize && (n.dashSize = t.dashSize), void 0 !== t.gapSize && (n.gapSize = t.gapSize), void 0 !== t.scale && (n.scale = t.scale), void 0 !== t.polygonOffset && (n.polygonOffset = t.polygonOffset), void 0 !== t.polygonOffsetFactor && (n.polygonOffsetFactor = t.polygonOffsetFactor), void 0 !== t.polygonOffsetUnits && (n.polygonOffsetUnits = t.polygonOffsetUnits), void 0 !== t.skinning && (n.skinning = t.skinning), void 0 !== t.morphTargets && (n.morphTargets = t.morphTargets), void 0 !== t.morphNormals && (n.morphNormals = t.morphNormals), void 0 !== t.dithering && (n.dithering = t.dithering), void 0 !== t.visible && (n.visible = t.visible), void 0 !== t.toneMapped && (n.toneMapped = t.toneMapped), void 0 !== t.userData && (n.userData = t.userData), void 0 !== t.uniforms) for (var i in t.uniforms) { var o = t.uniforms[i]; switch (n.uniforms[i] = {}, o.type) { case "t": n.uniforms[i].value = r(o.value); break; case "c": n.uniforms[i].value = (new an).setHex(o.value); break; case "v2": n.uniforms[i].value = (new Pe).fromArray(o.value); break; case "v3": n.uniforms[i].value = (new Ie).fromArray(o.value); break; case "v4": n.uniforms[i].value = (new ke).fromArray(o.value); break; case "m3": n.uniforms[i].value = (new ze).fromArray(o.value); case "m4": n.uniforms[i].value = (new Je).fromArray(o.value); break; default: n.uniforms[i].value = o.value } } if (void 0 !== t.defines && (n.defines = t.defines), void 0 !== t.vertexShader && (n.vertexShader = t.vertexShader), void 0 !== t.fragmentShader && (n.fragmentShader = t.fragmentShader), void 0 !== t.extensions) for (var a in t.extensions) n.extensions[a] = t.extensions[a]; if (void 0 !== t.shading && (n.flatShading = 1 === t.shading), void 0 !== t.size && (n.size = t.size), void 0 !== t.sizeAttenuation && (n.sizeAttenuation = t.sizeAttenuation), void 0 !== t.map && (n.map = r(t.map)), void 0 !== t.matcap && (n.matcap = r(t.matcap)), void 0 !== t.alphaMap && (n.alphaMap = r(t.alphaMap), n.transparent = !0), void 0 !== t.bumpMap && (n.bumpMap = r(t.bumpMap)), void 0 !== t.bumpScale && (n.bumpScale = t.bumpScale), void 0 !== t.normalMap && (n.normalMap = r(t.normalMap)), void 0 !== t.normalMapType && (n.normalMapType = t.normalMapType), void 0 !== t.normalScale) { var s = t.normalScale; !1 === Array.isArray(s) && (s = [s, s]), n.normalScale = (new Pe).fromArray(s) } return void 0 !== t.displacementMap && (n.displacementMap = r(t.displacementMap)), void 0 !== t.displacementScale && (n.displacementScale = t.displacementScale), void 0 !== t.displacementBias && (n.displacementBias = t.displacementBias), void 0 !== t.roughnessMap && (n.roughnessMap = r(t.roughnessMap)), void 0 !== t.metalnessMap && (n.metalnessMap = r(t.metalnessMap)), void 0 !== t.emissiveMap && (n.emissiveMap = r(t.emissiveMap)), void 0 !== t.emissiveIntensity && (n.emissiveIntensity = t.emissiveIntensity), void 0 !== t.specularMap && (n.specularMap = r(t.specularMap)), void 0 !== t.envMap && (n.envMap = r(t.envMap)), void 0 !== t.envMapIntensity && (n.envMapIntensity = t.envMapIntensity), void 0 !== t.reflectivity && (n.reflectivity = t.reflectivity), void 0 !== t.refractionRatio && (n.refractionRatio = t.refractionRatio), void 0 !== t.lightMap && (n.lightMap = r(t.lightMap)), void 0 !== t.lightMapIntensity && (n.lightMapIntensity = t.lightMapIntensity), void 0 !== t.aoMap && (n.aoMap = r(t.aoMap)), void 0 !== t.aoMapIntensity && (n.aoMapIntensity = t.aoMapIntensity), void 0 !== t.gradientMap && (n.gradientMap = r(t.gradientMap)), void 0 !== t.clearcoatNormalMap && (n.clearcoatNormalMap = r(t.clearcoatNormalMap)), void 0 !== t.clearcoatNormalScale && (n.clearcoatNormalScale = (new Pe).fromArray(t.clearcoatNormalScale)), n }, setTextures: function (t) { return this.textures = t, this } }); var hh = { decodeText: function (t) { if ("undefined" != typeof TextDecoder) return (new TextDecoder).decode(t); for (var e = "", r = 0, n = t.length; r < n; r++)e += String.fromCharCode(t[r]); try { return decodeURIComponent(escape(e)) } catch (t) { return e } }, extractUrlBase: function (t) { var e = t.lastIndexOf("/"); return -1 === e ? "./" : t.substr(0, e + 1) } }; function uh() { In.call(this), this.type = "InstancedBufferGeometry", this.maxInstancedCount = void 0 } function ph(t, e, r, n) { "number" == typeof r && (n = r, r = !1, console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.")), fn.call(this, t, e, r), this.meshPerAttribute = n || 1 } function dh(t) { xl.call(this, t) } uh.prototype = Object.assign(Object.create(In.prototype), { constructor: uh, isInstancedBufferGeometry: !0, copy: function (t) { return In.prototype.copy.call(this, t), this.maxInstancedCount = t.maxInstancedCount, this }, clone: function () { return (new this.constructor).copy(this) }, toJSON: function () { var t = In.prototype.toJSON.call(this); return t.maxInstancedCount = this.maxInstancedCount, t.isInstancedBufferGeometry = !0, t } }), ph.prototype = Object.assign(Object.create(fn.prototype), { constructor: ph, isInstancedBufferAttribute: !0, copy: function (t) { return fn.prototype.copy.call(this, t), this.meshPerAttribute = t.meshPerAttribute, this }, toJSON: function () { var t = fn.prototype.toJSON.call(this); return t.meshPerAttribute = this.meshPerAttribute, t.isInstancedBufferAttribute = !0, t } }), dh.prototype = Object.assign(Object.create(xl.prototype), { constructor: dh, load: function (t, e, r, n) { var i = this, o = new wl(i.manager); o.setPath(i.path), o.load(t, (function (t) { e(i.parse(JSON.parse(t))) }), r, n) }, parse: function (t) { var e = t.isInstancedBufferGeometry ? new uh : new In, r = t.data.index; if (void 0 !== r) { var n = new fh[r.type](r.array); e.setIndex(new fn(n, 1)) } var i = t.data.attributes; for (var o in i) { var a = i[o], s = (n = new fh[a.type](a.array), new (a.isInstancedBufferAttribute ? ph : fn)(n, a.itemSize, a.normalized)); void 0 !== a.name && (s.name = a.name), e.setAttribute(o, s) } var c = t.data.morphAttributes; if (c) for (var o in c) { for (var l = c[o], h = [], u = 0, p = l.length; u < p; u++) { a = l[u], s = new fn(n = new fh[a.type](a.array), a.itemSize, a.normalized); void 0 !== a.name && (s.name = a.name), h.push(s) } e.morphAttributes[o] = h } t.data.morphTargetsRelative && (e.morphTargetsRelative = !0); var d = t.data.groups || t.data.drawcalls || t.data.offsets; if (void 0 !== d) { u = 0; for (var f = d.length; u !== f; ++u) { var m = d[u]; e.addGroup(m.start, m.count, m.materialIndex) } } var v = t.data.boundingSphere; if (void 0 !== v) { var g = new Ie; void 0 !== v.center && g.fromArray(v.center), e.boundingSphere = new Or(g, v.radius) } return t.name && (e.name = t.name), t.userData && (e.userData = t.userData), e } }); var fh = { Int8Array: Int8Array, Uint8Array: Uint8Array, Uint8ClampedArray: "undefined" != typeof Uint8ClampedArray ? Uint8ClampedArray : Uint8Array, Int16Array: Int16Array, Uint16Array: Uint16Array, Int32Array: Int32Array, Uint32Array: Uint32Array, Float32Array: Float32Array, Float64Array: Float64Array }; function mh(t) { xl.call(this, t) } mh.prototype = Object.assign(Object.create(xl.prototype), { constructor: mh, load: function (t, e, r, n) { var i = this, o = "" === this.path ? hh.extractUrlBase(t) : this.path; this.resourcePath = this.resourcePath || o; var a = new wl(i.manager); a.setPath(this.path), a.load(t, (function (r) { var o = null; try { o = JSON.parse(r) } catch (e) { return void 0 !== n && n(e), void console.error("THREE:ObjectLoader: Can't parse " + t + ".", e.message) } var a = o.metadata; void 0 !== a && void 0 !== a.type && "geometry" !== a.type.toLowerCase() ? i.parse(o, e) : console.error("THREE.ObjectLoader: Can't load " + t) }), r, n) }, parse: function (t, e) { var r = this.parseShape(t.shapes), n = this.parseGeometries(t.geometries, r), i = this.parseImages(t.images, (function () { void 0 !== e && e(s) })), o = this.parseTextures(t.textures, i), a = this.parseMaterials(t.materials, o), s = this.parseObject(t.object, n, a); return t.animations && (s.animations = this.parseAnimations(t.animations)), void 0 !== t.images && 0 !== t.images.length || void 0 !== e && e(s), s }, parseShape: function (t) { var e = {}; if (void 0 !== t) for (var r = 0, n = t.length; r < n; r++) { var i = (new Jl).fromJSON(t[r]); e[i.uuid] = i } return e }, parseGeometries: function (t, e) { var r = {}; if (void 0 !== t) for (var n = new dh, i = 0, o = t.length; i < o; i++) { var a, s = t[i]; switch (s.type) { case "PlaneGeometry": case "PlaneBufferGeometry": a = new Vc[s.type](s.width, s.height, s.widthSegments, s.heightSegments); break; case "BoxGeometry": case "BoxBufferGeometry": case "CubeGeometry": a = new Vc[s.type](s.width, s.height, s.depth, s.widthSegments, s.heightSegments, s.depthSegments); break; case "CircleGeometry": case "CircleBufferGeometry": a = new Vc[s.type](s.radius, s.segments, s.thetaStart, s.thetaLength); break; case "CylinderGeometry": case "CylinderBufferGeometry": a = new Vc[s.type](s.radiusTop, s.radiusBottom, s.height, s.radialSegments, s.heightSegments, s.openEnded, s.thetaStart, s.thetaLength); break; case "ConeGeometry": case "ConeBufferGeometry": a = new Vc[s.type](s.radius, s.height, s.radialSegments, s.heightSegments, s.openEnded, s.thetaStart, s.thetaLength); break; case "SphereGeometry": case "SphereBufferGeometry": a = new Vc[s.type](s.radius, s.widthSegments, s.heightSegments, s.phiStart, s.phiLength, s.thetaStart, s.thetaLength); break; case "DodecahedronGeometry": case "DodecahedronBufferGeometry": case "IcosahedronGeometry": case "IcosahedronBufferGeometry": case "OctahedronGeometry": case "OctahedronBufferGeometry": case "TetrahedronGeometry": case "TetrahedronBufferGeometry": a = new Vc[s.type](s.radius, s.detail); break; case "RingGeometry": case "RingBufferGeometry": a = new Vc[s.type](s.innerRadius, s.outerRadius, s.thetaSegments, s.phiSegments, s.thetaStart, s.thetaLength); break; case "TorusGeometry": case "TorusBufferGeometry": a = new Vc[s.type](s.radius, s.tube, s.radialSegments, s.tubularSegments, s.arc); break; case "TorusKnotGeometry": case "TorusKnotBufferGeometry": a = new Vc[s.type](s.radius, s.tube, s.tubularSegments, s.radialSegments, s.p, s.q); break; case "TubeGeometry": case "TubeBufferGeometry": a = new Vc[s.type]((new Xl[s.path.type]).fromJSON(s.path), s.tubularSegments, s.radius, s.radialSegments, s.closed); break; case "LatheGeometry": case "LatheBufferGeometry": a = new Vc[s.type](s.points, s.segments, s.phiStart, s.phiLength); break; case "PolyhedronGeometry": case "PolyhedronBufferGeometry": a = new Vc[s.type](s.vertices, s.indices, s.radius, s.details); break; case "ShapeGeometry": case "ShapeBufferGeometry": for (var c = [], l = 0, h = s.shapes.length; l < h; l++) { var u = e[s.shapes[l]]; c.push(u) } a = new Vc[s.type](c, s.curveSegments); break; case "ExtrudeGeometry": case "ExtrudeBufferGeometry": for (c = [], l = 0, h = s.shapes.length; l < h; l++) { u = e[s.shapes[l]]; c.push(u) } var p = s.options.extrudePath; void 0 !== p && (s.options.extrudePath = (new Xl[p.type]).fromJSON(p)), a = new Vc[s.type](c, s.options); break; case "BufferGeometry": case "InstancedBufferGeometry": a = n.parse(s); break; case "Geometry": if ("THREE" in window && "LegacyJSONLoader" in THREE) a = (new THREE.LegacyJSONLoader).parse(s, this.resourcePath).geometry; else console.error('THREE.ObjectLoader: You have to import LegacyJSONLoader in order load geometry data of type "Geometry".'); break; default: console.warn('THREE.ObjectLoader: Unsupported geometry type "' + s.type + '"'); continue }a.uuid = s.uuid, void 0 !== s.name && (a.name = s.name), !0 === a.isBufferGeometry && void 0 !== s.userData && (a.userData = s.userData), r[s.uuid] = a } return r }, parseMaterials: function (t, e) { var r = {}, n = {}; if (void 0 !== t) { var i = new lh; i.setTextures(e); for (var o = 0, a = t.length; o < a; o++) { var s = t[o]; if ("MultiMaterial" === s.type) { for (var c = [], l = 0; l < s.materials.length; l++) { var h = s.materials[l]; void 0 === r[h.uuid] && (r[h.uuid] = i.parse(h)), c.push(r[h.uuid]) } n[s.uuid] = c } else void 0 === r[s.uuid] && (r[s.uuid] = i.parse(s)), n[s.uuid] = r[s.uuid] } } return n }, parseAnimations: function (t) { for (var e = [], r = 0; r < t.length; r++) { var n = t[r], i = fl.parse(n); void 0 !== n.uuid && (i.uuid = n.uuid), e.push(i) } return e }, parseImages: function (t, e) { var r = this, n = {}; function i(t) { return r.manager.itemStart(t), o.load(t, (function () { r.manager.itemEnd(t) }), void 0, (function () { r.manager.itemError(t), r.manager.itemEnd(t) })) } if (void 0 !== t && t.length > 0) { var o = new Tl(new gl(e)); o.setCrossOrigin(this.crossOrigin); for (var a = 0, s = t.length; a < s; a++) { var c = t[a], l = c.url; if (Array.isArray(l)) { n[c.uuid] = []; for (var h = 0, u = l.length; h < u; h++) { var p = l[h], d = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(p) ? p : r.resourcePath + p; n[c.uuid].push(i(d)) } } else { d = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(c.url) ? c.url : r.resourcePath + c.url; n[c.uuid] = i(d) } } } return n }, parseTextures: function (t, e) { function r(t, e) { return "number" == typeof t ? t : (console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", t), e[t]) } var n = {}; if (void 0 !== t) for (var i = 0, o = t.length; i < o; i++) { var a, s = t[i]; void 0 === s.image && console.warn('THREE.ObjectLoader: No "image" specified for', s.uuid), void 0 === e[s.image] && console.warn("THREE.ObjectLoader: Undefined image", s.image), (a = Array.isArray(e[s.image]) ? new Bi(e[s.image]) : new Be(e[s.image])).needsUpdate = !0, a.uuid = s.uuid, void 0 !== s.name && (a.name = s.name), void 0 !== s.mapping && (a.mapping = r(s.mapping, gh)), void 0 !== s.offset && a.offset.fromArray(s.offset), void 0 !== s.repeat && a.repeat.fromArray(s.repeat), void 0 !== s.center && a.center.fromArray(s.center), void 0 !== s.rotation && (a.rotation = s.rotation), void 0 !== s.wrap && (a.wrapS = r(s.wrap[0], yh), a.wrapT = r(s.wrap[1], yh)), void 0 !== s.format && (a.format = s.format), void 0 !== s.type && (a.type = s.type), void 0 !== s.encoding && (a.encoding = s.encoding), void 0 !== s.minFilter && (a.minFilter = r(s.minFilter, xh)), void 0 !== s.magFilter && (a.magFilter = r(s.magFilter, xh)), void 0 !== s.anisotropy && (a.anisotropy = s.anisotropy), void 0 !== s.flipY && (a.flipY = s.flipY), void 0 !== s.premultiplyAlpha && (a.premultiplyAlpha = s.premultiplyAlpha), void 0 !== s.unpackAlignment && (a.unpackAlignment = s.unpackAlignment), n[s.uuid] = a } return n }, parseObject: function (t, e, r) { var n; function i(t) { return void 0 === e[t] && console.warn("THREE.ObjectLoader: Undefined geometry", t), e[t] } function o(t) { if (void 0 !== t) { if (Array.isArray(t)) { for (var e = [], n = 0, i = t.length; n < i; n++) { var o = t[n]; void 0 === r[o] && console.warn("THREE.ObjectLoader: Undefined material", o), e.push(r[o]) } return e } return void 0 === r[t] && console.warn("THREE.ObjectLoader: Undefined material", t), r[t] } } switch (t.type) { case "Scene": n = new mr, void 0 !== t.background && Number.isInteger(t.background) && (n.background = new an(t.background)), void 0 !== t.fog && ("Fog" === t.fog.type ? n.fog = new Oa(t.fog.color, t.fog.near, t.fog.far) : "FogExp2" === t.fog.type && (n.fog = new Ca(t.fog.color, t.fog.density))); break; case "PerspectiveCamera": n = new pi(t.fov, t.aspect, t.near, t.far), void 0 !== t.focus && (n.focus = t.focus), void 0 !== t.zoom && (n.zoom = t.zoom), void 0 !== t.filmGauge && (n.filmGauge = t.filmGauge), void 0 !== t.filmOffset && (n.filmOffset = t.filmOffset), void 0 !== t.view && (n.view = Object.assign({}, t.view)); break; case "OrthographicCamera": n = new ih(t.left, t.right, t.top, t.bottom, t.near, t.far), void 0 !== t.zoom && (n.zoom = t.zoom), void 0 !== t.view && (n.view = Object.assign({}, t.view)); break; case "AmbientLight": n = new sh(t.color, t.intensity); break; case "DirectionalLight": n = new ah(t.color, t.intensity); break; case "PointLight": n = new nh(t.color, t.intensity, t.distance, t.decay); break; case "RectAreaLight": n = new ch(t.color, t.intensity, t.width, t.height); break; case "SpotLight": n = new eh(t.color, t.intensity, t.distance, t.angle, t.penumbra, t.decay); break; case "HemisphereLight": n = new Ql(t.color, t.groundColor, t.intensity); break; case "SkinnedMesh": console.warn("THREE.ObjectLoader.parseObject() does not support SkinnedMesh yet."); case "Mesh": var a = i(t.geometry), s = o(t.material); n = a.bones && a.bones.length > 0 ? new $a(a, s) : new Kn(a, s); break; case "InstancedMesh": a = i(t.geometry), s = o(t.material); var c = t.count, l = t.instanceMatrix; (n = new cs(a, s, c)).instanceMatrix = new fn(new Float32Array(l.array), 16); break; case "LOD": n = new Qa; break; case "Line": n = new ms(i(t.geometry), o(t.material), t.mode); break; case "LineLoop": n = new xs(i(t.geometry), o(t.material)); break; case "LineSegments": n = new ys(i(t.geometry), o(t.material)); break; case "PointCloud": case "Points": n = new Ts(i(t.geometry), o(t.material)); break; case "Sprite": n = new Ya(o(t.material)); break; case "Group": n = new _a; break; default: n = new fr }if (n.uuid = t.uuid, void 0 !== t.name && (n.name = t.name), void 0 !== t.matrix ? (n.matrix.fromArray(t.matrix), void 0 !== t.matrixAutoUpdate && (n.matrixAutoUpdate = t.matrixAutoUpdate), n.matrixAutoUpdate && n.matrix.decompose(n.position, n.quaternion, n.scale)) : (void 0 !== t.position && n.position.fromArray(t.position), void 0 !== t.rotation && n.rotation.fromArray(t.rotation), void 0 !== t.quaternion && n.quaternion.fromArray(t.quaternion), void 0 !== t.scale && n.scale.fromArray(t.scale)), void 0 !== t.castShadow && (n.castShadow = t.castShadow), void 0 !== t.receiveShadow && (n.receiveShadow = t.receiveShadow), t.shadow && (void 0 !== t.shadow.bias && (n.shadow.bias = t.shadow.bias), void 0 !== t.shadow.radius && (n.shadow.radius = t.shadow.radius), void 0 !== t.shadow.mapSize && n.shadow.mapSize.fromArray(t.shadow.mapSize), void 0 !== t.shadow.camera && (n.shadow.camera = this.parseObject(t.shadow.camera))), void 0 !== t.visible && (n.visible = t.visible), void 0 !== t.frustumCulled && (n.frustumCulled = t.frustumCulled), void 0 !== t.renderOrder && (n.renderOrder = t.renderOrder), void 0 !== t.userData && (n.userData = t.userData), void 0 !== t.layers && (n.layers.mask = t.layers), void 0 !== t.drawMode && n.setDrawMode(t.drawMode), void 0 !== t.children) for (var h = t.children, u = 0; u < h.length; u++)n.add(this.parseObject(h[u], e, r)); if ("LOD" === t.type) { void 0 !== t.autoUpdate && (n.autoUpdate = t.autoUpdate); for (var p = t.levels, d = 0; d < p.length; d++) { var f = p[d], m = n.getObjectByProperty("uuid", f.object); void 0 !== m && n.addLevel(m, f.distance) } } return n } }); var vh, gh = { UVMapping: 300, CubeReflectionMapping: tt, CubeRefractionMapping: et, EquirectangularReflectionMapping: rt, EquirectangularRefractionMapping: nt, SphericalReflectionMapping: it, CubeUVReflectionMapping: ot, CubeUVRefractionMapping: at }, yh = { RepeatWrapping: st, ClampToEdgeWrapping: ct, MirroredRepeatWrapping: lt }, xh = { NearestFilter: ht, NearestMipmapNearestFilter: ut, NearestMipmapLinearFilter: pt, LinearFilter: dt, LinearMipmapNearestFilter: ft, LinearMipmapLinearFilter: mt }; function bh(t) { "undefined" == typeof createImageBitmap && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), "undefined" == typeof fetch && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), xl.call(this, t), this.options = void 0 } function wh() { this.type = "ShapePath", this.color = new an, this.subPaths = [], this.currentPath = null } function _h(t) { this.type = "Font", this.data = t } function Mh(t, e, r, n, i) { var o = i.glyphs[t] || i.glyphs["?"]; if (o) { var a, s, c, l, h, u, p, d, f = new wh; if (o.o) for (var m = o._cachedOutline || (o._cachedOutline = o.o.split(" ")), v = 0, g = m.length; v < g;) { switch (m[v++]) { case "m": a = m[v++] * e + r, s = m[v++] * e + n, f.moveTo(a, s); break; case "l": a = m[v++] * e + r, s = m[v++] * e + n, f.lineTo(a, s); break; case "q": c = m[v++] * e + r, l = m[v++] * e + n, h = m[v++] * e + r, u = m[v++] * e + n, f.quadraticCurveTo(h, u, c, l); break; case "b": c = m[v++] * e + r, l = m[v++] * e + n, h = m[v++] * e + r, u = m[v++] * e + n, p = m[v++] * e + r, d = m[v++] * e + n, f.bezierCurveTo(h, u, p, d, c, l) } } return { offsetX: o.ha * e, path: f } } console.error('THREE.Font: character "' + t + '" does not exists in font family ' + i.familyName + ".") } function Sh(t) { xl.call(this, t) } bh.prototype = Object.assign(Object.create(xl.prototype), { constructor: bh, setOptions: function (t) { return this.options = t, this }, load: function (t, e, r, n) { void 0 === t && (t = ""), void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t); var i = this, o = vl.get(t); if (void 0 !== o) return i.manager.itemStart(t), setTimeout((function () { e && e(o), i.manager.itemEnd(t) }), 0), o; fetch(t).then((function (t) { return t.blob() })).then((function (t) { return void 0 === i.options ? createImageBitmap(t) : createImageBitmap(t, i.options) })).then((function (r) { vl.add(t, r), e && e(r), i.manager.itemEnd(t) })).catch((function (e) { n && n(e), i.manager.itemError(t), i.manager.itemEnd(t) })), i.manager.itemStart(t) } }), Object.assign(wh.prototype, { moveTo: function (t, e) { return this.currentPath = new Zl, this.subPaths.push(this.currentPath), this.currentPath.moveTo(t, e), this }, lineTo: function (t, e) { return this.currentPath.lineTo(t, e), this }, quadraticCurveTo: function (t, e, r, n) { return this.currentPath.quadraticCurveTo(t, e, r, n), this }, bezierCurveTo: function (t, e, r, n, i, o) { return this.currentPath.bezierCurveTo(t, e, r, n, i, o), this }, splineThru: function (t) { return this.currentPath.splineThru(t), this }, toShapes: function (t, e) { function r(t) { for (var e = [], r = 0, n = t.length; r < n; r++) { var i = t[r], o = new Jl; o.curves = i.curves, e.push(o) } return e } function n(t, e) { for (var r = e.length, n = !1, i = r - 1, o = 0; o < r; i = o++) { var a = e[i], s = e[o], c = s.x - a.x, l = s.y - a.y; if (Math.abs(l) > Number.EPSILON) { if (l < 0 && (a = e[o], c = -c, s = e[i], l = -l), t.y < a.y || t.y > s.y) continue; if (t.y === a.y) { if (t.x === a.x) return !0 } else { var h = l * (t.x - a.x) - c * (t.y - a.y); if (0 === h) return !0; if (h < 0) continue; n = !n } } else { if (t.y !== a.y) continue; if (s.x <= t.x && t.x <= a.x || a.x <= t.x && t.x <= s.x) return !0 } } return n } var i = yc.isClockWise, o = this.subPaths; if (0 === o.length) return []; if (!0 === e) return r(o); var a, s, c, l = []; if (1 === o.length) return s = o[0], (c = new Jl).curves = s.curves, l.push(c), l; var h = !i(o[0].getPoints()); h = t ? !h : h; var u, p, d = [], f = [], m = [], v = 0; f[v] = void 0, m[v] = []; for (var g = 0, y = o.length; g < y; g++)a = i(u = (s = o[g]).getPoints()), (a = t ? !a : a) ? (!h && f[v] && v++, f[v] = { s: new Jl, p: u }, f[v].s.curves = s.curves, h && v++, m[v] = []) : m[v].push({ h: s, p: u[0] }); if (!f[0]) return r(o); if (f.length > 1) { for (var x = !1, b = [], w = 0, _ = f.length; w < _; w++)d[w] = []; for (w = 0, _ = f.length; w < _; w++)for (var M = m[w], S = 0; S < M.length; S++) { for (var T = M[S], E = !0, A = 0; A < f.length; A++)n(T.p, f[A].p) && (w !== A && b.push({ froms: w, tos: A, hole: S }), E ? (E = !1, d[A].push(T)) : x = !0); E && d[w].push(T) } b.length > 0 && (x || (m = d)) } g = 0; for (var L = f.length; g < L; g++) { c = f[g].s, l.push(c); for (var P = 0, R = (p = m[g]).length; P < R; P++)c.holes.push(p[P].h) } return l } }), Object.assign(_h.prototype, { isFont: !0, generateShapes: function (t, e) { void 0 === e && (e = 100); for (var r = [], n = function (t, e, r) { for (var n = Array.from ? Array.from(t) : String(t).split(""), i = e / r.resolution, o = (r.boundingBox.yMax - r.boundingBox.yMin + r.underlineThickness) * i, a = [], s = 0, c = 0, l = 0; l < n.length; l++) { var h = n[l]; if ("\n" === h) s = 0, c -= o; else { var u = Mh(h, i, s, c, r); s += u.offsetX, a.push(u.path) } } return a }(t, e, this.data), i = 0, o = n.length; i < o; i++)Array.prototype.push.apply(r, n[i].toShapes()); return r } }), Sh.prototype = Object.assign(Object.create(xl.prototype), { constructor: Sh, load: function (t, e, r, n) { var i = this, o = new wl(this.manager); o.setPath(this.path), o.load(t, (function (t) { var r; try { r = JSON.parse(t) } catch (e) { console.warn("THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead."), r = JSON.parse(t.substring(65, t.length - 2)) } var n = i.parse(r); e && e(n) }), r, n) }, parse: function (t) { return new _h(t) } }); var Th = { getContext: function () { return void 0 === vh && (vh = new (window.AudioContext || window.webkitAudioContext)), vh }, setContext: function (t) { vh = t } }; function Eh(t) { xl.call(this, t) } function Ah() { this.coefficients = []; for (var t = 0; t < 9; t++)this.coefficients.push(new Ie) } function Lh(t, e) { Kl.call(this, void 0, e), this.sh = void 0 !== t ? t : new Ah } function Ph(t, e, r) { Lh.call(this, void 0, r); var n = (new an).set(t), i = (new an).set(e), o = new Ie(n.r, n.g, n.b), a = new Ie(i.r, i.g, i.b), s = Math.sqrt(Math.PI), c = s * Math.sqrt(.75); this.sh.coefficients[0].copy(o).add(a).multiplyScalar(s), this.sh.coefficients[1].copy(o).sub(a).multiplyScalar(c) } function Rh(t, e) { Lh.call(this, void 0, e); var r = (new an).set(t); this.sh.coefficients[0].set(r.r, r.g, r.b).multiplyScalar(2 * Math.sqrt(Math.PI)) } Eh.prototype = Object.assign(Object.create(xl.prototype), { constructor: Eh, load: function (t, e, r, n) { var i = new wl(this.manager); i.setResponseType("arraybuffer"), i.setPath(this.path), i.load(t, (function (t) { var r = t.slice(0); Th.getContext().decodeAudioData(r, (function (t) { e(t) })) }), r, n) } }), Object.assign(Ah.prototype, { isSphericalHarmonics3: !0, set: function (t) { for (var e = 0; e < 9; e++)this.coefficients[e].copy(t[e]); return this }, zero: function () { for (var t = 0; t < 9; t++)this.coefficients[t].set(0, 0, 0); return this }, getAt: function (t, e) { var r = t.x, n = t.y, i = t.z, o = this.coefficients; return e.copy(o[0]).multiplyScalar(.282095), e.addScale(o[1], .488603 * n), e.addScale(o[2], .488603 * i), e.addScale(o[3], .488603 * r), e.addScale(o[4], r * n * 1.092548), e.addScale(o[5], n * i * 1.092548), e.addScale(o[6], .315392 * (3 * i * i - 1)), e.addScale(o[7], r * i * 1.092548), e.addScale(o[8], .546274 * (r * r - n * n)), e }, getIrradianceAt: function (t, e) { var r = t.x, n = t.y, i = t.z, o = this.coefficients; return e.copy(o[0]).multiplyScalar(.886227), e.addScale(o[1], 1.023328 * n), e.addScale(o[2], 1.023328 * i), e.addScale(o[3], 1.023328 * r), e.addScale(o[4], .858086 * r * n), e.addScale(o[5], .858086 * n * i), e.addScale(o[6], .743125 * i * i - .247708), e.addScale(o[7], .858086 * r * i), e.addScale(o[8], .429043 * (r * r - n * n)), e }, add: function (t) { for (var e = 0; e < 9; e++)this.coefficients[e].add(t.coefficients[e]); return this }, scale: function (t) { for (var e = 0; e < 9; e++)this.coefficients[e].multiplyScalar(t); return this }, lerp: function (t, e) { for (var r = 0; r < 9; r++)this.coefficients[r].lerp(t.coefficients[r], e); return this }, equals: function (t) { for (var e = 0; e < 9; e++)if (!this.coefficients[e].equals(t.coefficients[e])) return !1; return !0 }, copy: function (t) { return this.set(t.coefficients) }, clone: function () { return (new this.constructor).copy(this) }, fromArray: function (t, e) { void 0 === e && (e = 0); for (var r = this.coefficients, n = 0; n < 9; n++)r[n].fromArray(t, e + 3 * n); return this }, toArray: function (t, e) { void 0 === t && (t = []), void 0 === e && (e = 0); for (var r = this.coefficients, n = 0; n < 9; n++)r[n].toArray(t, e + 3 * n); return t } }), Object.assign(Ah, { getBasisAt: function (t, e) { var r = t.x, n = t.y, i = t.z; e[0] = .282095, e[1] = .488603 * n, e[2] = .488603 * i, e[3] = .488603 * r, e[4] = 1.092548 * r * n, e[5] = 1.092548 * n * i, e[6] = .315392 * (3 * i * i - 1), e[7] = 1.092548 * r * i, e[8] = .546274 * (r * r - n * n) } }), Lh.prototype = Object.assign(Object.create(Kl.prototype), { constructor: Lh, isLightProbe: !0, copy: function (t) { return Kl.prototype.copy.call(this, t), this.sh.copy(t.sh), this.intensity = t.intensity, this }, toJSON: function (t) { return Kl.prototype.toJSON.call(this, t) } }), Ph.prototype = Object.assign(Object.create(Lh.prototype), { constructor: Ph, isHemisphereLightProbe: !0, copy: function (t) { return Lh.prototype.copy.call(this, t), this }, toJSON: function (t) { return Lh.prototype.toJSON.call(this, t) } }), Rh.prototype = Object.assign(Object.create(Lh.prototype), { constructor: Rh, isAmbientLightProbe: !0, copy: function (t) { return Lh.prototype.copy.call(this, t), this }, toJSON: function (t) { return Lh.prototype.toJSON.call(this, t) } }); var Ch = new Je, Oh = new Je; function Ih(t) { this.autoStart = void 0 === t || t, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = !1 } Object.assign(function () { this.type = "StereoCamera", this.aspect = 1, this.eyeSep = .064, this.cameraL = new pi, this.cameraL.layers.enable(1), this.cameraL.matrixAutoUpdate = !1, this.cameraR = new pi, this.cameraR.layers.enable(2), this.cameraR.matrixAutoUpdate = !1, this._cache = { focus: null, fov: null, aspect: null, near: null, far: null, zoom: null, eyeSep: null } }.prototype, { update: function (t) { var e = this._cache; if (e.focus !== t.focus || e.fov !== t.fov || e.aspect !== t.aspect * this.aspect || e.near !== t.near || e.far !== t.far || e.zoom !== t.zoom || e.eyeSep !== this.eyeSep) { e.focus = t.focus, e.fov = t.fov, e.aspect = t.aspect * this.aspect, e.near = t.near, e.far = t.far, e.zoom = t.zoom, e.eyeSep = this.eyeSep; var r, n, i = t.projectionMatrix.clone(), o = e.eyeSep / 2, a = o * e.near / e.focus, s = e.near * Math.tan(Le.DEG2RAD * e.fov * .5) / e.zoom; Oh.elements[12] = -o, Ch.elements[12] = o, r = -s * e.aspect + a, n = s * e.aspect + a, i.elements[0] = 2 * e.near / (n - r), i.elements[8] = (n + r) / (n - r), this.cameraL.projectionMatrix.copy(i), r = -s * e.aspect - a, n = s * e.aspect - a, i.elements[0] = 2 * e.near / (n - r), i.elements[8] = (n + r) / (n - r), this.cameraR.projectionMatrix.copy(i) } this.cameraL.matrixWorld.copy(t.matrixWorld).multiply(Oh), this.cameraR.matrixWorld.copy(t.matrixWorld).multiply(Ch) } }), Object.assign(Ih.prototype, { start: function () { this.startTime = ("undefined" == typeof performance ? Date : performance).now(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = !0 }, stop: function () { this.getElapsedTime(), this.running = !1, this.autoStart = !1 }, getElapsedTime: function () { return this.getDelta(), this.elapsedTime }, getDelta: function () { var t = 0; if (this.autoStart && !this.running) return this.start(), 0; if (this.running) { var e = ("undefined" == typeof performance ? Date : performance).now(); t = (e - this.oldTime) / 1e3, this.oldTime = e, this.elapsedTime += t } return t } }); var Nh = new Ie, Dh = new Re, zh = new Ie, Fh = new Ie; function Uh() { fr.call(this), this.type = "AudioListener", this.context = Th.getContext(), this.gain = this.context.createGain(), this.gain.connect(this.context.destination), this.filter = null, this.timeDelta = 0, this._clock = new Ih } function Bh(t) { fr.call(this), this.type = "Audio", this.listener = t, this.context = t.context, this.gain = this.context.createGain(), this.gain.connect(t.getInput()), this.autoplay = !1, this.buffer = null, this.detune = 0, this.loop = !1, this.loopStart = 0, this.loopEnd = 0, this.offset = 0, this.duration = void 0, this.playbackRate = 1, this.isPlaying = !1, this.hasPlaybackControl = !0, this.sourceType = "empty", this._startedAt = 0, this._pausedAt = 0, this.filters = [] } Uh.prototype = Object.assign(Object.create(fr.prototype), { constructor: Uh, getInput: function () { return this.gain }, removeFilter: function () { return null !== this.filter && (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination), this.gain.connect(this.context.destination), this.filter = null), this }, getFilter: function () { return this.filter }, setFilter: function (t) { return null !== this.filter ? (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination), this.filter = t, this.gain.connect(this.filter), this.filter.connect(this.context.destination), this }, getMasterVolume: function () { return this.gain.gain.value }, setMasterVolume: function (t) { return this.gain.gain.setTargetAtTime(t, this.context.currentTime, .01), this }, updateMatrixWorld: function (t) { fr.prototype.updateMatrixWorld.call(this, t); var e = this.context.listener, r = this.up; if (this.timeDelta = this._clock.getDelta(), this.matrixWorld.decompose(Nh, Dh, zh), Fh.set(0, 0, -1).applyQuaternion(Dh), e.positionX) { var n = this.context.currentTime + this.timeDelta; e.positionX.linearRampToValueAtTime(Nh.x, n), e.positionY.linearRampToValueAtTime(Nh.y, n), e.positionZ.linearRampToValueAtTime(Nh.z, n), e.forwardX.linearRampToValueAtTime(Fh.x, n), e.forwardY.linearRampToValueAtTime(Fh.y, n), e.forwardZ.linearRampToValueAtTime(Fh.z, n), e.upX.linearRampToValueAtTime(r.x, n), e.upY.linearRampToValueAtTime(r.y, n), e.upZ.linearRampToValueAtTime(r.z, n) } else e.setPosition(Nh.x, Nh.y, Nh.z), e.setOrientation(Fh.x, Fh.y, Fh.z, r.x, r.y, r.z) } }), Bh.prototype = Object.assign(Object.create(fr.prototype), { constructor: Bh, getOutput: function () { return this.gain }, setNodeSource: function (t) { return this.hasPlaybackControl = !1, this.sourceType = "audioNode", this.source = t, this.connect(), this }, setMediaElementSource: function (t) { return this.hasPlaybackControl = !1, this.sourceType = "mediaNode", this.source = this.context.createMediaElementSource(t), this.connect(), this }, setMediaStreamSource: function (t) { return this.hasPlaybackControl = !1, this.sourceType = "mediaStreamNode", this.source = this.context.createMediaStreamSource(t), this.connect(), this }, setBuffer: function (t) { return this.buffer = t, this.sourceType = "buffer", this.autoplay && this.play(), this }, play: function (t) { if (void 0 === t && (t = 0), !0 !== this.isPlaying) { if (!1 !== this.hasPlaybackControl) { this._startedAt = this.context.currentTime + t; var e = this.context.createBufferSource(); return e.buffer = this.buffer, e.loop = this.loop, e.loopStart = this.loopStart, e.loopEnd = this.loopEnd, e.onended = this.onEnded.bind(this), e.start(this._startedAt, this._pausedAt + this.offset, this.duration), this.isPlaying = !0, this.source = e, this.setDetune(this.detune), this.setPlaybackRate(this.playbackRate), this.connect() } console.warn("THREE.Audio: this Audio has no playback control.") } else console.warn("THREE.Audio: Audio is already playing.") }, pause: function () { if (!1 !== this.hasPlaybackControl) return !0 === this.isPlaying && (this._pausedAt = (this.context.currentTime - this._startedAt) * this.playbackRate, this.source.stop(), this.source.onended = null, this.isPlaying = !1), this; console.warn("THREE.Audio: this Audio has no playback control.") }, stop: function () { if (!1 !== this.hasPlaybackControl) return this._pausedAt = 0, this.source.stop(), this.source.onended = null, this.isPlaying = !1, this; console.warn("THREE.Audio: this Audio has no playback control.") }, connect: function () { if (this.filters.length > 0) { this.source.connect(this.filters[0]); for (var t = 1, e = this.filters.length; t < e; t++)this.filters[t - 1].connect(this.filters[t]); this.filters[this.filters.length - 1].connect(this.getOutput()) } else this.source.connect(this.getOutput()); return this }, disconnect: function () { if (this.filters.length > 0) { this.source.disconnect(this.filters[0]); for (var t = 1, e = this.filters.length; t < e; t++)this.filters[t - 1].disconnect(this.filters[t]); this.filters[this.filters.length - 1].disconnect(this.getOutput()) } else this.source.disconnect(this.getOutput()); return this }, getFilters: function () { return this.filters }, setFilters: function (t) { return t || (t = []), !0 === this.isPlaying ? (this.disconnect(), this.filters = t, this.connect()) : this.filters = t, this }, setDetune: function (t) { if (this.detune = t, void 0 !== this.source.detune) return !0 === this.isPlaying && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, .01), this }, getDetune: function () { return this.detune }, getFilter: function () { return this.getFilters()[0] }, setFilter: function (t) { return this.setFilters(t ? [t] : []) }, setPlaybackRate: function (t) { if (!1 !== this.hasPlaybackControl) return this.playbackRate = t, !0 === this.isPlaying && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, .01), this; console.warn("THREE.Audio: this Audio has no playback control.") }, getPlaybackRate: function () { return this.playbackRate }, onEnded: function () { this.isPlaying = !1 }, getLoop: function () { return !1 === this.hasPlaybackControl ? (console.warn("THREE.Audio: this Audio has no playback control."), !1) : this.loop }, setLoop: function (t) { if (!1 !== this.hasPlaybackControl) return this.loop = t, !0 === this.isPlaying && (this.source.loop = this.loop), this; console.warn("THREE.Audio: this Audio has no playback control.") }, setLoopStart: function (t) { return this.loopStart = t, this }, setLoopEnd: function (t) { return this.loopEnd = t, this }, getVolume: function () { return this.gain.gain.value }, setVolume: function (t) { return this.gain.gain.setTargetAtTime(t, this.context.currentTime, .01), this } }); var kh = new Ie, jh = new Re, Gh = new Ie, Vh = new Ie; function Hh(t) { Bh.call(this, t), this.panner = this.context.createPanner(), this.panner.panningModel = "HRTF", this.panner.connect(this.gain) } function Wh(t, e) { this.analyser = t.context.createAnalyser(), this.analyser.fftSize = void 0 !== e ? e : 2048, this.data = new Uint8Array(this.analyser.frequencyBinCount), t.getOutput().connect(this.analyser) } function qh(t, e, r) { this.binding = t, this.valueSize = r; var n, i = Float64Array; switch (e) { case "quaternion": n = this._slerp; break; case "string": case "bool": i = Array, n = this._select; break; default: n = this._lerp }this.buffer = new i(4 * r), this._mixBufferRegion = n, this.cumulativeWeight = 0, this.useCount = 0, this.referenceCount = 0 } Hh.prototype = Object.assign(Object.create(Bh.prototype), { constructor: Hh, getOutput: function () { return this.panner }, getRefDistance: function () { return this.panner.refDistance }, setRefDistance: function (t) { return this.panner.refDistance = t, this }, getRolloffFactor: function () { return this.panner.rolloffFactor }, setRolloffFactor: function (t) { return this.panner.rolloffFactor = t, this }, getDistanceModel: function () { return this.panner.distanceModel }, setDistanceModel: function (t) { return this.panner.distanceModel = t, this }, getMaxDistance: function () { return this.panner.maxDistance }, setMaxDistance: function (t) { return this.panner.maxDistance = t, this }, setDirectionalCone: function (t, e, r) { return this.panner.coneInnerAngle = t, this.panner.coneOuterAngle = e, this.panner.coneOuterGain = r, this }, updateMatrixWorld: function (t) { if (fr.prototype.updateMatrixWorld.call(this, t), !0 !== this.hasPlaybackControl || !1 !== this.isPlaying) { this.matrixWorld.decompose(kh, jh, Gh), Vh.set(0, 0, 1).applyQuaternion(jh); var e = this.panner; if (e.positionX) { var r = this.context.currentTime + this.listener.timeDelta; e.positionX.linearRampToValueAtTime(kh.x, r), e.positionY.linearRampToValueAtTime(kh.y, r), e.positionZ.linearRampToValueAtTime(kh.z, r), e.orientationX.linearRampToValueAtTime(Vh.x, r), e.orientationY.linearRampToValueAtTime(Vh.y, r), e.orientationZ.linearRampToValueAtTime(Vh.z, r) } else e.setPosition(kh.x, kh.y, kh.z), e.setOrientation(Vh.x, Vh.y, Vh.z) } } }), Object.assign(Wh.prototype, { getFrequencyData: function () { return this.analyser.getByteFrequencyData(this.data), this.data }, getAverageFrequency: function () { for (var t = 0, e = this.getFrequencyData(), r = 0; r < e.length; r++)t += e[r]; return t / e.length } }), Object.assign(qh.prototype, { accumulate: function (t, e) { var r = this.buffer, n = this.valueSize, i = t * n + n, o = this.cumulativeWeight; if (0 === o) { for (var a = 0; a !== n; ++a)r[i + a] = r[a]; o = e } else { var s = e / (o += e); this._mixBufferRegion(r, i, 0, s, n) } this.cumulativeWeight = o }, apply: function (t) { var e = this.valueSize, r = this.buffer, n = t * e + e, i = this.cumulativeWeight, o = this.binding; if (this.cumulativeWeight = 0, i < 1) { var a = 3 * e; this._mixBufferRegion(r, n, a, 1 - i, e) } for (var s = e, c = e + e; s !== c; ++s)if (r[s] !== r[s + e]) { o.setValue(r, n); break } }, saveOriginalState: function () { var t = this.binding, e = this.buffer, r = this.valueSize, n = 3 * r; t.getValue(e, n); for (var i = r, o = n; i !== o; ++i)e[i] = e[n + i % r]; this.cumulativeWeight = 0 }, restoreOriginalState: function () { var t = 3 * this.valueSize; this.binding.setValue(this.buffer, t) }, _select: function (t, e, r, n, i) { if (n >= .5) for (var o = 0; o !== i; ++o)t[e + o] = t[r + o] }, _slerp: function (t, e, r, n) { Re.slerpFlat(t, e, t, e, t, r, n) }, _lerp: function (t, e, r, n, i) { for (var o = 1 - n, a = 0; a !== i; ++a) { var s = e + a; t[s] = t[s] * o + t[r + a] * n } } }); var Xh = new RegExp("[\\[\\]\\.:\\/]", "g"), Yh = "[^" + "\\[\\]\\.:\\/".replace("\\.", "") + "]", Zh = /((?:WC+[\/:])*)/.source.replace("WC", "[^\\[\\]\\.:\\/]"), Jh = /(WCOD+)?/.source.replace("WCOD", Yh), Kh = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", "[^\\[\\]\\.:\\/]"), Qh = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", "[^\\[\\]\\.:\\/]"), $h = new RegExp("^" + Zh + Jh + Kh + Qh + "$"), tu = ["material", "materials", "bones"]; function eu(t, e, r) { var n = r || ru.parseTrackName(e); this._targetGroup = t, this._bindings = t.subscribe_(e, n) } function ru(t, e, r) { this.path = e, this.parsedPath = r || ru.parseTrackName(e), this.node = ru.findNode(t, this.parsedPath.nodeName) || t, this.rootNode = t } function nu(t, e, r) { this._mixer = t, this._clip = e, this._localRoot = r || null; for (var n = e.tracks, i = n.length, o = new Array(i), a = { endingStart: ae, endingEnd: ae }, s = 0; s !== i; ++s) { var c = n[s].createInterpolant(null); o[s] = c, c.settings = a } this._interpolantSettings = a, this._interpolants = o, this._propertyBindings = new Array(i), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = oe, this._loopCount = -1, this._startTime = null, this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = !1, this.enabled = !0, this.clampWhenFinished = !1, this.zeroSlopeAtStart = !0, this.zeroSlopeAtEnd = !0 } function iu(t) { this._root = t, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this.timeScale = 1 } function ou(t) { "string" == typeof t && (console.warn("THREE.Uniform: Type parameter is no longer needed."), t = arguments[1]), this.value = t } function au(t, e, r) { Ia.call(this, t, e), this.meshPerAttribute = r || 1 } function su(t, e) { return t.distance - e.distance } function cu(t, e, r, n) { if (!1 !== t.visible && (t.raycast(e, r), !0 === n)) for (var i = t.children, o = 0, a = i.length; o < a; o++)cu(i[o], e, r, !0) } Object.assign(eu.prototype, { getValue: function (t, e) { this.bind(); var r = this._targetGroup.nCachedObjects_, n = this._bindings[r]; void 0 !== n && n.getValue(t, e) }, setValue: function (t, e) { for (var r = this._bindings, n = this._targetGroup.nCachedObjects_, i = r.length; n !== i; ++n)r[n].setValue(t, e) }, bind: function () { for (var t = this._bindings, e = this._targetGroup.nCachedObjects_, r = t.length; e !== r; ++e)t[e].bind() }, unbind: function () { for (var t = this._bindings, e = this._targetGroup.nCachedObjects_, r = t.length; e !== r; ++e)t[e].unbind() } }), Object.assign(ru, { Composite: eu, create: function (t, e, r) { return t && t.isAnimationObjectGroup ? new ru.Composite(t, e, r) : new ru(t, e, r) }, sanitizeNodeName: function (t) { return t.replace(/\s/g, "_").replace(Xh, "") }, parseTrackName: function (t) { var e = $h.exec(t); if (!e) throw new Error("PropertyBinding: Cannot parse trackName: " + t); var r = { nodeName: e[2], objectName: e[3], objectIndex: e[4], propertyName: e[5], propertyIndex: e[6] }, n = r.nodeName && r.nodeName.lastIndexOf("."); if (void 0 !== n && -1 !== n) { var i = r.nodeName.substring(n + 1); -1 !== tu.indexOf(i) && (r.nodeName = r.nodeName.substring(0, n), r.objectName = i) } if (null === r.propertyName || 0 === r.propertyName.length) throw new Error("PropertyBinding: can not parse propertyName from trackName: " + t); return r }, findNode: function (t, e) { if (!e || "" === e || "root" === e || "." === e || -1 === e || e === t.name || e === t.uuid) return t; if (t.skeleton) { var r = t.skeleton.getBoneByName(e); if (void 0 !== r) return r } if (t.children) { var n = function (t) { for (var r = 0; r < t.length; r++) { var i = t[r]; if (i.name === e || i.uuid === e) return i; var o = n(i.children); if (o) return o } return null }, i = n(t.children); if (i) return i } return null } }), Object.assign(ru.prototype, { _getValue_unavailable: function () { }, _setValue_unavailable: function () { }, BindingType: { Direct: 0, EntireArray: 1, ArrayElement: 2, HasFromToArray: 3 }, Versioning: { None: 0, NeedsUpdate: 1, MatrixWorldNeedsUpdate: 2 }, GetterByBindingType: [function (t, e) { t[e] = this.node[this.propertyName] }, function (t, e) { for (var r = this.resolvedProperty, n = 0, i = r.length; n !== i; ++n)t[e++] = r[n] }, function (t, e) { t[e] = this.resolvedProperty[this.propertyIndex] }, function (t, e) { this.resolvedProperty.toArray(t, e) }], SetterByBindingTypeAndVersioning: [[function (t, e) { this.targetObject[this.propertyName] = t[e] }, function (t, e) { this.targetObject[this.propertyName] = t[e], this.targetObject.needsUpdate = !0 }, function (t, e) { this.targetObject[this.propertyName] = t[e], this.targetObject.matrixWorldNeedsUpdate = !0 }], [function (t, e) { for (var r = this.resolvedProperty, n = 0, i = r.length; n !== i; ++n)r[n] = t[e++] }, function (t, e) { for (var r = this.resolvedProperty, n = 0, i = r.length; n !== i; ++n)r[n] = t[e++]; this.targetObject.needsUpdate = !0 }, function (t, e) { for (var r = this.resolvedProperty, n = 0, i = r.length; n !== i; ++n)r[n] = t[e++]; this.targetObject.matrixWorldNeedsUpdate = !0 }], [function (t, e) { this.resolvedProperty[this.propertyIndex] = t[e] }, function (t, e) { this.resolvedProperty[this.propertyIndex] = t[e], this.targetObject.needsUpdate = !0 }, function (t, e) { this.resolvedProperty[this.propertyIndex] = t[e], this.targetObject.matrixWorldNeedsUpdate = !0 }], [function (t, e) { this.resolvedProperty.fromArray(t, e) }, function (t, e) { this.resolvedProperty.fromArray(t, e), this.targetObject.needsUpdate = !0 }, function (t, e) { this.resolvedProperty.fromArray(t, e), this.targetObject.matrixWorldNeedsUpdate = !0 }]], getValue: function (t, e) { this.bind(), this.getValue(t, e) }, setValue: function (t, e) { this.bind(), this.setValue(t, e) }, bind: function () { var t = this.node, e = this.parsedPath, r = e.objectName, n = e.propertyName, i = e.propertyIndex; if (t || (t = ru.findNode(this.rootNode, e.nodeName) || this.rootNode, this.node = t), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, t) { if (r) { var o = e.objectIndex; switch (r) { case "materials": if (!t.material) return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this); if (!t.material.materials) return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this); t = t.material.materials; break; case "bones": if (!t.skeleton) return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this); t = t.skeleton.bones; for (var a = 0; a < t.length; a++)if (t[a].name === o) { o = a; break } break; default: if (void 0 === t[r]) return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this); t = t[r] }if (void 0 !== o) { if (void 0 === t[o]) return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, t); t = t[o] } } var s = t[n]; if (void 0 !== s) { var c = this.Versioning.None; this.targetObject = t, void 0 !== t.needsUpdate ? c = this.Versioning.NeedsUpdate : void 0 !== t.matrixWorldNeedsUpdate && (c = this.Versioning.MatrixWorldNeedsUpdate); var l = this.BindingType.Direct; if (void 0 !== i) { if ("morphTargetInfluences" === n) { if (!t.geometry) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this); if (t.geometry.isBufferGeometry) { if (!t.geometry.morphAttributes) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this); for (a = 0; a < this.node.geometry.morphAttributes.position.length; a++)if (t.geometry.morphAttributes.position[a].name === i) { i = a; break } } else { if (!t.geometry.morphTargets) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphTargets.", this); for (a = 0; a < this.node.geometry.morphTargets.length; a++)if (t.geometry.morphTargets[a].name === i) { i = a; break } } } l = this.BindingType.ArrayElement, this.resolvedProperty = s, this.propertyIndex = i } else void 0 !== s.fromArray && void 0 !== s.toArray ? (l = this.BindingType.HasFromToArray, this.resolvedProperty = s) : Array.isArray(s) ? (l = this.BindingType.EntireArray, this.resolvedProperty = s) : this.propertyName = n; this.getValue = this.GetterByBindingType[l], this.setValue = this.SetterByBindingTypeAndVersioning[l][c] } else { var h = e.nodeName; console.error("THREE.PropertyBinding: Trying to update property for track: " + h + "." + n + " but it wasn't found.", t) } } else console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.") }, unbind: function () { this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound } }), Object.assign(ru.prototype, { _getValue_unbound: ru.prototype.getValue, _setValue_unbound: ru.prototype.setValue }), Object.assign(function () { this.uuid = Le.generateUUID(), this._objects = Array.prototype.slice.call(arguments), this.nCachedObjects_ = 0; var t = {}; this._indicesByUUID = t; for (var e = 0, r = arguments.length; e !== r; ++e)t[arguments[e].uuid] = e; this._paths = [], this._parsedPaths = [], this._bindings = [], this._bindingsIndicesByPath = {}; var n = this; this.stats = { objects: { get total() { return n._objects.length }, get inUse() { return this.total - n.nCachedObjects_ } }, get bindingsPerObject() { return n._bindings.length } } }.prototype, { isAnimationObjectGroup: !0, add: function () { for (var t = this._objects, e = t.length, r = this.nCachedObjects_, n = this._indicesByUUID, i = this._paths, o = this._parsedPaths, a = this._bindings, s = a.length, c = void 0, l = 0, h = arguments.length; l !== h; ++l) { var u = arguments[l], p = u.uuid, d = n[p]; if (void 0 === d) { d = e++, n[p] = d, t.push(u); for (var f = 0, m = s; f !== m; ++f)a[f].push(new ru(u, i[f], o[f])) } else if (d < r) { c = t[d]; var v = --r, g = t[v]; n[g.uuid] = d, t[d] = g, n[p] = v, t[v] = u; for (f = 0, m = s; f !== m; ++f) { var y = a[f], x = y[v], b = y[d]; y[d] = x, void 0 === b && (b = new ru(u, i[f], o[f])), y[v] = b } } else t[d] !== c && console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.") } this.nCachedObjects_ = r }, remove: function () { for (var t = this._objects, e = this.nCachedObjects_, r = this._indicesByUUID, n = this._bindings, i = n.length, o = 0, a = arguments.length; o !== a; ++o) { var s = arguments[o], c = s.uuid, l = r[c]; if (void 0 !== l && l >= e) { var h = e++, u = t[h]; r[u.uuid] = l, t[l] = u, r[c] = h, t[h] = s; for (var p = 0, d = i; p !== d; ++p) { var f = n[p], m = f[h], v = f[l]; f[l] = m, f[h] = v } } } this.nCachedObjects_ = e }, uncache: function () { for (var t = this._objects, e = t.length, r = this.nCachedObjects_, n = this._indicesByUUID, i = this._bindings, o = i.length, a = 0, s = arguments.length; a !== s; ++a) { var c = arguments[a], l = c.uuid, h = n[l]; if (void 0 !== h) if (delete n[l], h < r) { var u = --r, p = t[u], d = t[y = --e]; n[p.uuid] = h, t[h] = p, n[d.uuid] = u, t[u] = d, t.pop(); for (var f = 0, m = o; f !== m; ++f) { var v = (x = i[f])[u], g = x[y]; x[h] = v, x[u] = g, x.pop() } } else { var y; n[(d = t[y = --e]).uuid] = h, t[h] = d, t.pop(); for (f = 0, m = o; f !== m; ++f) { var x; (x = i[f])[h] = x[y], x.pop() } } } this.nCachedObjects_ = r }, subscribe_: function (t, e) { var r = this._bindingsIndicesByPath, n = r[t], i = this._bindings; if (void 0 !== n) return i[n]; var o = this._paths, a = this._parsedPaths, s = this._objects, c = s.length, l = this.nCachedObjects_, h = new Array(c); n = i.length, r[t] = n, o.push(t), a.push(e), i.push(h); for (var u = l, p = s.length; u !== p; ++u) { var d = s[u]; h[u] = new ru(d, t, e) } return h }, unsubscribe_: function (t) { var e = this._bindingsIndicesByPath, r = e[t]; if (void 0 !== r) { var n = this._paths, i = this._parsedPaths, o = this._bindings, a = o.length - 1, s = o[a]; e[t[a]] = r, o[r] = s, o.pop(), i[r] = i[a], i.pop(), n[r] = n[a], n.pop() } } }), Object.assign(nu.prototype, { play: function () { return this._mixer._activateAction(this), this }, stop: function () { return this._mixer._deactivateAction(this), this.reset() }, reset: function () { return this.paused = !1, this.enabled = !0, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping() }, isRunning: function () { return this.enabled && !this.paused && 0 !== this.timeScale && null === this._startTime && this._mixer._isActiveAction(this) }, isScheduled: function () { return this._mixer._isActiveAction(this) }, startAt: function (t) { return this._startTime = t, this }, setLoop: function (t, e) { return this.loop = t, this.repetitions = e, this }, setEffectiveWeight: function (t) { return this.weight = t, this._effectiveWeight = this.enabled ? t : 0, this.stopFading() }, getEffectiveWeight: function () { return this._effectiveWeight }, fadeIn: function (t) { return this._scheduleFading(t, 0, 1) }, fadeOut: function (t) { return this._scheduleFading(t, 1, 0) }, crossFadeFrom: function (t, e, r) { if (t.fadeOut(e), this.fadeIn(e), r) { var n = this._clip.duration, i = t._clip.duration, o = i / n, a = n / i; t.warp(1, o, e), this.warp(a, 1, e) } return this }, crossFadeTo: function (t, e, r) { return t.crossFadeFrom(this, e, r) }, stopFading: function () { var t = this._weightInterpolant; return null !== t && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(t)), this }, setEffectiveTimeScale: function (t) { return this.timeScale = t, this._effectiveTimeScale = this.paused ? 0 : t, this.stopWarping() }, getEffectiveTimeScale: function () { return this._effectiveTimeScale }, setDuration: function (t) { return this.timeScale = this._clip.duration / t, this.stopWarping() }, syncWith: function (t) { return this.time = t.time, this.timeScale = t.timeScale, this.stopWarping() }, halt: function (t) { return this.warp(this._effectiveTimeScale, 0, t) }, warp: function (t, e, r) { var n = this._mixer, i = n.time, o = this._timeScaleInterpolant, a = this.timeScale; null === o && (o = n._lendControlInterpolant(), this._timeScaleInterpolant = o); var s = o.parameterPositions, c = o.sampleValues; return s[0] = i, s[1] = i + r, c[0] = t / a, c[1] = e / a, this }, stopWarping: function () { var t = this._timeScaleInterpolant; return null !== t && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(t)), this }, getMixer: function () { return this._mixer }, getClip: function () { return this._clip }, getRoot: function () { return this._localRoot || this._mixer._root }, _update: function (t, e, r, n) { if (this.enabled) { var i = this._startTime; if (null !== i) { var o = (t - i) * r; if (o < 0 || 0 === r) return; this._startTime = null, e = r * o } e *= this._updateTimeScale(t); var a = this._updateTime(e), s = this._updateWeight(t); if (s > 0) for (var c = this._interpolants, l = this._propertyBindings, h = 0, u = c.length; h !== u; ++h)c[h].evaluate(a), l[h].accumulate(n, s) } else this._updateWeight(t) }, _updateWeight: function (t) { var e = 0; if (this.enabled) { e = this.weight; var r = this._weightInterpolant; if (null !== r) { var n = r.evaluate(t)[0]; e *= n, t > r.parameterPositions[1] && (this.stopFading(), 0 === n && (this.enabled = !1)) } } return this._effectiveWeight = e, e }, _updateTimeScale: function (t) { var e = 0; if (!this.paused) { e = this.timeScale; var r = this._timeScaleInterpolant; if (null !== r) e *= r.evaluate(t)[0], t > r.parameterPositions[1] && (this.stopWarping(), 0 === e ? this.paused = !0 : this.timeScale = e) } return this._effectiveTimeScale = e, e }, _updateTime: function (t) { var e = this.time + t, r = this._clip.duration, n = this.loop, i = this._loopCount, o = 2202 === n; if (0 === t) return -1 === i ? e : o && 1 == (1 & i) ? r - e : e; if (2200 === n) { -1 === i && (this._loopCount = 0, this._setEndings(!0, !0, !1)); t: { if (e >= r) e = r; else { if (!(e < 0)) { this.time = e; break t } e = 0 } this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, this.time = e, this._mixer.dispatchEvent({ type: "finished", action: this, direction: t < 0 ? -1 : 1 }) } } else { if (-1 === i && (t >= 0 ? (i = 0, this._setEndings(!0, 0 === this.repetitions, o)) : this._setEndings(0 === this.repetitions, !0, o)), e >= r || e < 0) { var a = Math.floor(e / r); e -= r * a, i += Math.abs(a); var s = this.repetitions - i; if (s <= 0) this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, e = t > 0 ? r : 0, this.time = e, this._mixer.dispatchEvent({ type: "finished", action: this, direction: t > 0 ? 1 : -1 }); else { if (1 === s) { var c = t < 0; this._setEndings(c, !c, o) } else this._setEndings(!1, !1, o); this._loopCount = i, this.time = e, this._mixer.dispatchEvent({ type: "loop", action: this, loopDelta: a }) } } else this.time = e; if (o && 1 == (1 & i)) return r - e } return e }, _setEndings: function (t, e, r) { var n = this._interpolantSettings; r ? (n.endingStart = 2401, n.endingEnd = 2401) : (n.endingStart = t ? this.zeroSlopeAtStart ? 2401 : ae : 2402, n.endingEnd = e ? this.zeroSlopeAtEnd ? 2401 : ae : 2402) }, _scheduleFading: function (t, e, r) { var n = this._mixer, i = n.time, o = this._weightInterpolant; null === o && (o = n._lendControlInterpolant(), this._weightInterpolant = o); var a = o.parameterPositions, s = o.sampleValues; return a[0] = i, s[0] = e, a[1] = i + t, s[1] = r, this } }), iu.prototype = Object.assign(Object.create(Te.prototype), { constructor: iu, _bindAction: function (t, e) { var r = t._localRoot || this._root, n = t._clip.tracks, i = n.length, o = t._propertyBindings, a = t._interpolants, s = r.uuid, c = this._bindingsByRootAndName, l = c[s]; void 0 === l && (l = {}, c[s] = l); for (var h = 0; h !== i; ++h) { var u = n[h], p = u.name, d = l[p]; if (void 0 !== d) o[h] = d; else { if (void 0 !== (d = o[h])) { null === d._cacheIndex && (++d.referenceCount, this._addInactiveBinding(d, s, p)); continue } var f = e && e._propertyBindings[h].binding.parsedPath; ++(d = new qh(ru.create(r, p, f), u.ValueTypeName, u.getValueSize())).referenceCount, this._addInactiveBinding(d, s, p), o[h] = d } a[h].resultBuffer = d.buffer } }, _activateAction: function (t) { if (!this._isActiveAction(t)) { if (null === t._cacheIndex) { var e = (t._localRoot || this._root).uuid, r = t._clip.uuid, n = this._actionsByClip[r]; this._bindAction(t, n && n.knownActions[0]), this._addInactiveAction(t, r, e) } for (var i = t._propertyBindings, o = 0, a = i.length; o !== a; ++o) { var s = i[o]; 0 == s.useCount++ && (this._lendBinding(s), s.saveOriginalState()) } this._lendAction(t) } }, _deactivateAction: function (t) { if (this._isActiveAction(t)) { for (var e = t._propertyBindings, r = 0, n = e.length; r !== n; ++r) { var i = e[r]; 0 == --i.useCount && (i.restoreOriginalState(), this._takeBackBinding(i)) } this._takeBackAction(t) } }, _initMemoryManager: function () { this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0; var t = this; this.stats = { actions: { get total() { return t._actions.length }, get inUse() { return t._nActiveActions } }, bindings: { get total() { return t._bindings.length }, get inUse() { return t._nActiveBindings } }, controlInterpolants: { get total() { return t._controlInterpolants.length }, get inUse() { return t._nActiveControlInterpolants } } } }, _isActiveAction: function (t) { var e = t._cacheIndex; return null !== e && e < this._nActiveActions }, _addInactiveAction: function (t, e, r) { var n = this._actions, i = this._actionsByClip, o = i[e]; if (void 0 === o) o = { knownActions: [t], actionByRoot: {} }, t._byClipCacheIndex = 0, i[e] = o; else { var a = o.knownActions; t._byClipCacheIndex = a.length, a.push(t) } t._cacheIndex = n.length, n.push(t), o.actionByRoot[r] = t }, _removeInactiveAction: function (t) { var e = this._actions, r = e[e.length - 1], n = t._cacheIndex; r._cacheIndex = n, e[n] = r, e.pop(), t._cacheIndex = null; var i = t._clip.uuid, o = this._actionsByClip, a = o[i], s = a.knownActions, c = s[s.length - 1], l = t._byClipCacheIndex; c._byClipCacheIndex = l, s[l] = c, s.pop(), t._byClipCacheIndex = null, delete a.actionByRoot[(t._localRoot || this._root).uuid], 0 === s.length && delete o[i], this._removeInactiveBindingsForAction(t) }, _removeInactiveBindingsForAction: function (t) { for (var e = t._propertyBindings, r = 0, n = e.length; r !== n; ++r) { var i = e[r]; 0 == --i.referenceCount && this._removeInactiveBinding(i) } }, _lendAction: function (t) { var e = this._actions, r = t._cacheIndex, n = this._nActiveActions++, i = e[n]; t._cacheIndex = n, e[n] = t, i._cacheIndex = r, e[r] = i }, _takeBackAction: function (t) { var e = this._actions, r = t._cacheIndex, n = --this._nActiveActions, i = e[n]; t._cacheIndex = n, e[n] = t, i._cacheIndex = r, e[r] = i }, _addInactiveBinding: function (t, e, r) { var n = this._bindingsByRootAndName, i = n[e], o = this._bindings; void 0 === i && (i = {}, n[e] = i), i[r] = t, t._cacheIndex = o.length, o.push(t) }, _removeInactiveBinding: function (t) { var e = this._bindings, r = t.binding, n = r.rootNode.uuid, i = r.path, o = this._bindingsByRootAndName, a = o[n], s = e[e.length - 1], c = t._cacheIndex; s._cacheIndex = c, e[c] = s, e.pop(), delete a[i], 0 === Object.keys(a).length && delete o[n] }, _lendBinding: function (t) { var e = this._bindings, r = t._cacheIndex, n = this._nActiveBindings++, i = e[n]; t._cacheIndex = n, e[n] = t, i._cacheIndex = r, e[r] = i }, _takeBackBinding: function (t) { var e = this._bindings, r = t._cacheIndex, n = --this._nActiveBindings, i = e[n]; t._cacheIndex = n, e[n] = t, i._cacheIndex = r, e[r] = i }, _lendControlInterpolant: function () { var t = this._controlInterpolants, e = this._nActiveControlInterpolants++, r = t[e]; return void 0 === r && ((r = new il(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer)).__cacheIndex = e, t[e] = r), r }, _takeBackControlInterpolant: function (t) { var e = this._controlInterpolants, r = t.__cacheIndex, n = --this._nActiveControlInterpolants, i = e[n]; t.__cacheIndex = n, e[n] = t, i.__cacheIndex = r, e[r] = i }, _controlInterpolantsResultBuffer: new Float32Array(1), clipAction: function (t, e) { var r = e || this._root, n = r.uuid, i = "string" == typeof t ? fl.findByName(r, t) : t, o = null !== i ? i.uuid : t, a = this._actionsByClip[o], s = null; if (void 0 !== a) { var c = a.actionByRoot[n]; if (void 0 !== c) return c; s = a.knownActions[0], null === i && (i = s._clip) } if (null === i) return null; var l = new nu(this, i, e); return this._bindAction(l, s), this._addInactiveAction(l, o, n), l }, existingAction: function (t, e) { var r = e || this._root, n = r.uuid, i = "string" == typeof t ? fl.findByName(r, t) : t, o = i ? i.uuid : t, a = this._actionsByClip[o]; return void 0 !== a && a.actionByRoot[n] || null }, stopAllAction: function () { var t = this._actions, e = this._nActiveActions, r = this._bindings, n = this._nActiveBindings; this._nActiveActions = 0, this._nActiveBindings = 0; for (var i = 0; i !== e; ++i)t[i].reset(); for (i = 0; i !== n; ++i)r[i].useCount = 0; return this }, update: function (t) { t *= this.timeScale; for (var e = this._actions, r = this._nActiveActions, n = this.time += t, i = Math.sign(t), o = this._accuIndex ^= 1, a = 0; a !== r; ++a) { e[a]._update(n, t, i, o) } var s = this._bindings, c = this._nActiveBindings; for (a = 0; a !== c; ++a)s[a].apply(o); return this }, setTime: function (t) { this.time = 0; for (var e = 0; e < this._actions.length; e++)this._actions[e].time = 0; return this.update(t) }, getRoot: function () { return this._root }, uncacheClip: function (t) { var e = this._actions, r = t.uuid, n = this._actionsByClip, i = n[r]; if (void 0 !== i) { for (var o = i.knownActions, a = 0, s = o.length; a !== s; ++a) { var c = o[a]; this._deactivateAction(c); var l = c._cacheIndex, h = e[e.length - 1]; c._cacheIndex = null, c._byClipCacheIndex = null, h._cacheIndex = l, e[l] = h, e.pop(), this._removeInactiveBindingsForAction(c) } delete n[r] } }, uncacheRoot: function (t) { var e = t.uuid, r = this._actionsByClip; for (var n in r) { var i = r[n].actionByRoot[e]; void 0 !== i && (this._deactivateAction(i), this._removeInactiveAction(i)) } var o = this._bindingsByRootAndName[e]; if (void 0 !== o) for (var a in o) { var s = o[a]; s.restoreOriginalState(), this._removeInactiveBinding(s) } }, uncacheAction: function (t, e) { var r = this.existingAction(t, e); null !== r && (this._deactivateAction(r), this._removeInactiveAction(r)) } }), ou.prototype.clone = function () { return new ou(void 0 === this.value.clone ? this.value : this.value.clone()) }, au.prototype = Object.assign(Object.create(Ia.prototype), { constructor: au, isInstancedInterleavedBuffer: !0, copy: function (t) { return Ia.prototype.copy.call(this, t), this.meshPerAttribute = t.meshPerAttribute, this } }), Object.assign(function (t, e, r, n) { this.ray = new kr(t, e), this.near = r || 0, this.far = n || 1 / 0, this.camera = null, this.params = { Mesh: {}, Line: {}, LOD: {}, Points: { threshold: 1 }, Sprite: {} }, Object.defineProperties(this.params, { PointCloud: { get: function () { return console.warn("THREE.Raycaster: params.PointCloud has been renamed to params.Points."), this.Points } } }) }.prototype, { linePrecision: 1, set: function (t, e) { this.ray.set(t, e) }, setFromCamera: function (t, e) { e && e.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(e.matrixWorld), this.ray.direction.set(t.x, t.y, .5).unproject(e).sub(this.ray.origin).normalize(), this.camera = e) : e && e.isOrthographicCamera ? (this.ray.origin.set(t.x, t.y, (e.near + e.far) / (e.near - e.far)).unproject(e), this.ray.direction.set(0, 0, -1).transformDirection(e.matrixWorld), this.camera = e) : console.error("THREE.Raycaster: Unsupported camera type.") }, intersectObject: function (t, e, r) { var n = r || []; return cu(t, this, n, e), n.sort(su), n }, intersectObjects: function (t, e, r) { var n = r || []; if (!1 === Array.isArray(t)) return console.warn("THREE.Raycaster.intersectObjects: objects is not an Array."), n; for (var i = 0, o = t.length; i < o; i++)cu(t[i], this, n, e); return n.sort(su), n } }), Object.assign(function (t, e, r) { return this.radius = void 0 !== t ? t : 1, this.phi = void 0 !== e ? e : 0, this.theta = void 0 !== r ? r : 0, this }.prototype, { set: function (t, e, r) { return this.radius = t, this.phi = e, this.theta = r, this }, clone: function () { return (new this.constructor).copy(this) }, copy: function (t) { return this.radius = t.radius, this.phi = t.phi, this.theta = t.theta, this }, makeSafe: function () { return this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi)), this }, setFromVector3: function (t) { return this.setFromCartesianCoords(t.x, t.y, t.z) }, setFromCartesianCoords: function (t, e, r) { return this.radius = Math.sqrt(t * t + e * e + r * r), 0 === this.radius ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(t, r), this.phi = Math.acos(Le.clamp(e / this.radius, -1, 1))), this } }), Object.assign(function (t, e, r) { return this.radius = void 0 !== t ? t : 1, this.theta = void 0 !== e ? e : 0, this.y = void 0 !== r ? r : 0, this }.prototype, { set: function (t, e, r) { return this.radius = t, this.theta = e, this.y = r, this }, clone: function () { return (new this.constructor).copy(this) }, copy: function (t) { return this.radius = t.radius, this.theta = t.theta, this.y = t.y, this }, setFromVector3: function (t) { return this.setFromCartesianCoords(t.x, t.y, t.z) }, setFromCartesianCoords: function (t, e, r) { return this.radius = Math.sqrt(t * t + r * r), this.theta = Math.atan2(t, r), this.y = e, this } }); var lu = new Pe; function hu(t, e) { this.min = void 0 !== t ? t : new Pe(1 / 0, 1 / 0), this.max = void 0 !== e ? e : new Pe(-1 / 0, -1 / 0) } Object.assign(hu.prototype, { set: function (t, e) { return this.min.copy(t), this.max.copy(e), this }, setFromPoints: function (t) { this.makeEmpty(); for (var e = 0, r = t.length; e < r; e++)this.expandByPoint(t[e]); return this }, setFromCenterAndSize: function (t, e) { var r = lu.copy(e).multiplyScalar(.5); return this.min.copy(t).sub(r), this.max.copy(t).add(r), this }, clone: function () { return (new this.constructor).copy(this) }, copy: function (t) { return this.min.copy(t.min), this.max.copy(t.max), this }, makeEmpty: function () { return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -1 / 0, this }, isEmpty: function () { return this.max.x < this.min.x || this.max.y < this.min.y }, getCenter: function (t) { return void 0 === t && (console.warn("THREE.Box2: .getCenter() target is now required"), t = new Pe), this.isEmpty() ? t.set(0, 0) : t.addVectors(this.min, this.max).multiplyScalar(.5) }, getSize: function (t) { return void 0 === t && (console.warn("THREE.Box2: .getSize() target is now required"), t = new Pe), this.isEmpty() ? t.set(0, 0) : t.subVectors(this.max, this.min) }, expandByPoint: function (t) { return this.min.min(t), this.max.max(t), this }, expandByVector: function (t) { return this.min.sub(t), this.max.add(t), this }, expandByScalar: function (t) { return this.min.addScalar(-t), this.max.addScalar(t), this }, containsPoint: function (t) { return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y) }, containsBox: function (t) { return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y }, getParameter: function (t, e) { return void 0 === e && (console.warn("THREE.Box2: .getParameter() target is now required"), e = new Pe), e.set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y)) }, intersectsBox: function (t) { return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y) }, clampPoint: function (t, e) { return void 0 === e && (console.warn("THREE.Box2: .clampPoint() target is now required"), e = new Pe), e.copy(t).clamp(this.min, this.max) }, distanceToPoint: function (t) { return lu.copy(t).clamp(this.min, this.max).sub(t).length() }, intersect: function (t) { return this.min.max(t.min), this.max.min(t.max), this }, union: function (t) { return this.min.min(t.min), this.max.max(t.max), this }, translate: function (t) { return this.min.add(t), this.max.add(t), this }, equals: function (t) { return t.min.equals(this.min) && t.max.equals(this.max) } }); var uu = new Ie, pu = new Ie; function du(t, e) { this.start = void 0 !== t ? t : new Ie, this.end = void 0 !== e ? e : new Ie } function fu(t) { fr.call(this), this.material = t, this.render = function () { } } Object.assign(du.prototype, { set: function (t, e) { return this.start.copy(t), this.end.copy(e), this }, clone: function () { return (new this.constructor).copy(this) }, copy: function (t) { return this.start.copy(t.start), this.end.copy(t.end), this }, getCenter: function (t) { return void 0 === t && (console.warn("THREE.Line3: .getCenter() target is now required"), t = new Ie), t.addVectors(this.start, this.end).multiplyScalar(.5) }, delta: function (t) { return void 0 === t && (console.warn("THREE.Line3: .delta() target is now required"), t = new Ie), t.subVectors(this.end, this.start) }, distanceSq: function () { return this.start.distanceToSquared(this.end) }, distance: function () { return this.start.distanceTo(this.end) }, at: function (t, e) { return void 0 === e && (console.warn("THREE.Line3: .at() target is now required"), e = new Ie), this.delta(e).multiplyScalar(t).add(this.start) }, closestPointToPointParameter: function (t, e) { uu.subVectors(t, this.start), pu.subVectors(this.end, this.start); var r = pu.dot(pu), n = pu.dot(uu) / r; return e && (n = Le.clamp(n, 0, 1)), n }, closestPointToPoint: function (t, e, r) { var n = this.closestPointToPointParameter(t, e); return void 0 === r && (console.warn("THREE.Line3: .closestPointToPoint() target is now required"), r = new Ie), this.delta(r).multiplyScalar(n).add(this.start) }, applyMatrix4: function (t) { return this.start.applyMatrix4(t), this.end.applyMatrix4(t), this }, equals: function (t) { return t.start.equals(this.start) && t.end.equals(this.end) } }), fu.prototype = Object.create(fr.prototype), fu.prototype.constructor = fu, fu.prototype.isImmediateRenderObject = !0; var mu = new Ie, vu = new Ie, gu = new ze, yu = ["a", "b", "c"]; function xu(t, e, r, n) { this.object = t, this.size = void 0 !== e ? e : 1; var i = void 0 !== r ? r : 16711680, o = void 0 !== n ? n : 1, a = 0, s = this.object.geometry; s && s.isGeometry ? a = 3 * s.faces.length : s && s.isBufferGeometry && (a = s.attributes.normal.count); var c = new In, l = new _n(2 * a * 3, 3); c.setAttribute("position", l), ys.call(this, c, new ls({ color: i, linewidth: o })), this.matrixAutoUpdate = !1, this.update() } xu.prototype = Object.create(ys.prototype), xu.prototype.constructor = xu, xu.prototype.update = function () { this.object.updateMatrixWorld(!0), gu.getNormalMatrix(this.object.matrixWorld); var t = this.object.matrixWorld, e = this.geometry.attributes.position, r = this.object.geometry; if (r && r.isGeometry) for (var n = r.vertices, i = r.faces, o = 0, a = 0, s = i.length; a < s; a++)for (var c = i[a], l = 0, h = c.vertexNormals.length; l < h; l++) { var u = n[c[yu[l]]], p = c.vertexNormals[l]; mu.copy(u).applyMatrix4(t), vu.copy(p).applyMatrix3(gu).normalize().multiplyScalar(this.size).add(mu), e.setXYZ(o, mu.x, mu.y, mu.z), o += 1, e.setXYZ(o, vu.x, vu.y, vu.z), o += 1 } else if (r && r.isBufferGeometry) { var d = r.attributes.position, f = r.attributes.normal; for (o = 0, l = 0, h = d.count; l < h; l++)mu.set(d.getX(l), d.getY(l), d.getZ(l)).applyMatrix4(t), vu.set(f.getX(l), f.getY(l), f.getZ(l)), vu.applyMatrix3(gu).normalize().multiplyScalar(this.size).add(mu), e.setXYZ(o, mu.x, mu.y, mu.z), o += 1, e.setXYZ(o, vu.x, vu.y, vu.z), o += 1 } e.needsUpdate = !0 }; var bu = new Ie; function wu(t, e) { fr.call(this), this.light = t, this.light.updateMatrixWorld(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.color = e; for (var r = new In, n = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1], i = 0, o = 1; i < 32; i++, o++) { var a = i / 32 * Math.PI * 2, s = o / 32 * Math.PI * 2; n.push(Math.cos(a), Math.sin(a), 1, Math.cos(s), Math.sin(s), 1) } r.setAttribute("position", new _n(n, 3)); var c = new ls({ fog: !1 }); this.cone = new ys(r, c), this.add(this.cone), this.update() } wu.prototype = Object.create(fr.prototype), wu.prototype.constructor = wu, wu.prototype.dispose = function () { this.cone.geometry.dispose(), this.cone.material.dispose() }, wu.prototype.update = function () { this.light.updateMatrixWorld(); var t = this.light.distance ? this.light.distance : 1e3, e = t * Math.tan(this.light.angle); this.cone.scale.set(e, e, t), bu.setFromMatrixPosition(this.light.target.matrixWorld), this.cone.lookAt(bu), void 0 !== this.color ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color) }; var _u = new Ie, Mu = new Je, Su = new Je; function Tu(t) { for (var e = function t(e) { var r = []; e && e.isBone && r.push(e); for (var n = 0; n < e.children.length; n++)r.push.apply(r, t(e.children[n])); return r }(t), r = new In, n = [], i = [], o = new an(0, 0, 1), a = new an(0, 1, 0), s = 0; s < e.length; s++) { var c = e[s]; c.parent && c.parent.isBone && (n.push(0, 0, 0), n.push(0, 0, 0), i.push(o.r, o.g, o.b), i.push(a.r, a.g, a.b)) } r.setAttribute("position", new _n(n, 3)), r.setAttribute("color", new _n(i, 3)); var l = new ls({ vertexColors: f, depthTest: !1, depthWrite: !1, transparent: !0 }); ys.call(this, r, l), this.root = t, this.bones = e, this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1 } function Eu(t, e, r) { this.light = t, this.light.updateMatrixWorld(), this.color = r; var n = new Lc(e, 4, 2), i = new dn({ wireframe: !0, fog: !1 }); Kn.call(this, n, i), this.matrix = this.light.matrixWorld, this.matrixAutoUpdate = !1, this.update() } function Au(t, e) { this.type = "RectAreaLightHelper", this.light = t, this.color = e; var r = new In; r.setAttribute("position", new _n([1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0, 1, 1, 0], 3)), r.computeBoundingSphere(); var n = new ls({ fog: !1 }); ms.call(this, r, n); var i = new In; i.setAttribute("position", new _n([1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0], 3)), i.computeBoundingSphere(), this.add(new Kn(i, new dn({ side: h, fog: !1 }))), this.update() } Tu.prototype = Object.create(ys.prototype), Tu.prototype.constructor = Tu, Tu.prototype.updateMatrixWorld = function (t) { var e = this.bones, r = this.geometry, n = r.getAttribute("position"); Su.getInverse(this.root.matrixWorld); for (var i = 0, o = 0; i < e.length; i++) { var a = e[i]; a.parent && a.parent.isBone && (Mu.multiplyMatrices(Su, a.matrixWorld), _u.setFromMatrixPosition(Mu), n.setXYZ(o, _u.x, _u.y, _u.z), Mu.multiplyMatrices(Su, a.parent.matrixWorld), _u.setFromMatrixPosition(Mu), n.setXYZ(o + 1, _u.x, _u.y, _u.z), o += 2) } r.getAttribute("position").needsUpdate = !0, fr.prototype.updateMatrixWorld.call(this, t) }, Eu.prototype = Object.create(Kn.prototype), Eu.prototype.constructor = Eu, Eu.prototype.dispose = function () { this.geometry.dispose(), this.material.dispose() }, Eu.prototype.update = function () { void 0 !== this.color ? this.material.color.set(this.color) : this.material.color.copy(this.light.color) }, Au.prototype = Object.create(ms.prototype), Au.prototype.constructor = Au, Au.prototype.update = function () { if (this.scale.set(.5 * this.light.width, .5 * this.light.height, 1), void 0 !== this.color) this.material.color.set(this.color), this.children[0].material.color.set(this.color); else { this.material.color.copy(this.light.color).multiplyScalar(this.light.intensity); var t = this.material.color, e = Math.max(t.r, t.g, t.b); e > 1 && t.multiplyScalar(1 / e), this.children[0].material.color.copy(this.material.color) } }, Au.prototype.dispose = function () { this.geometry.dispose(), this.material.dispose(), this.children[0].geometry.dispose(), this.children[0].material.dispose() }; var Lu = new Ie, Pu = new an, Ru = new an; function Cu(t, e, r) { fr.call(this), this.light = t, this.light.updateMatrixWorld(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.color = r; var n = new Bs(e); n.rotateY(.5 * Math.PI), this.material = new dn({ wireframe: !0, fog: !1 }), void 0 === this.color && (this.material.vertexColors = f); var i = n.getAttribute("position"), o = new Float32Array(3 * i.count); n.setAttribute("color", new fn(o, 3)), this.add(new Kn(n, this.material)), this.update() } function Ou(t, e) { this.lightProbe = t, this.size = e; var r = { GAMMA_OUTPUT: "" }, n = new hi({ defines: r, uniforms: { sh: { value: this.lightProbe.sh.coefficients }, intensity: { value: this.lightProbe.intensity } }, vertexShader: ["varying vec3 vNormal;", "void main() {", "\tvNormal = normalize( normalMatrix * normal );", "\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"), fragmentShader: ["#define RECIPROCAL_PI 0.318309886", "vec3 inverseTransformDirection( in vec3 normal, in mat4 matrix ) {", "\t// matrix is assumed to be orthogonal", "\treturn normalize( ( vec4( normal, 0.0 ) * matrix ).xyz );", "}", "vec3 linearToOutput( in vec3 a ) {", "\t#ifdef GAMMA_OUTPUT", "\t\treturn pow( a, vec3( 1.0 / float( GAMMA_FACTOR ) ) );", "\t#else", "\t\treturn a;", "\t#endif", "}", "// source: https://graphics.stanford.edu/papers/envmap/envmap.pdf", "vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {", "\t// normal is assumed to have unit length", "\tfloat x = normal.x, y = normal.y, z = normal.z;", "\t// band 0", "\tvec3 result = shCoefficients[ 0 ] * 0.886227;", "\t// band 1", "\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;", "\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;", "\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;", "\t// band 2", "\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;", "\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;", "\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );", "\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;", "\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );", "\treturn result;", "}", "uniform vec3 sh[ 9 ]; // sh coefficients", "uniform float intensity; // light probe intensity", "varying vec3 vNormal;", "void main() {", "\tvec3 normal = normalize( vNormal );", "\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );", "\tvec3 irradiance = shGetIrradianceAt( worldNormal, sh );", "\tvec3 outgoingLight = RECIPROCAL_PI * irradiance * intensity;", "\toutgoingLight = linearToOutput( outgoingLight );", "\tgl_FragColor = vec4( outgoingLight, 1.0 );", "}"].join("\n") }), i = new Lc(1, 32, 16); Kn.call(this, i, n), this.onBeforeRender() } function Iu(t, e, r, n) { t = t || 10, e = e || 10, r = new an(void 0 !== r ? r : 4473924), n = new an(void 0 !== n ? n : 8947848); for (var i = e / 2, o = t / e, a = t / 2, s = [], c = [], l = 0, h = 0, u = -a; l <= e; l++, u += o) { s.push(-a, 0, u, a, 0, u), s.push(u, 0, -a, u, 0, a); var p = l === i ? r : n; p.toArray(c, h), h += 3, p.toArray(c, h), h += 3, p.toArray(c, h), h += 3, p.toArray(c, h), h += 3 } var d = new In; d.setAttribute("position", new _n(s, 3)), d.setAttribute("color", new _n(c, 3)); var m = new ls({ vertexColors: f }); ys.call(this, d, m) } function Nu(t, e, r, n, i, o) { t = t || 10, e = e || 16, r = r || 8, n = n || 64, i = new an(void 0 !== i ? i : 4473924), o = new an(void 0 !== o ? o : 8947848); var a, s, c, l, h, u, p, d = [], m = []; for (l = 0; l <= e; l++)c = l / e * (2 * Math.PI), a = Math.sin(c) * t, s = Math.cos(c) * t, d.push(0, 0, 0), d.push(a, 0, s), p = 1 & l ? i : o, m.push(p.r, p.g, p.b), m.push(p.r, p.g, p.b); for (l = 0; l <= r; l++)for (p = 1 & l ? i : o, u = t - t / r * l, h = 0; h < n; h++)c = h / n * (2 * Math.PI), a = Math.sin(c) * u, s = Math.cos(c) * u, d.push(a, 0, s), m.push(p.r, p.g, p.b), c = (h + 1) / n * (2 * Math.PI), a = Math.sin(c) * u, s = Math.cos(c) * u, d.push(a, 0, s), m.push(p.r, p.g, p.b); var v = new In; v.setAttribute("position", new _n(d, 3)), v.setAttribute("color", new _n(m, 3)); var g = new ls({ vertexColors: f }); ys.call(this, v, g) } function Du(t, e, r, n) { this.audio = t, this.range = e || 1, this.divisionsInnerAngle = r || 16, this.divisionsOuterAngle = n || 2; var i = new In, o = this.divisionsInnerAngle + 2 * this.divisionsOuterAngle, a = new Float32Array(3 * (3 * o + 3)); i.setAttribute("position", new fn(a, 3)); var s = new ls({ color: 65280 }), c = new ls({ color: 16776960 }); ms.call(this, i, [c, s]), this.update() } Cu.prototype = Object.create(fr.prototype), Cu.prototype.constructor = Cu, Cu.prototype.dispose = function () { this.children[0].geometry.dispose(), this.children[0].material.dispose() }, Cu.prototype.update = function () { var t = this.children[0]; if (void 0 !== this.color) this.material.color.set(this.color); else { var e = t.geometry.getAttribute("color"); Pu.copy(this.light.color), Ru.copy(this.light.groundColor); for (var r = 0, n = e.count; r < n; r++) { var i = r < n / 2 ? Pu : Ru; e.setXYZ(r, i.r, i.g, i.b) } e.needsUpdate = !0 } t.lookAt(Lu.setFromMatrixPosition(this.light.matrixWorld).negate()) }, Ou.prototype = Object.create(Kn.prototype), Ou.prototype.constructor = Ou, Ou.prototype.dispose = function () { this.geometry.dispose(), this.material.dispose() }, Ou.prototype.onBeforeRender = function () { this.position.copy(this.lightProbe.position), this.scale.set(1, 1, 1).multiplyScalar(this.size), this.material.uniforms.intensity.value = this.lightProbe.intensity }, Iu.prototype = Object.assign(Object.create(ys.prototype), { constructor: Iu, copy: function (t) { return ys.prototype.copy.call(this, t), this.geometry.copy(t.geometry), this.material.copy(t.material), this }, clone: function () { return (new this.constructor).copy(this) } }), Nu.prototype = Object.create(ys.prototype), Nu.prototype.constructor = Nu, Du.prototype = Object.create(ms.prototype), Du.prototype.constructor = Du, Du.prototype.update = function () { var t, e, r = this.audio, n = this.range, i = this.divisionsInnerAngle, o = this.divisionsOuterAngle, a = Le.degToRad(r.panner.coneInnerAngle), s = Le.degToRad(r.panner.coneOuterAngle), c = a / 2, l = s / 2, h = 0, u = 0, p = this.geometry, d = p.attributes.position; function f(r, i, o, a) { var s = (i - r) / o; for (d.setXYZ(h, 0, 0, 0), u++, t = r; t < i; t += s)e = h + u, d.setXYZ(e, Math.sin(t) * n, 0, Math.cos(t) * n), d.setXYZ(e + 1, Math.sin(Math.min(t + s, i)) * n, 0, Math.cos(Math.min(t + s, i)) * n), d.setXYZ(e + 2, 0, 0, 0), u += 3; p.addGroup(h, u, a), h += u, u = 0 } p.clearGroups(), f(-l, -c, o, 0), f(-c, c, i, 1), f(c, l, o, 0), d.needsUpdate = !0, a === s && (this.material[0].visible = !1) }, Du.prototype.dispose = function () { this.geometry.dispose(), this.material[0].dispose(), this.material[1].dispose() }; var zu = new Ie, Fu = new Ie, Uu = new ze; function Bu(t, e, r, n) { this.object = t, this.size = void 0 !== e ? e : 1; var i = void 0 !== r ? r : 16776960, o = void 0 !== n ? n : 1, a = 0, s = this.object.geometry; s && s.isGeometry ? a = s.faces.length : console.warn("THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead."); var c = new In, l = new _n(2 * a * 3, 3); c.setAttribute("position", l), ys.call(this, c, new ls({ color: i, linewidth: o })), this.matrixAutoUpdate = !1, this.update() } Bu.prototype = Object.create(ys.prototype), Bu.prototype.constructor = Bu, Bu.prototype.update = function () { this.object.updateMatrixWorld(!0), Uu.getNormalMatrix(this.object.matrixWorld); for (var t = this.object.matrixWorld, e = this.geometry.attributes.position, r = this.object.geometry, n = r.vertices, i = r.faces, o = 0, a = 0, s = i.length; a < s; a++) { var c = i[a], l = c.normal; zu.copy(n[c.a]).add(n[c.b]).add(n[c.c]).divideScalar(3).applyMatrix4(t), Fu.copy(l).applyMatrix3(Uu).normalize().multiplyScalar(this.size).add(zu), e.setXYZ(o, zu.x, zu.y, zu.z), o += 1, e.setXYZ(o, Fu.x, Fu.y, Fu.z), o += 1 } e.needsUpdate = !0 }; var ku = new Ie, ju = new Ie, Gu = new Ie; function Vu(t, e, r) { fr.call(this), this.light = t, this.light.updateMatrixWorld(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.color = r, void 0 === e && (e = 1); var n = new In; n.setAttribute("position", new _n([-e, e, 0, e, e, 0, e, -e, 0, -e, -e, 0, -e, e, 0], 3)); var i = new ls({ fog: !1 }); this.lightPlane = new ms(n, i), this.add(this.lightPlane), (n = new In).setAttribute("position", new _n([0, 0, 0, 0, 0, 1], 3)), this.targetLine = new ms(n, i), this.add(this.targetLine), this.update() } Vu.prototype = Object.create(fr.prototype), Vu.prototype.constructor = Vu, Vu.prototype.dispose = function () { this.lightPlane.geometry.dispose(), this.lightPlane.material.dispose(), this.targetLine.geometry.dispose(), this.targetLine.material.dispose() }, Vu.prototype.update = function () { ku.setFromMatrixPosition(this.light.matrixWorld), ju.setFromMatrixPosition(this.light.target.matrixWorld), Gu.subVectors(ju, ku), this.lightPlane.lookAt(ju), void 0 !== this.color ? (this.lightPlane.material.color.set(this.color), this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color), this.targetLine.material.color.copy(this.light.color)), this.targetLine.lookAt(ju), this.targetLine.scale.z = Gu.length() }; var Hu = new Ie, Wu = new ui; function qu(t) { var e = new In, r = new ls({ color: 16777215, vertexColors: d }), n = [], i = [], o = {}, a = new an(16755200), s = new an(16711680), c = new an(43775), l = new an(16777215), h = new an(3355443); function u(t, e, r) { p(t, r), p(e, r) } function p(t, e) { n.push(0, 0, 0), i.push(e.r, e.g, e.b), void 0 === o[t] && (o[t] = []), o[t].push(n.length / 3 - 1) } u("n1", "n2", a), u("n2", "n4", a), u("n4", "n3", a), u("n3", "n1", a), u("f1", "f2", a), u("f2", "f4", a), u("f4", "f3", a), u("f3", "f1", a), u("n1", "f1", a), u("n2", "f2", a), u("n3", "f3", a), u("n4", "f4", a), u("p", "n1", s), u("p", "n2", s), u("p", "n3", s), u("p", "n4", s), u("u1", "u2", c), u("u2", "u3", c), u("u3", "u1", c), u("c", "t", l), u("p", "c", h), u("cn1", "cn2", h), u("cn3", "cn4", h), u("cf1", "cf2", h), u("cf3", "cf4", h), e.setAttribute("position", new _n(n, 3)), e.setAttribute("color", new _n(i, 3)), ys.call(this, e, r), this.camera = t, this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.pointMap = o, this.update() } function Xu(t, e, r, n, i, o, a) { Hu.set(i, o, a).unproject(n); var s = e[t]; if (void 0 !== s) for (var c = r.getAttribute("position"), l = 0, h = s.length; l < h; l++)c.setXYZ(s[l], Hu.x, Hu.y, Hu.z) } qu.prototype = Object.create(ys.prototype), qu.prototype.constructor = qu, qu.prototype.update = function () { var t = this.geometry, e = this.pointMap; Wu.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse), Xu("c", e, t, Wu, 0, 0, -1), Xu("t", e, t, Wu, 0, 0, 1), Xu("n1", e, t, Wu, -1, -1, -1), Xu("n2", e, t, Wu, 1, -1, -1), Xu("n3", e, t, Wu, -1, 1, -1), Xu("n4", e, t, Wu, 1, 1, -1), Xu("f1", e, t, Wu, -1, -1, 1), Xu("f2", e, t, Wu, 1, -1, 1), Xu("f3", e, t, Wu, -1, 1, 1), Xu("f4", e, t, Wu, 1, 1, 1), Xu("u1", e, t, Wu, .7, 1.1, -1), Xu("u2", e, t, Wu, -.7, 1.1, -1), Xu("u3", e, t, Wu, 0, 2, -1), Xu("cf1", e, t, Wu, -1, 0, 1), Xu("cf2", e, t, Wu, 1, 0, 1), Xu("cf3", e, t, Wu, 0, -1, 1), Xu("cf4", e, t, Wu, 0, 1, 1), Xu("cn1", e, t, Wu, -1, 0, -1), Xu("cn2", e, t, Wu, 1, 0, -1), Xu("cn3", e, t, Wu, 0, -1, -1), Xu("cn4", e, t, Wu, 0, 1, -1), t.getAttribute("position").needsUpdate = !0 }; var Yu = new Pr; function Zu(t, e) { this.object = t, void 0 === e && (e = 16776960); var r = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]), n = new Float32Array(24), i = new In; i.setIndex(new fn(r, 1)), i.setAttribute("position", new fn(n, 3)), ys.call(this, i, new ls({ color: e })), this.matrixAutoUpdate = !1, this.update() } function Ju(t, e) { this.type = "Box3Helper", this.box = t, e = e || 16776960; var r = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]), n = new In; n.setIndex(new fn(r, 1)), n.setAttribute("position", new _n([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1], 3)), ys.call(this, n, new ls({ color: e })), this.geometry.computeBoundingSphere() } function Ku(t, e, r) { this.type = "PlaneHelper", this.plane = t, this.size = void 0 === e ? 1 : e; var n = void 0 !== r ? r : 16776960, i = new In; i.setAttribute("position", new _n([1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0], 3)), i.computeBoundingSphere(), ms.call(this, i, new ls({ color: n })); var o = new In; o.setAttribute("position", new _n([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1], 3)), o.computeBoundingSphere(), this.add(new Kn(o, new dn({ color: n, opacity: .2, transparent: !0, depthWrite: !1 }))) } Zu.prototype = Object.create(ys.prototype), Zu.prototype.constructor = Zu, Zu.prototype.update = function (t) { if (void 0 !== t && console.warn("THREE.BoxHelper: .update() has no longer arguments."), void 0 !== this.object && Yu.setFromObject(this.object), !Yu.isEmpty()) { var e = Yu.min, r = Yu.max, n = this.geometry.attributes.position, i = n.array; i[0] = r.x, i[1] = r.y, i[2] = r.z, i[3] = e.x, i[4] = r.y, i[5] = r.z, i[6] = e.x, i[7] = e.y, i[8] = r.z, i[9] = r.x, i[10] = e.y, i[11] = r.z, i[12] = r.x, i[13] = r.y, i[14] = e.z, i[15] = e.x, i[16] = r.y, i[17] = e.z, i[18] = e.x, i[19] = e.y, i[20] = e.z, i[21] = r.x, i[22] = e.y, i[23] = e.z, n.needsUpdate = !0, this.geometry.computeBoundingSphere() } }, Zu.prototype.setFromObject = function (t) { return this.object = t, this.update(), this }, Zu.prototype.copy = function (t) { return ys.prototype.copy.call(this, t), this.object = t.object, this }, Zu.prototype.clone = function () { return (new this.constructor).copy(this) }, Ju.prototype = Object.create(ys.prototype), Ju.prototype.constructor = Ju, Ju.prototype.updateMatrixWorld = function (t) { var e = this.box; e.isEmpty() || (e.getCenter(this.position), e.getSize(this.scale), this.scale.multiplyScalar(.5), fr.prototype.updateMatrixWorld.call(this, t)) }, Ku.prototype = Object.create(ms.prototype), Ku.prototype.constructor = Ku, Ku.prototype.updateMatrixWorld = function (t) { var e = -this.plane.constant; Math.abs(e) < 1e-8 && (e = 1e-8), this.scale.set(.5 * this.size, .5 * this.size, e), this.children[0].material.side = e < 0 ? h : l, this.lookAt(this.plane.normal), fr.prototype.updateMatrixWorld.call(this, t) }; var Qu, $u, tp = new Ie; function ep(t, e, r, n, i, o) { fr.call(this), void 0 === t && (t = new Ie(0, 0, 1)), void 0 === e && (e = new Ie(0, 0, 0)), void 0 === r && (r = 1), void 0 === n && (n = 16776960), void 0 === i && (i = .2 * r), void 0 === o && (o = .2 * i), void 0 === Qu && ((Qu = new In).setAttribute("position", new _n([0, 0, 0, 0, 1, 0], 3)), ($u = new Uc(0, .5, 1, 5, 1)).translate(0, -.5, 0)), this.position.copy(e), this.line = new ms(Qu, new ls({ color: n })), this.line.matrixAutoUpdate = !1, this.add(this.line), this.cone = new Kn($u, new dn({ color: n })), this.cone.matrixAutoUpdate = !1, this.add(this.cone), this.setDirection(t), this.setLength(r, i, o) } function rp(t) { var e = [0, 0, 0, t = t || 1, 0, 0, 0, 0, 0, 0, t, 0, 0, 0, 0, 0, 0, t], r = new In; r.setAttribute("position", new _n(e, 3)), r.setAttribute("color", new _n([1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1], 3)); var n = new ls({ vertexColors: f }); ys.call(this, r, n) } ep.prototype = Object.create(fr.prototype), ep.prototype.constructor = ep, ep.prototype.setDirection = function (t) { if (t.y > .99999) this.quaternion.set(0, 0, 0, 1); else if (t.y < -.99999) this.quaternion.set(1, 0, 0, 0); else { tp.set(t.z, 0, -t.x).normalize(); var e = Math.acos(t.y); this.quaternion.setFromAxisAngle(tp, e) } }, ep.prototype.setLength = function (t, e, r) { void 0 === e && (e = .2 * t), void 0 === r && (r = .2 * e), this.line.scale.set(1, Math.max(1e-4, t - e), 1), this.line.updateMatrix(), this.cone.scale.set(r, e, r), this.cone.position.y = t, this.cone.updateMatrix() }, ep.prototype.setColor = function (t) { this.line.material.color.set(t), this.cone.material.color.set(t) }, ep.prototype.copy = function (t) { return fr.prototype.copy.call(this, t, !1), this.line.copy(t.line), this.cone.copy(t.cone), this }, ep.prototype.clone = function () { return (new this.constructor).copy(this) }, rp.prototype = Object.create(ys.prototype), rp.prototype.constructor = rp; function np(t) { console.warn("THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead."), zl.call(this, t), this.type = "catmullrom" } Ll.create = function (t, e) { return console.log("THREE.Curve.create() has been deprecated"), t.prototype = Object.create(Ll.prototype), t.prototype.constructor = t, t.prototype.getPoint = e, t }, Object.assign(Yl.prototype, { createPointsGeometry: function (t) { console.warn("THREE.CurvePath: .createPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead."); var e = this.getPoints(t); return this.createGeometry(e) }, createSpacedPointsGeometry: function (t) { console.warn("THREE.CurvePath: .createSpacedPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead."); var e = this.getSpacedPoints(t); return this.createGeometry(e) }, createGeometry: function (t) { console.warn("THREE.CurvePath: .createGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead."); for (var e = new ii, r = 0, n = t.length; r < n; r++) { var i = t[r]; e.vertices.push(new Ie(i.x, i.y, i.z || 0)) } return e } }), Object.assign(Zl.prototype, { fromPoints: function (t) { return console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints()."), this.setFromPoints(t) } }), Object.create(zl.prototype), Object.create(zl.prototype), np.prototype = Object.create(zl.prototype), Object.assign(np.prototype, { initFromArray: function () { console.error("THREE.Spline: .initFromArray() has been removed.") }, getControlPointsArray: function () { console.error("THREE.Spline: .getControlPointsArray() has been removed.") }, reparametrizeByArcLength: function () { console.error("THREE.Spline: .reparametrizeByArcLength() has been removed.") } }), Iu.prototype.setColors = function () { console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.") }, Tu.prototype.update = function () { console.error("THREE.SkeletonHelper: update() no longer needs to be called.") }, Object.assign(xl.prototype, { extractUrlBase: function (t) { return console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."), hh.extractUrlBase(t) } }), xl.Handlers = { add: function () { console.error("THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.") }, get: function () { console.error("THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.") } }, Object.assign(mh.prototype, { setTexturePath: function (t) { return console.warn("THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath()."), this.setResourcePath(t) } }), Object.assign(hu.prototype, { center: function (t) { return console.warn("THREE.Box2: .center() has been renamed to .getCenter()."), this.getCenter(t) }, empty: function () { return console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."), this.isEmpty() }, isIntersectionBox: function (t) { return console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t) }, size: function (t) { return console.warn("THREE.Box2: .size() has been renamed to .getSize()."), this.getSize(t) } }), Object.assign(Pr.prototype, { center: function (t) { return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."), this.getCenter(t) }, empty: function () { return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."), this.isEmpty() }, isIntersectionBox: function (t) { return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t) }, isIntersectionSphere: function (t) { return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(t) }, size: function (t) { return console.warn("THREE.Box3: .size() has been renamed to .getSize()."), this.getSize(t) } }), du.prototype.center = function (t) { return console.warn("THREE.Line3: .center() has been renamed to .getCenter()."), this.getCenter(t) }, Object.assign(Le, { random16: function () { return console.warn("THREE.Math: .random16() has been deprecated. Use Math.random() instead."), Math.random() }, nearestPowerOfTwo: function (t) { return console.warn("THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo()."), Le.floorPowerOfTwo(t) }, nextPowerOfTwo: function (t) { return console.warn("THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo()."), Le.ceilPowerOfTwo(t) } }), Object.assign(ze.prototype, { flattenToArrayOffset: function (t, e) { return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(t, e) }, multiplyVector3: function (t) { return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."), t.applyMatrix3(this) }, multiplyVector3Array: function () { console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.") }, applyToBuffer: function (t) { return console.warn("THREE.Matrix3: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead."), this.applyToBufferAttribute(t) }, applyToVector3Array: function () { console.error("THREE.Matrix3: .applyToVector3Array() has been removed.") } }), Object.assign(Je.prototype, { extractPosition: function (t) { return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."), this.copyPosition(t) }, flattenToArrayOffset: function (t, e) { return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(t, e) }, getPosition: function () { return console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."), (new Ie).setFromMatrixColumn(this, 3) }, setRotationFromQuaternion: function (t) { return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."), this.makeRotationFromQuaternion(t) }, multiplyToArray: function () { console.warn("THREE.Matrix4: .multiplyToArray() has been removed.") }, multiplyVector3: function (t) { return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."), t.applyMatrix4(this) }, multiplyVector4: function (t) { return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."), t.applyMatrix4(this) }, multiplyVector3Array: function () { console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.") }, rotateAxis: function (t) { console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."), t.transformDirection(this) }, crossVector: function (t) { return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."), t.applyMatrix4(this) }, translate: function () { console.error("THREE.Matrix4: .translate() has been removed.") }, rotateX: function () { console.error("THREE.Matrix4: .rotateX() has been removed.") }, rotateY: function () { console.error("THREE.Matrix4: .rotateY() has been removed.") }, rotateZ: function () { console.error("THREE.Matrix4: .rotateZ() has been removed.") }, rotateByAxis: function () { console.error("THREE.Matrix4: .rotateByAxis() has been removed.") }, applyToBuffer: function (t) { return console.warn("THREE.Matrix4: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead."), this.applyToBufferAttribute(t) }, applyToVector3Array: function () { console.error("THREE.Matrix4: .applyToVector3Array() has been removed.") }, makeFrustum: function (t, e, r, n, i, o) { return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."), this.makePerspective(t, e, n, r, i, o) } }), Hr.prototype.isIntersectionLine = function (t) { return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."), this.intersectsLine(t) }, Re.prototype.multiplyVector3 = function (t) { return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."), t.applyQuaternion(this) }, Object.assign(kr.prototype, { isIntersectionBox: function (t) { return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t) }, isIntersectionPlane: function (t) { return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."), this.intersectsPlane(t) }, isIntersectionSphere: function (t) { return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(t) } }), Object.assign(en.prototype, { area: function () { return console.warn("THREE.Triangle: .area() has been renamed to .getArea()."), this.getArea() }, barycoordFromPoint: function (t, e) { return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), this.getBarycoord(t, e) }, midpoint: function (t) { return console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."), this.getMidpoint(t) }, normal: function (t) { return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), this.getNormal(t) }, plane: function (t) { return console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."), this.getPlane(t) } }), Object.assign(en, { barycoordFromPoint: function (t, e, r, n, i) { return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), en.getBarycoord(t, e, r, n, i) }, normal: function (t, e, r, n) { return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), en.getNormal(t, e, r, n) } }), Object.assign(Jl.prototype, { extractAllPoints: function (t) { return console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."), this.extractPoints(t) }, extrude: function (t) { return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."), new wc(this, t) }, makeGeometry: function (t) { return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."), new Ic(this, t) } }), Object.assign(Pe.prototype, { fromAttribute: function (t, e, r) { return console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t, e, r) }, distanceToManhattan: function (t) { return console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(t) }, lengthManhattan: function () { return console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength() } }), Object.assign(Ie.prototype, { setEulerFromRotationMatrix: function () { console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.") }, setEulerFromQuaternion: function () { console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.") }, getPositionFromMatrix: function (t) { return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."), this.setFromMatrixPosition(t) }, getScaleFromMatrix: function (t) { return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."), this.setFromMatrixScale(t) }, getColumnFromMatrix: function (t, e) { return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."), this.setFromMatrixColumn(e, t) }, applyProjection: function (t) { return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."), this.applyMatrix4(t) }, fromAttribute: function (t, e, r) { return console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t, e, r) }, distanceToManhattan: function (t) { return console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(t) }, lengthManhattan: function () { return console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength() } }), Object.assign(ke.prototype, { fromAttribute: function (t, e, r) { return console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t, e, r) }, lengthManhattan: function () { return console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength() } }), Object.assign(ii.prototype, { computeTangents: function () { console.error("THREE.Geometry: .computeTangents() has been removed.") }, computeLineDistances: function () { console.error("THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.") } }), Object.assign(fr.prototype, { getChildByName: function (t) { return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."), this.getObjectByName(t) }, renderDepth: function () { console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.") }, translate: function (t, e) { return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."), this.translateOnAxis(e, t) }, getWorldRotation: function () { console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.") } }), Object.defineProperties(fr.prototype, { eulerOrder: { get: function () { return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order }, set: function (t) { console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order = t } }, useQuaternion: { get: function () { console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.") }, set: function () { console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.") } } }), Object.defineProperties(Qa.prototype, { objects: { get: function () { return console.warn("THREE.LOD: .objects has been renamed to .levels."), this.levels } } }), Object.defineProperty(rs.prototype, "useVertexTexture", { get: function () { console.warn("THREE.Skeleton: useVertexTexture has been removed.") }, set: function () { console.warn("THREE.Skeleton: useVertexTexture has been removed.") } }), $a.prototype.initBones = function () { console.error("THREE.SkinnedMesh: initBones() has been removed.") }, Object.defineProperty(Ll.prototype, "__arcLengthDivisions", { get: function () { return console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."), this.arcLengthDivisions }, set: function (t) { console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."), this.arcLengthDivisions = t } }), pi.prototype.setLens = function (t, e) { console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."), void 0 !== e && (this.filmGauge = e), this.setFocalLength(t) }, Object.defineProperties(Kl.prototype, { onlyShadow: { set: function () { console.warn("THREE.Light: .onlyShadow has been removed.") } }, shadowCameraFov: { set: function (t) { console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."), this.shadow.camera.fov = t } }, shadowCameraLeft: { set: function (t) { console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."), this.shadow.camera.left = t } }, shadowCameraRight: { set: function (t) { console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."), this.shadow.camera.right = t } }, shadowCameraTop: { set: function (t) { console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."), this.shadow.camera.top = t } }, shadowCameraBottom: { set: function (t) { console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."), this.shadow.camera.bottom = t } }, shadowCameraNear: { set: function (t) { console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."), this.shadow.camera.near = t } }, shadowCameraFar: { set: function (t) { console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."), this.shadow.camera.far = t } }, shadowCameraVisible: { set: function () { console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.") } }, shadowBias: { set: function (t) { console.warn("THREE.Light: .shadowBias is now .shadow.bias."), this.shadow.bias = t } }, shadowDarkness: { set: function () { console.warn("THREE.Light: .shadowDarkness has been removed.") } }, shadowMapWidth: { set: function (t) { console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."), this.shadow.mapSize.width = t } }, shadowMapHeight: { set: function (t) { console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."), this.shadow.mapSize.height = t } } }), Object.defineProperties(fn.prototype, { length: { get: function () { return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."), this.array.length } }, dynamic: { get: function () { return console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."), 35048 === this.usage }, set: function () { console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."), this.setUsage(35048) } } }), Object.assign(fn.prototype, { setDynamic: function (t) { return console.warn("THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead."), this.setUsage(!0 === t ? 35048 : Se), this }, copyIndicesArray: function () { console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.") }, setArray: function () { console.error("THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers") } }), Object.assign(In.prototype, { addIndex: function (t) { console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."), this.setIndex(t) }, addAttribute: function (t, e) { return console.warn("THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute()."), e && e.isBufferAttribute || e && e.isInterleavedBufferAttribute ? "index" === t ? (console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."), this.setIndex(e), this) : this.setAttribute(t, e) : (console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."), this.setAttribute(t, new fn(arguments[1], arguments[2]))) }, addDrawCall: function (t, e, r) { void 0 !== r && console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."), console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."), this.addGroup(t, e) }, clearDrawCalls: function () { console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."), this.clearGroups() }, computeTangents: function () { console.warn("THREE.BufferGeometry: .computeTangents() has been removed.") }, computeOffsets: function () { console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.") }, removeAttribute: function (t) { return console.warn("THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute()."), this.deleteAttribute(t) } }), Object.defineProperties(In.prototype, { drawcalls: { get: function () { return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."), this.groups } }, offsets: { get: function () { return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."), this.groups } } }), Object.defineProperties(Ia.prototype, { dynamic: { get: function () { return console.warn("THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead."), 35048 === this.usage }, set: function (t) { console.warn("THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead."), this.setUsage(t) } } }), Object.assign(Ia.prototype, { setDynamic: function (t) { return console.warn("THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead."), this.setUsage(!0 === t ? 35048 : Se), this }, setArray: function () { console.error("THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers") } }), Object.assign(_c.prototype, { getArrays: function () { console.error("THREE.ExtrudeBufferGeometry: .getArrays() has been removed.") }, addShapeList: function () { console.error("THREE.ExtrudeBufferGeometry: .addShapeList() has been removed.") }, addShape: function () { console.error("THREE.ExtrudeBufferGeometry: .addShape() has been removed.") } }), Object.defineProperties(ou.prototype, { dynamic: { set: function () { console.warn("THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.") } }, onUpdate: { value: function () { return console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."), this } } }), Object.defineProperties(pn.prototype, { wrapAround: { get: function () { console.warn("THREE.Material: .wrapAround has been removed.") }, set: function () { console.warn("THREE.Material: .wrapAround has been removed.") } }, overdraw: { get: function () { console.warn("THREE.Material: .overdraw has been removed.") }, set: function () { console.warn("THREE.Material: .overdraw has been removed.") } }, wrapRGB: { get: function () { return console.warn("THREE.Material: .wrapRGB has been removed."), new an } }, shading: { get: function () { console.error("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.") }, set: function (t) { console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = 1 === t } }, stencilMask: { get: function () { return console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead."), this.stencilFuncMask }, set: function (t) { console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead."), this.stencilFuncMask = t } } }), Object.defineProperties(Yc.prototype, { metal: { get: function () { return console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead."), !1 }, set: function () { console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead") } } }), Object.defineProperties(hi.prototype, { derivatives: { get: function () { return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives }, set: function (t) { console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives = t } } }), Object.assign(Ra.prototype, { clearTarget: function (t, e, r, n) { console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."), this.setRenderTarget(t), this.clear(e, r, n) }, animate: function (t) { console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."), this.setAnimationLoop(t) }, getCurrentRenderTarget: function () { return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."), this.getRenderTarget() }, getMaxAnisotropy: function () { return console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."), this.capabilities.getMaxAnisotropy() }, getPrecision: function () { return console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."), this.capabilities.precision }, resetGLState: function () { return console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."), this.state.reset() }, supportsFloatTextures: function () { return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."), this.extensions.get("OES_texture_float") }, supportsHalfFloatTextures: function () { return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."), this.extensions.get("OES_texture_half_float") }, supportsStandardDerivatives: function () { return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."), this.extensions.get("OES_standard_derivatives") }, supportsCompressedTextureS3TC: function () { return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."), this.extensions.get("WEBGL_compressed_texture_s3tc") }, supportsCompressedTexturePVRTC: function () { return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."), this.extensions.get("WEBGL_compressed_texture_pvrtc") }, supportsBlendMinMax: function () { return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."), this.extensions.get("EXT_blend_minmax") }, supportsVertexTextures: function () { return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."), this.capabilities.vertexTextures }, supportsInstancedArrays: function () { return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."), this.extensions.get("ANGLE_instanced_arrays") }, enableScissorTest: function (t) { console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."), this.setScissorTest(t) }, initMaterial: function () { console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.") }, addPrePlugin: function () { console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.") }, addPostPlugin: function () { console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.") }, updateShadowMap: function () { console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.") }, setFaceCulling: function () { console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.") }, allocTextureUnit: function () { console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.") }, setTexture: function () { console.warn("THREE.WebGLRenderer: .setTexture() has been removed.") }, setTexture2D: function () { console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.") }, setTextureCube: function () { console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.") }, getActiveMipMapLevel: function () { return console.warn("THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel()."), this.getActiveMipmapLevel() } }), Object.defineProperties(Ra.prototype, { shadowMapEnabled: { get: function () { return this.shadowMap.enabled }, set: function (t) { console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."), this.shadowMap.enabled = t } }, shadowMapType: { get: function () { return this.shadowMap.type }, set: function (t) { console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."), this.shadowMap.type = t } }, shadowMapCullFace: { get: function () { console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.") }, set: function () { console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.") } }, context: { get: function () { return console.warn("THREE.WebGLRenderer: .context has been removed. Use .getContext() instead."), this.getContext() } } }), Object.defineProperties(va.prototype, { cullFace: { get: function () { console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.") }, set: function () { console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.") } }, renderReverseSided: { get: function () { console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.") }, set: function () { console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.") } }, renderSingleSided: { get: function () { console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.") }, set: function () { console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.") } } }), Object.defineProperties(vi.prototype, { activeCubeFace: { set: function () { console.warn("THREE.WebGLRenderTargetCube: .activeCubeFace has been removed. It is now the second parameter of WebGLRenderer.setRenderTarget().") } }, activeMipMapLevel: { set: function () { console.warn("THREE.WebGLRenderTargetCube: .activeMipMapLevel has been removed. It is now the third parameter of WebGLRenderer.setRenderTarget().") } } }), Object.defineProperties(je.prototype, { wrapS: { get: function () { return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS }, set: function (t) { console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS = t } }, wrapT: { get: function () { return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT }, set: function (t) { console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT = t } }, magFilter: { get: function () { return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter }, set: function (t) { console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter = t } }, minFilter: { get: function () { return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter }, set: function (t) { console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter = t } }, anisotropy: { get: function () { return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy }, set: function (t) { console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy = t } }, offset: { get: function () { return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset }, set: function (t) { console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset = t } }, repeat: { get: function () { return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat }, set: function (t) { console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat = t } }, format: { get: function () { return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format }, set: function (t) { console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format = t } }, type: { get: function () { return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type }, set: function (t) { console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type = t } }, generateMipmaps: { get: function () { return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps }, set: function (t) { console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps = t } } }), Object.defineProperties(La.prototype, { standing: { set: function () { console.warn("THREE.WebVRManager: .standing has been removed.") } }, userHeight: { set: function () { console.warn("THREE.WebVRManager: .userHeight has been removed.") } } }), Object.defineProperties(Bh.prototype, { load: { value: function (t) { console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead."); var e = this; return (new Eh).load(t, (function (t) { e.setBuffer(t) })), this } }, startTime: { set: function () { console.warn("THREE.Audio: .startTime is now .play( delay ).") } } }), Wh.prototype.getData = function () { return console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData()."), this.getFrequencyData() }, mi.prototype.updateCubeMap = function (t, e) { return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."), this.update(t, e) }; Fe.crossOrigin = void 0, Fe.loadTexture = function (t, e, r, n) { console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead."); var i = new Al; i.setCrossOrigin(this.crossOrigin); var o = i.load(t, r, void 0, n); return e && (o.mapping = e), o }, Fe.loadTextureCube = function (t, e, r, n) { console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead."); var i = new El; i.setCrossOrigin(this.crossOrigin); var o = i.load(t, r, void 0, n); return e && (o.mapping = e), o }, Fe.loadCompressedTexture = function () { console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.") }, Fe.loadCompressedTextureCube = function () { console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.") }; "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", { detail: { revision: "111" } })) }, Wr5T: function (t, e) { !function () { "use strict"; if ("object" == typeof window) if ("IntersectionObserver" in window && "IntersectionObserverEntry" in window && "intersectionRatio" in window.IntersectionObserverEntry.prototype) "isIntersecting" in window.IntersectionObserverEntry.prototype || Object.defineProperty(window.IntersectionObserverEntry.prototype, "isIntersecting", { get: function () { return this.intersectionRatio > 0 } }); else { var t = window.document, e = []; n.prototype.THROTTLE_TIMEOUT = 100, n.prototype.POLL_INTERVAL = null, n.prototype.USE_MUTATION_OBSERVER = !0, n.prototype.observe = function (t) { if (!this._observationTargets.some((function (e) { return e.element == t }))) { if (!t || 1 != t.nodeType) throw new Error("target must be an Element"); this._registerInstance(), this._observationTargets.push({ element: t, entry: null }), this._monitorIntersections(), this._checkForIntersections() } }, n.prototype.unobserve = function (t) { this._observationTargets = this._observationTargets.filter((function (e) { return e.element != t })), this._observationTargets.length || (this._unmonitorIntersections(), this._unregisterInstance()) }, n.prototype.disconnect = function () { this._observationTargets = [], this._unmonitorIntersections(), this._unregisterInstance() }, n.prototype.takeRecords = function () { var t = this._queuedEntries.slice(); return this._queuedEntries = [], t }, n.prototype._initThresholds = function (t) { var e = t || [0]; return Array.isArray(e) || (e = [e]), e.sort().filter((function (t, e, r) { if ("number" != typeof t || isNaN(t) || t < 0 || t > 1) throw new Error("threshold must be a number between 0 and 1 inclusively"); return t !== r[e - 1] })) }, n.prototype._parseRootMargin = function (t) { var e = (t || "0px").split(/\s+/).map((function (t) { var e = /^(-?\d*\.?\d+)(px|%)$/.exec(t); if (!e) throw new Error("rootMargin must be specified in pixels or percent"); return { value: parseFloat(e[1]), unit: e[2] } })); return e[1] = e[1] || e[0], e[2] = e[2] || e[0], e[3] = e[3] || e[1], e }, n.prototype._monitorIntersections = function () { this._monitoringIntersections || (this._monitoringIntersections = !0, this.POLL_INTERVAL ? this._monitoringInterval = setInterval(this._checkForIntersections, this.POLL_INTERVAL) : (i(window, "resize", this._checkForIntersections, !0), i(t, "scroll", this._checkForIntersections, !0), this.USE_MUTATION_OBSERVER && "MutationObserver" in window && (this._domObserver = new MutationObserver(this._checkForIntersections), this._domObserver.observe(t, { attributes: !0, childList: !0, characterData: !0, subtree: !0 })))) }, n.prototype._unmonitorIntersections = function () { this._monitoringIntersections && (this._monitoringIntersections = !1, clearInterval(this._monitoringInterval), this._monitoringInterval = null, o(window, "resize", this._checkForIntersections, !0), o(t, "scroll", this._checkForIntersections, !0), this._domObserver && (this._domObserver.disconnect(), this._domObserver = null)) }, n.prototype._checkForIntersections = function () { var t = this._rootIsInDom(), e = t ? this._getRootRect() : { top: 0, bottom: 0, left: 0, right: 0, width: 0, height: 0 }; this._observationTargets.forEach((function (n) { var i = n.element, o = a(i), s = this._rootContainsTarget(i), c = n.entry, l = t && s && this._computeTargetAndRootIntersection(i, e), h = n.entry = new r({ time: window.performance && performance.now && performance.now(), target: i, boundingClientRect: o, rootBounds: e, intersectionRect: l }); c ? t && s ? this._hasCrossedThreshold(c, h) && this._queuedEntries.push(h) : c && c.isIntersecting && this._queuedEntries.push(h) : this._queuedEntries.push(h) }), this), this._queuedEntries.length && this._callback(this.takeRecords(), this) }, n.prototype._computeTargetAndRootIntersection = function (e, r) { if ("none" != window.getComputedStyle(e).display) { for (var n, i, o, s, l, h, u, p, d = a(e), f = c(e), m = !1; !m;) { var v = null, g = 1 == f.nodeType ? window.getComputedStyle(f) : {}; if ("none" == g.display) return; if (f == this.root || f == t ? (m = !0, v = r) : f != t.body && f != t.documentElement && "visible" != g.overflow && (v = a(f)), v && (n = v, i = d, o = void 0, s = void 0, l = void 0, h = void 0, u = void 0, p = void 0, o = Math.max(n.top, i.top), s = Math.min(n.bottom, i.bottom), l = Math.max(n.left, i.left), h = Math.min(n.right, i.right), p = s - o, !(d = (u = h - l) >= 0 && p >= 0 && { top: o, bottom: s, left: l, right: h, width: u, height: p }))) break; f = c(f) } return d } }, n.prototype._getRootRect = function () { var e; if (this.root) e = a(this.root); else { var r = t.documentElement, n = t.body; e = { top: 0, left: 0, right: r.clientWidth || n.clientWidth, width: r.clientWidth || n.clientWidth, bottom: r.clientHeight || n.clientHeight, height: r.clientHeight || n.clientHeight } } return this._expandRectByRootMargin(e) }, n.prototype._expandRectByRootMargin = function (t) { var e = this._rootMarginValues.map((function (e, r) { return "px" == e.unit ? e.value : e.value * (r % 2 ? t.width : t.height) / 100 })), r = { top: t.top - e[0], right: t.right + e[1], bottom: t.bottom + e[2], left: t.left - e[3] }; return r.width = r.right - r.left, r.height = r.bottom - r.top, r }, n.prototype._hasCrossedThreshold = function (t, e) { var r = t && t.isIntersecting ? t.intersectionRatio || 0 : -1, n = e.isIntersecting ? e.intersectionRatio || 0 : -1; if (r !== n) for (var i = 0; i < this.thresholds.length; i++) { var o = this.thresholds[i]; if (o == r || o == n || o < r != o < n) return !0 } }, n.prototype._rootIsInDom = function () { return !this.root || s(t, this.root) }, n.prototype._rootContainsTarget = function (e) { return s(this.root || t, e) }, n.prototype._registerInstance = function () { e.indexOf(this) < 0 && e.push(this) }, n.prototype._unregisterInstance = function () { var t = e.indexOf(this); -1 != t && e.splice(t, 1) }, window.IntersectionObserver = n, window.IntersectionObserverEntry = r } function r(t) { this.time = t.time, this.target = t.target, this.rootBounds = t.rootBounds, this.boundingClientRect = t.boundingClientRect, this.intersectionRect = t.intersectionRect || { top: 0, bottom: 0, left: 0, right: 0, width: 0, height: 0 }, this.isIntersecting = !!t.intersectionRect; var e = this.boundingClientRect, r = e.width * e.height, n = this.intersectionRect, i = n.width * n.height; this.intersectionRatio = r ? Number((i / r).toFixed(4)) : this.isIntersecting ? 1 : 0 } function n(t, e) { var r, n, i, o = e || {}; if ("function" != typeof t) throw new Error("callback must be a function"); if (o.root && 1 != o.root.nodeType) throw new Error("root must be an Element"); this._checkForIntersections = (r = this._checkForIntersections.bind(this), n = this.THROTTLE_TIMEOUT, i = null, function () { i || (i = setTimeout((function () { r(), i = null }), n)) }), this._callback = t, this._observationTargets = [], this._queuedEntries = [], this._rootMarginValues = this._parseRootMargin(o.rootMargin), this.thresholds = this._initThresholds(o.threshold), this.root = o.root || null, this.rootMargin = this._rootMarginValues.map((function (t) { return t.value + t.unit })).join(" ") } function i(t, e, r, n) { "function" == typeof t.addEventListener ? t.addEventListener(e, r, n || !1) : "function" == typeof t.attachEvent && t.attachEvent("on" + e, r) } function o(t, e, r, n) { "function" == typeof t.removeEventListener ? t.removeEventListener(e, r, n || !1) : "function" == typeof t.detatchEvent && t.detatchEvent("on" + e, r) } function a(t) { var e; try { e = t.getBoundingClientRect() } catch (t) { } return e ? (e.width && e.height || (e = { top: e.top, right: e.right, bottom: e.bottom, left: e.left, width: e.right - e.left, height: e.bottom - e.top }), e) : { top: 0, bottom: 0, left: 0, right: 0, width: 0, height: 0 } } function s(t, e) { for (var r = e; r;) { if (r == t) return !0; r = c(r) } return !1 } function c(t) { var e = t.parentNode; return e && 11 == e.nodeType && e.host ? e.host : e && e.assignedSlot ? e.assignedSlot.parentNode : e } }() }, "hKI/": function (t, e, r) { (function (e) { var r = "Expected a function", n = NaN, i = "[object Symbol]", o = /^\s+|\s+$/g, a = /^[-+]0x[0-9a-f]+$/i, s = /^0b[01]+$/i, c = /^0o[0-7]+$/i, l = parseInt, h = "object" == typeof e && e && e.Object === Object && e, u = "object" == typeof self && self && self.Object === Object && self, p = h || u || Function("return this")(), d = Object.prototype.toString, f = Math.max, m = Math.min, v = function () { return p.Date.now() }; function g(t, e, n) { var i, o, a, s, c, l, h = 0, u = !1, p = !1, d = !0; if ("function" != typeof t) throw new TypeError(r); function g(e) { var r = i, n = o; return i = o = void 0, h = e, s = t.apply(n, r) } function b(t) { var r = t - l; return void 0 === l || r >= e || r < 0 || p && t - h >= a } function w() { var t = v(); if (b(t)) return _(t); c = setTimeout(w, function (t) { var r = e - (t - l); return p ? m(r, a - (t - h)) : r }(t)) } function _(t) { return c = void 0, d && i ? g(t) : (i = o = void 0, s) } function M() { var t = v(), r = b(t); if (i = arguments, o = this, l = t, r) { if (void 0 === c) return function (t) { return h = t, c = setTimeout(w, e), u ? g(t) : s }(l); if (p) return c = setTimeout(w, e), g(l) } return void 0 === c && (c = setTimeout(w, e)), s } return e = x(e) || 0, y(n) && (u = !!n.leading, a = (p = "maxWait" in n) ? f(x(n.maxWait) || 0, e) : a, d = "trailing" in n ? !!n.trailing : d), M.cancel = function () { void 0 !== c && clearTimeout(c), h = 0, i = l = o = c = void 0 }, M.flush = function () { return void 0 === c ? s : _(v()) }, M } function y(t) { var e = typeof t; return !!t && ("object" == e || "function" == e) } function x(t) { if ("number" == typeof t) return t; if (function (t) { return "symbol" == typeof t || function (t) { return !!t && "object" == typeof t }(t) && d.call(t) == i }(t)) return n; if (y(t)) { var e = "function" == typeof t.valueOf ? t.valueOf() : t; t = y(e) ? e + "" : e } if ("string" != typeof t) return 0 === t ? t : +t; t = t.replace(o, ""); var r = s.test(t); return r || c.test(t) ? l(t.slice(2), r ? 2 : 8) : a.test(t) ? n : +t } t.exports = function (t, e, n) { var i = !0, o = !0; if ("function" != typeof t) throw new TypeError(r); return y(n) && (i = "leading" in n ? !!n.leading : i, o = "trailing" in n ? !!n.trailing : o), g(t, e, { leading: i, maxWait: e, trailing: o }) } }).call(this, r("yLpj")) }, he0O: function (t, e, r) { "use strict"; function n() { if (!(this instanceof n)) return new n; this.size = 0, this.uid = 0, this.selectors = [], this.selectorObjects = {}, this.indexes = Object.create(this.indexes), this.activeIndexes = [] } var i = window.document.documentElement, o = i.matches || i.webkitMatchesSelector || i.mozMatchesSelector || i.oMatchesSelector || i.msMatchesSelector; n.prototype.matchesSelector = function (t, e) { return o.call(t, e) }, n.prototype.querySelectorAll = function (t, e) { return e.querySelectorAll(t) }, n.prototype.indexes = []; var a = /^#((?:[\w\u00c0-\uFFFF\-]|\\.)+)/g; n.prototype.indexes.push({ name: "ID", selector: function (t) { var e; if (e = t.match(a)) return e[0].slice(1) }, element: function (t) { if (t.id) return [t.id] } }); var s = /^\.((?:[\w\u00c0-\uFFFF\-]|\\.)+)/g; n.prototype.indexes.push({ name: "CLASS", selector: function (t) { var e; if (e = t.match(s)) return e[0].slice(1) }, element: function (t) { var e = t.className; if (e) { if ("string" == typeof e) return e.split(/\s/); if ("object" == typeof e && "baseVal" in e) return e.baseVal.split(/\s/) } } }); var c, l = /^((?:[\w\u00c0-\uFFFF\-]|\\.)+)/g; n.prototype.indexes.push({ name: "TAG", selector: function (t) { var e; if (e = t.match(l)) return e[0].toUpperCase() }, element: function (t) { return [t.nodeName.toUpperCase()] } }), n.prototype.indexes.default = { name: "UNIVERSAL", selector: function () { return !0 }, element: function () { return [!0] } }, c = "function" == typeof window.Map ? window.Map : function () { function t() { this.map = {} } return t.prototype.get = function (t) { return this.map[t + " "] }, t.prototype.set = function (t, e) { this.map[t + " "] = e }, t }(); var h = /((?:\((?:\([^()]+\)|[^()]+)+\)|\[(?:\[[^\[\]]*\]|['"][^'"]*['"]|[^\[\]'"]+)+\]|\\.|[^ >+~,(\[\\]+)+|[>+~])(\s*,\s*)?((?:.|\r|\n)*)/g; function u(t, e) { var r, n, i, o, a, s, c = (t = t.slice(0).concat(t.default)).length, l = e, u = []; do { if (h.exec(""), (i = h.exec(l)) && (l = i[3], i[2] || !l)) for (r = 0; r < c; r++)if (a = (s = t[r]).selector(i[1])) { for (n = u.length, o = !1; n--;)if (u[n].index === s && u[n].key === a) { o = !0; break } o || u.push({ index: s, key: a }); break } } while (i); return u } function p(t, e) { var r, n, i; for (r = 0, n = t.length; r < n; r++)if (i = t[r], e.isPrototypeOf(i)) return i } function d(t, e) { return t.id - e.id } n.prototype.logDefaultIndexUsed = function () { }, n.prototype.add = function (t, e) { var r, n, i, o, a, s, l, h, d = this.activeIndexes, f = this.selectors, m = this.selectorObjects; if ("string" == typeof t) { for (m[(r = { id: this.uid++, selector: t, data: e }).id] = r, l = u(this.indexes, t), n = 0; n < l.length; n++)o = (h = l[n]).key, (a = p(d, i = h.index)) || ((a = Object.create(i)).map = new c, d.push(a)), i === this.indexes.default && this.logDefaultIndexUsed(r), (s = a.map.get(o)) || (s = [], a.map.set(o, s)), s.push(r); this.size++, f.push(t) } }, n.prototype.remove = function (t, e) { if ("string" == typeof t) { var r, n, i, o, a, s, c, l, h = this.activeIndexes, p = this.selectors = [], d = this.selectorObjects, f = {}, m = 1 === arguments.length; for (r = u(this.indexes, t), i = 0; i < r.length; i++)for (n = r[i], o = h.length; o--;)if (s = h[o], n.index.isPrototypeOf(s)) { if (c = s.map.get(n.key)) for (a = c.length; a--;)(l = c[a]).selector !== t || !m && l.data !== e || (c.splice(a, 1), f[l.id] = !0); break } for (i in f) delete d[i], this.size--; for (i in d) p.push(d[i].selector) } }, n.prototype.queryAll = function (t) { if (!this.selectors.length) return []; var e, r, n, i, o, a, s, c, l = {}, h = [], u = this.querySelectorAll(this.selectors.join(", "), t); for (e = 0, n = u.length; e < n; e++)for (o = u[e], r = 0, i = (a = this.matches(o)).length; r < i; r++)l[(c = a[r]).id] ? s = l[c.id] : (s = { id: c.id, selector: c.selector, data: c.data, elements: [] }, l[c.id] = s, h.push(s)), s.elements.push(o); return h.sort(d) }, n.prototype.matches = function (t) { if (!t) return []; var e, r, n, i, o, a, s, c, l, h, u, p = this.activeIndexes, f = {}, m = []; for (e = 0, i = p.length; e < i; e++)if (c = (s = p[e]).element(t)) for (r = 0, o = c.length; r < o; r++)if (l = s.map.get(c[r])) for (n = 0, a = l.length; n < a; n++)!f[u = (h = l[n]).id] && this.matchesSelector(t, h.selector) && (f[u] = !0, m.push(h)); return m.sort(d) }; const f = {}, m = {}, v = ["mouseenter", "mouseleave"]; function g(t) { void 0 === m[t] && (m[t] = []) } function y(t) { return "string" == typeof t ? document.querySelectorAll(t) : t } function x(t) { let e = function (t, e) { const r = []; let n = e; do { if (1 !== n.nodeType) break; const e = t.matches(n); e.length && r.push({ delegatedTarget: n, stack: e }) } while (n = n.parentElement); return r }(f[t.type], t.target); if (e.length) for (let r = 0; r < e.length; r++)for (let n = 0; n < e[r].stack.length; n++)-1 !== v.indexOf(t.type) ? (b(t, e[r].delegatedTarget), t.target === e[r].delegatedTarget && e[r].stack[n].data(t)) : (b(t, e[r].delegatedTarget), e[r].stack[n].data(t)) } function b(t, e) { Object.defineProperty(t, "currentTarget", { configurable: !0, enumerable: !0, get: () => e }) } function w(t) { return JSON.parse(JSON.stringify(t)) } r.d(e, "a", (function () { return _ })); class _ { bindAll(t, e) { void 0 === e && (e = Object.getOwnPropertyNames(Object.getPrototypeOf(t))); for (let r = 0; r < e.length; r++)t[e[r]] = t[e[r]].bind(t) } on(t, e, r, n) { const i = t.split(" "); for (let t = 0; t < i.length; t++)if ("function" != typeof e || void 0 !== r) if (e.nodeType && 1 === e.nodeType || e === window || e === document) e.addEventListener(i[t], r, n); else { e = y(e); for (let o = 0; o < e.length; o++)e[o].addEventListener(i[t], r, n) } else g(i[t]), m[i[t]].push(e) } delegate(t, e, r) { const i = t.split(" "); for (let t = 0; t < i.length; t++) { let o = f[i[t]]; void 0 === o && (o = new n, f[i[t]] = o, -1 !== v.indexOf(i[t]) ? document.addEventListener(i[t], x, !0) : document.addEventListener(i[t], x)), o.add(e, r) } } off(t, e, r, n) { const i = t.split(" "); for (let t = 0; t < i.length; t++) { if (void 0 === e) { m[i[t]] = []; continue } if ("function" == typeof e) { g(i[t]); for (let r = 0; r < m[i[t]].length; r++)m[i[t]][r] === e && m[i[t]].splice(r, 1); continue } const o = f[i[t]]; if (void 0 === o || (o.remove(e, r), 0 !== o.size)) if (void 0 === e.removeEventListener) { e = y(e); for (let o = 0; o < e.length; o++)e[o].removeEventListener(i[t], r, n) } else e.removeEventListener(i[t], r, n); else delete f[i[t]], document.removeEventListener(i[t], x) } } emit(t, ...e) { !function (t, e) { if (m[t]) for (let r = 0; r < m[t].length; r++)m[t][r](...e) }(t, e) } debugDelegated() { return w(f) } debugBus() { return w(m) } } }, hxDe: function (t, e, r) { "use strict"; var n = r("Womt"), i = {}, o = void 0, a = i; function s(t, e) { var r, n = t.split("."), i = a; !(n[0] in i) && i.execScript && i.execScript("var " + n[0]); for (; n.length && (r = n.shift());)n.length || e === o ? i = i[r] ? i[r] : i[r] = {} : i[r] = e } var c = "undefined" != typeof Uint8Array && "undefined" != typeof Uint16Array && "undefined" != typeof Uint32Array && "undefined" != typeof DataView; function l(t) { var e, r, n, i, o, a, s, l, h, u, p = t.length, d = 0, f = Number.POSITIVE_INFINITY; for (l = 0; l < p; ++l)t[l] > d && (d = t[l]), t[l] < f && (f = t[l]); for (e = 1 << d, r = new (c ? Uint32Array : Array)(e), n = 1, i = 0, o = 2; n <= d;) { for (l = 0; l < p; ++l)if (t[l] === n) { for (a = 0, s = i, h = 0; h < n; ++h)a = a << 1 | 1 & s, s >>= 1; for (u = n << 16 | l, h = a; h < e; h += o)r[h] = u; ++i } ++n, i <<= 1, o <<= 1 } return [r, d, f] } function h(t, e) { switch (this.g = [], this.h = 32768, this.d = this.f = this.a = this.l = 0, this.input = c ? new Uint8Array(t) : t, this.m = !1, this.i = p, this.r = !1, !e && (e = {}) || (e.index && (this.a = e.index), e.bufferSize && (this.h = e.bufferSize), e.bufferType && (this.i = e.bufferType), e.resize && (this.r = e.resize)), this.i) { case u: this.b = 32768, this.c = new (c ? Uint8Array : Array)(32768 + this.h + 258); break; case p: this.b = 0, this.c = new (c ? Uint8Array : Array)(this.h), this.e = this.z, this.n = this.v, this.j = this.w; break; default: throw Error("invalid inflate mode") } } var u = 0, p = 1, d = { t: u, s: p }; h.prototype.k = function () { for (; !this.m;) { var t = O(this, 3); switch (1 & t && (this.m = !0), t >>>= 1) { case 0: var e = this.input, r = this.a, n = this.c, i = this.b, a = e.length, s = o, h = n.length, d = o; if (this.d = this.f = 0, r + 1 >= a) throw Error("invalid uncompressed block header: LEN"); if (s = e[r++] | e[r++] << 8, r + 1 >= a) throw Error("invalid uncompressed block header: NLEN"); if (s === ~(e[r++] | e[r++] << 8)) throw Error("invalid uncompressed block header: length verify"); if (r + s > e.length) throw Error("input buffer is broken"); switch (this.i) { case u: for (; i + s > n.length;) { if (s -= d = h - i, c) n.set(e.subarray(r, r + d), i), i += d, r += d; else for (; d--;)n[i++] = e[r++]; this.b = i, n = this.e(), i = this.b } break; case p: for (; i + s > n.length;)n = this.e({ p: 2 }); break; default: throw Error("invalid inflate mode") }if (c) n.set(e.subarray(r, r + s), i), i += s, r += s; else for (; s--;)n[i++] = e[r++]; this.a = r, this.b = i, this.c = n; break; case 1: this.j(P, C); break; case 2: var f, m, v, y, x = O(this, 5) + 257, b = O(this, 5) + 1, w = O(this, 4) + 4, _ = new (c ? Uint8Array : Array)(g.length), M = o, S = o, T = o, E = o, A = o; for (A = 0; A < w; ++A)_[g[A]] = O(this, 3); if (!c) for (A = w, w = _.length; A < w; ++A)_[g[A]] = 0; for (f = l(_), M = new (c ? Uint8Array : Array)(x + b), A = 0, y = x + b; A < y;)switch (S = I(this, f), S) { case 16: for (E = 3 + O(this, 2); E--;)M[A++] = T; break; case 17: for (E = 3 + O(this, 3); E--;)M[A++] = 0; T = 0; break; case 18: for (E = 11 + O(this, 7); E--;)M[A++] = 0; T = 0; break; default: T = M[A++] = S }m = l(c ? M.subarray(0, x) : M.slice(0, x)), v = l(c ? M.subarray(x) : M.slice(x)), this.j(m, v); break; default: throw Error("unknown BTYPE: " + t) } } return this.n() }; var f, m, v = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], g = c ? new Uint16Array(v) : v, y = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 258, 258], x = c ? new Uint16Array(y) : y, b = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0], w = c ? new Uint8Array(b) : b, _ = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577], M = c ? new Uint16Array(_) : _, S = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13], T = c ? new Uint8Array(S) : S, E = new (c ? Uint8Array : Array)(288); for (f = 0, m = E.length; f < m; ++f)E[f] = 143 >= f ? 8 : 255 >= f ? 9 : 279 >= f ? 7 : 8; var A, L, P = l(E), R = new (c ? Uint8Array : Array)(30); for (A = 0, L = R.length; A < L; ++A)R[A] = 5; var C = l(R); function O(t, e) { for (var r, n = t.f, i = t.d, o = t.input, a = t.a, s = o.length; i < e;) { if (a >= s) throw Error("input buffer is broken"); n |= o[a++] << i, i += 8 } return r = n & (1 << e) - 1, t.f = n >>> e, t.d = i - e, t.a = a, r } function I(t, e) { for (var r, n, i = t.f, o = t.d, a = t.input, s = t.a, c = a.length, l = e[0], h = e[1]; o < h && !(s >= c);)i |= a[s++] << o, o += 8; if ((n = (r = l[i & (1 << h) - 1]) >>> 16) > o) throw Error("invalid code length: " + n); return t.f = i >> n, t.d = o - n, t.a = s, 65535 & r } function N(t, e) { var r, n; switch (this.input = t, this.a = 0, !e && (e = {}) || (e.index && (this.a = e.index), e.verify && (this.A = e.verify)), r = t[this.a++], n = t[this.a++], 15 & r) { case D: this.method = D; break; default: throw Error("unsupported compression method") }if (0 != ((r << 8) + n) % 31) throw Error("invalid fcheck flag:" + ((r << 8) + n) % 31); if (32 & n) throw Error("fdict flag is not supported"); this.q = new h(t, { index: this.a, bufferSize: e.bufferSize, bufferType: e.bufferType, resize: e.resize }) } h.prototype.j = function (t, e) { var r = this.c, n = this.b; this.o = t; for (var i, o, a, s, c = r.length - 258; 256 !== (i = I(this, t));)if (256 > i) n >= c && (this.b = n, r = this.e(), n = this.b), r[n++] = i; else for (s = x[o = i - 257], 0 < w[o] && (s += O(this, w[o])), i = I(this, e), a = M[i], 0 < T[i] && (a += O(this, T[i])), n >= c && (this.b = n, r = this.e(), n = this.b); s--;)r[n] = r[n++ - a]; for (; 8 <= this.d;)this.d -= 8, this.a--; this.b = n }, h.prototype.w = function (t, e) { var r = this.c, n = this.b; this.o = t; for (var i, o, a, s, c = r.length; 256 !== (i = I(this, t));)if (256 > i) n >= c && (c = (r = this.e()).length), r[n++] = i; else for (s = x[o = i - 257], 0 < w[o] && (s += O(this, w[o])), i = I(this, e), a = M[i], 0 < T[i] && (a += O(this, T[i])), n + s > c && (c = (r = this.e()).length); s--;)r[n] = r[n++ - a]; for (; 8 <= this.d;)this.d -= 8, this.a--; this.b = n }, h.prototype.e = function () { var t, e, r = new (c ? Uint8Array : Array)(this.b - 32768), n = this.b - 32768, i = this.c; if (c) r.set(i.subarray(32768, r.length)); else for (t = 0, e = r.length; t < e; ++t)r[t] = i[t + 32768]; if (this.g.push(r), this.l += r.length, c) i.set(i.subarray(n, n + 32768)); else for (t = 0; 32768 > t; ++t)i[t] = i[n + t]; return this.b = 32768, i }, h.prototype.z = function (t) { var e, r, n, i = this.input.length / this.a + 1 | 0, o = this.input, a = this.c; return t && ("number" == typeof t.p && (i = t.p), "number" == typeof t.u && (i += t.u)), 2 > i ? r = (n = (o.length - this.a) / this.o[2] / 2 * 258 | 0) < a.length ? a.length + n : a.length << 1 : r = a.length * i, c ? (e = new Uint8Array(r)).set(a) : e = a, this.c = e }, h.prototype.n = function () { var t, e, r, n, i, o = 0, a = this.c, s = this.g, l = new (c ? Uint8Array : Array)(this.l + (this.b - 32768)); if (0 === s.length) return c ? this.c.subarray(32768, this.b) : this.c.slice(32768, this.b); for (e = 0, r = s.length; e < r; ++e)for (n = 0, i = (t = s[e]).length; n < i; ++n)l[o++] = t[n]; for (e = 32768, r = this.b; e < r; ++e)l[o++] = a[e]; return this.g = [], this.buffer = l }, h.prototype.v = function () { var t, e = this.b; return c ? this.r ? (t = new Uint8Array(e)).set(this.c.subarray(0, e)) : t = this.c.subarray(0, e) : (this.c.length > e && (this.c.length = e), t = this.c), this.buffer = t }, N.prototype.k = function () { var t, e, r = this.input; if (t = this.q.k(), this.a = this.q.a, this.A) { e = (r[this.a++] << 24 | r[this.a++] << 16 | r[this.a++] << 8 | r[this.a++]) >>> 0; var n = t; if ("string" == typeof n) { var i, o, a = n.split(""); for (i = 0, o = a.length; i < o; i++)a[i] = (255 & a[i].charCodeAt(0)) >>> 0; n = a } for (var s, c = 1, l = 0, h = n.length, u = 0; 0 < h;) { h -= s = 1024 < h ? 1024 : h; do { l += c += n[u++] } while (--s); c %= 65521, l %= 65521 } if (e !== (l << 16 | c) >>> 0) throw Error("invalid adler-32 checksum") } return t }; var D = 8; s("Zlib.Inflate", N), s("Zlib.Inflate.prototype.decompress", N.prototype.k); var z, F, U, B, k = { ADAPTIVE: d.s, BLOCK: d.t }; if (Object.keys) z = Object.keys(k); else for (F in z = [], U = 0, k) z[U++] = F; for (U = 0, B = z.length; U < B; ++U)s("Zlib.Inflate.BufferType." + (F = z[U]), k[F]); var j = i.Zlib, G = { findSpan: function (t, e, r) { var n = r.length - t - 1; if (e >= r[n]) return n - 1; if (e <= r[t]) return t; for (var i = t, o = n, a = Math.floor((i + o) / 2); e < r[a] || e >= r[a + 1];)e < r[a] ? o = a : i = a, a = Math.floor((i + o) / 2); return a }, calcBasisFunctions: function (t, e, r, n) { var i = [], o = [], a = []; i[0] = 1; for (var s = 1; s <= r; ++s) { o[s] = e - n[t + 1 - s], a[s] = n[t + s] - e; for (var c = 0, l = 0; l < s; ++l) { var h = a[l + 1], u = o[s - l], p = i[l] / (h + u); i[l] = c + h * p, c = u * p } i[s] = c } return i }, calcBSplinePoint: function (t, e, r, i) { for (var o = this.findSpan(t, i, e), a = this.calcBasisFunctions(o, i, t, e), s = new n.X(0, 0, 0, 0), c = 0; c <= t; ++c) { var l = r[o - t + c], h = a[c], u = l.w * h; s.x += l.x * u, s.y += l.y * u, s.z += l.z * u, s.w += l.w * h } return s }, calcBasisFunctionDerivatives: function (t, e, r, n, i) { for (var o = [], a = 0; a <= r; ++a)o[a] = 0; var s = []; for (a = 0; a <= n; ++a)s[a] = o.slice(0); var c = []; for (a = 0; a <= r; ++a)c[a] = o.slice(0); c[0][0] = 1; for (var l = o.slice(0), h = o.slice(0), u = 1; u <= r; ++u) { l[u] = e - i[t + 1 - u], h[u] = i[t + u] - e; for (var p = 0, d = 0; d < u; ++d) { var f = h[d + 1], m = l[u - d]; c[u][d] = f + m; var v = c[d][u - 1] / c[u][d]; c[d][u] = p + f * v, p = m * v } c[u][u] = p } for (u = 0; u <= r; ++u)s[0][u] = c[u][r]; for (d = 0; d <= r; ++d) { var g = 0, y = 1, x = []; for (a = 0; a <= r; ++a)x[a] = o.slice(0); x[0][0] = 1; for (var b = 1; b <= n; ++b) { var w = 0, _ = d - b, M = r - b; d >= b && (x[y][0] = x[g][0] / c[M + 1][_], w = x[y][0] * c[_][M]); var S = d - 1 <= M ? b - 1 : r - d; for (u = _ >= -1 ? 1 : -_; u <= S; ++u)x[y][u] = (x[g][u] - x[g][u - 1]) / c[M + 1][_ + u], w += x[y][u] * c[_ + u][M]; d <= M && (x[y][b] = -x[g][b - 1] / c[M + 1][d], w += x[y][b] * c[d][M]), s[b][d] = w; u = g; g = y, y = u } } for (d = r, b = 1; b <= n; ++b) { for (u = 0; u <= r; ++u)s[b][u] *= d; d *= r - b } return s }, calcBSplineDerivatives: function (t, e, r, i, o) { for (var a = o < t ? o : t, s = [], c = this.findSpan(t, i, e), l = this.calcBasisFunctionDerivatives(c, i, t, a, e), h = [], u = 0; u < r.length; ++u) { var p = (f = r[u].clone()).w; f.x *= p, f.y *= p, f.z *= p, h[u] = f } for (var d = 0; d <= a; ++d) { for (var f = h[c - t].clone().multiplyScalar(l[d][0]), m = 1; m <= t; ++m)f.add(h[c - t + m].clone().multiplyScalar(l[d][m])); s[d] = f } for (d = a + 1; d <= o + 1; ++d)s[d] = new n.X(0, 0, 0); return s }, calcKoverI: function (t, e) { for (var r = 1, n = 2; n <= t; ++n)r *= n; var i = 1; for (n = 2; n <= e; ++n)i *= n; for (n = 2; n <= t - e; ++n)i *= n; return r / i }, calcRationalCurveDerivatives: function (t) { for (var e = t.length, r = [], i = [], o = 0; o < e; ++o) { var a = t[o]; r[o] = new n.W(a.x, a.y, a.z), i[o] = a.w } for (var s = [], c = 0; c < e; ++c) { var l = r[c].clone(); for (o = 1; o <= c; ++o)l.sub(s[c - o].clone().multiplyScalar(this.calcKoverI(c, o) * i[o])); s[c] = l.divideScalar(i[0]) } return s }, calcNURBSDerivatives: function (t, e, r, n, i) { var o = this.calcBSplineDerivatives(t, e, r, n, i); return this.calcRationalCurveDerivatives(o) }, calcSurfacePoint: function (t, e, r, i, o, a, s, c) { for (var l = this.findSpan(t, a, r), h = this.findSpan(e, s, i), u = this.calcBasisFunctions(l, a, t, r), p = this.calcBasisFunctions(h, s, e, i), d = [], f = 0; f <= e; ++f) { d[f] = new n.X(0, 0, 0, 0); for (var m = 0; m <= t; ++m) { var v = o[l - t + m][h - e + f].clone(), g = v.w; v.x *= g, v.y *= g, v.z *= g, d[f].add(v.multiplyScalar(u[m])) } } var y = new n.X(0, 0, 0, 0); for (f = 0; f <= e; ++f)y.add(d[f].multiplyScalar(p[f])); y.divideScalar(y.w), c.set(y.x, y.y, y.z) } }, V = function (t, e, r, i, o) { n.j.call(this), this.degree = t, this.knots = e, this.controlPoints = [], this.startKnot = i || 0, this.endKnot = o || this.knots.length - 1; for (var a = 0; a < r.length; ++a) { var s = r[a]; this.controlPoints[a] = new n.X(s.x, s.y, s.z, s.w) } }; (V.prototype = Object.create(n.j.prototype)).constructor = V, V.prototype.getPoint = function (t) { var e = this.knots[this.startKnot] + t * (this.knots[this.endKnot] - this.knots[this.startKnot]), r = G.calcBSplinePoint(this.degree, this.knots, this.controlPoints, e); return 1 != r.w && r.divideScalar(r.w), new n.W(r.x, r.y, r.z) }, V.prototype.getTangent = function (t) { var e = this.knots[0] + t * (this.knots[this.knots.length - 1] - this.knots[0]), r = G.calcNURBSDerivatives(this.degree, this.knots, this.controlPoints, e, 1)[1].clone(); return r.normalize(), r }, r.d(e, "a", (function () { return H })); var H = function () { var t, e, r; function i(t) { n.u.call(this, t) } function o(t, e) { this.textureLoader = t, this.manager = e } function a() { } function s() { } function c() { } function l() { } function h(t, e) { this.dv = new DataView(t), this.offset = 0, this.littleEndian = void 0 === e || e } function u() { } function p(t) { var e = t.match(/FBXVersion: (\d+)/); if (e) return parseInt(e[1]); throw new Error("THREE.FBXLoader: Cannot find the version number for the file given.") } function d(t) { return t / 46186158e3 } i.prototype = Object.assign(Object.create(n.u.prototype), { constructor: i, load: function (t, e, r, i) { var o = this, a = "" === o.path ? n.v.extractUrlBase(t) : o.path, s = new n.o(this.manager); s.setPath(o.path), s.setResponseType("arraybuffer"), s.load(t, (function (r) { try { e(o.parse(r, a)) } catch (e) { setTimeout((function () { i && i(e), o.manager.itemError(t) }), 0) } }), r, i) }, parse: function (e, r) { if (s = "Kaydara FBX Binary  \0", (a = e).byteLength >= s.length && s === w(a, 0, s.length)) t = (new l).parse(e); else { var i = w(e); if (!function (t) { var e = ["K", "a", "y", "d", "a", "r", "a", "\\", "F", "B", "X", "\\", "B", "i", "n", "a", "r", "y", "\\", "\\"], r = 0; for (var n = 0; n < e.length; ++n) { if ((o = void 0, o = t[(i = 1) - 1], t = t.slice(r + i), r++, o) === e[n]) return !1 } var i, o; return !0 }(i)) throw new Error("THREE.FBXLoader: Unknown format."); if (p(i) < 7e3) throw new Error("THREE.FBXLoader: FBX version not supported, FileVersion: " + p(i)); t = (new c).parse(i) } var a, s; return new o(new n.U(this.manager).setPath(this.resourcePath || r).setCrossOrigin(this.crossOrigin), this.manager).parse(t) } }), o.prototype = { constructor: o, parse: function () { e = this.parseConnections(); var t = this.parseImages(), n = this.parseTextures(t), i = this.parseMaterials(n), o = this.parseDeformers(), s = (new a).parse(o); return this.parseScene(o, s, i), r }, parseConnections: function () { var e = new Map; "Connections" in t && t.Connections.connections.forEach((function (t) { var r = t[0], n = t[1], i = t[2]; e.has(r) || e.set(r, { parents: [], children: [] }); var o = { ID: n, relationship: i }; e.get(r).parents.push(o), e.has(n) || e.set(n, { parents: [], children: [] }); var a = { ID: r, relationship: i }; e.get(n).children.push(a) })); return e }, parseImages: function () { var e = {}, r = {}; if ("Video" in t.Objects) { var n = t.Objects.Video; for (var i in n) { var o = n[i]; if (e[l = parseInt(i)] = o.RelativeFilename || o.Filename, "Content" in o) { var a = o.Content instanceof ArrayBuffer && o.Content.byteLength > 0, s = "string" == typeof o.Content && "" !== o.Content; if (a || s) { var c = this.parseImage(n[i]); r[o.RelativeFilename || o.Filename] = c } } } } for (var l in e) { var h = e[l]; void 0 !== r[h] ? e[l] = r[h] : e[l] = e[l].split("\\").pop() } return e }, parseImage: function (t) { var e, r = t.Content, n = t.RelativeFilename || t.Filename, i = n.slice(n.lastIndexOf(".") + 1).toLowerCase(); switch (i) { case "bmp": e = "image/bmp"; break; case "jpg": case "jpeg": e = "image/jpeg"; break; case "png": e = "image/png"; break; case "tif": e = "image/tiff"; break; case "tga": null === this.manager.getHandler(".tga") && console.warn("FBXLoader: TGA loader not found, skipping ", n), e = "image/tga"; break; default: return void console.warn('FBXLoader: Image type "' + i + '" is not supported.') }if ("string" == typeof r) return "data:" + e + ";base64," + r; var o = new Uint8Array(r); return window.URL.createObjectURL(new Blob([o], { type: e })) }, parseTextures: function (e) { var r = new Map; if ("Texture" in t.Objects) { var n = t.Objects.Texture; for (var i in n) { var o = this.parseTexture(n[i], e); r.set(parseInt(i), o) } } return r }, parseTexture: function (t, e) { var r = this.loadTexture(t, e); r.ID = t.id, r.name = t.attrName; var i = t.WrapModeU, o = t.WrapModeV, a = void 0 !== i ? i.value : 0, s = void 0 !== o ? o.value : 0; if (r.wrapS = 0 === a ? n.N : n.g, r.wrapT = 0 === s ? n.N : n.g, "Scaling" in t) { var c = t.Scaling.value; r.repeat.x = c[0], r.repeat.y = c[1] } return r }, loadTexture: function (t, r) { var i, o, a = this.textureLoader.path, s = e.get(t.id).children; void 0 !== s && s.length > 0 && void 0 !== r[s[0].ID] && (0 !== (i = r[s[0].ID]).indexOf("blob:") && 0 !== i.indexOf("data:") || this.textureLoader.setPath(void 0)); var c = t.FileName.slice(-3).toLowerCase(); if ("tga" === c) { var l = this.manager.getHandler(".tga"); null === l ? (console.warn("FBXLoader: TGA loader not found, creating placeholder texture for", t.RelativeFilename), o = new n.T) : o = l.load(i) } else "psd" === c ? (console.warn("FBXLoader: PSD textures are not supported, creating placeholder texture for", t.RelativeFilename), o = new n.T) : o = this.textureLoader.load(i); return this.textureLoader.setPath(a), o }, parseMaterials: function (e) { var r = new Map; if ("Material" in t.Objects) { var n = t.Objects.Material; for (var i in n) { var o = this.parseMaterial(n[i], e); null !== o && r.set(parseInt(i), o) } } return r }, parseMaterial: function (t, r) { var i = t.id, o = t.attrName, a = t.ShadingModel; if ("object" == typeof a && (a = a.value), !e.has(i)) return null; var s, c = this.parseParameters(t, r, i); switch (a.toLowerCase()) { case "phong": s = new n.B; break; case "lambert": s = new n.A; break; default: console.warn('THREE.FBXLoader: unknown material type "%s". Defaulting to MeshPhongMaterial.', a), s = new n.B }return s.setValues(c), s.name = o, s }, parseParameters: function (t, r, i) { var o = {}; t.BumpFactor && (o.bumpScale = t.BumpFactor.value), t.Diffuse ? o.color = (new n.i).fromArray(t.Diffuse.value) : t.DiffuseColor && "Color" === t.DiffuseColor.type && (o.color = (new n.i).fromArray(t.DiffuseColor.value)), t.DisplacementFactor && (o.displacementScale = t.DisplacementFactor.value), t.Emissive ? o.emissive = (new n.i).fromArray(t.Emissive.value) : t.EmissiveColor && "Color" === t.EmissiveColor.type && (o.emissive = (new n.i).fromArray(t.EmissiveColor.value)), t.EmissiveFactor && (o.emissiveIntensity = parseFloat(t.EmissiveFactor.value)), t.Opacity && (o.opacity = parseFloat(t.Opacity.value)), o.opacity < 1 && (o.transparent = !0), t.ReflectionFactor && (o.reflectivity = t.ReflectionFactor.value), t.Shininess && (o.shininess = t.Shininess.value), t.Specular ? o.specular = (new n.i).fromArray(t.Specular.value) : t.SpecularColor && "Color" === t.SpecularColor.type && (o.specular = (new n.i).fromArray(t.SpecularColor.value)); var a = this; return e.get(i).children.forEach((function (t) { var e = t.relationship; switch (e) { case "Bump": o.bumpMap = a.getTexture(r, t.ID); break; case "Maya|TEX_ao_map": o.aoMap = a.getTexture(r, t.ID); break; case "DiffuseColor": case "Maya|TEX_color_map": o.map = a.getTexture(r, t.ID), o.map.encoding = n.bb; break; case "DisplacementColor": o.displacementMap = a.getTexture(r, t.ID); break; case "EmissiveColor": o.emissiveMap = a.getTexture(r, t.ID), o.emissiveMap.encoding = n.bb; break; case "NormalMap": case "Maya|TEX_normal_map": o.normalMap = a.getTexture(r, t.ID); break; case "ReflectionColor": o.envMap = a.getTexture(r, t.ID), o.envMap.mapping = n.m, o.envMap.encoding = n.bb; break; case "SpecularColor": o.specularMap = a.getTexture(r, t.ID), o.specularMap.encoding = n.bb; break; case "TransparentColor": o.alphaMap = a.getTexture(r, t.ID), o.transparent = !0; break; case "AmbientColor": case "ShininessExponent": case "SpecularFactor": case "VectorDisplacementColor": default: console.warn("THREE.FBXLoader: %s map is not supported in three.js, skipping texture.", e) } })), o }, getTexture: function (r, n) { return "LayeredTexture" in t.Objects && n in t.Objects.LayeredTexture && (console.warn("THREE.FBXLoader: layered textures are not supported in three.js. Discarding all but first layer."), n = e.get(n).children[0].ID), r.get(n) }, parseDeformers: function () { var r = {}, n = {}; if ("Deformer" in t.Objects) { var i = t.Objects.Deformer; for (var o in i) { var a = i[o], s = e.get(parseInt(o)); if ("Skin" === a.attrType) { var c = this.parseSkeleton(s, i); c.ID = o, s.parents.length > 1 && console.warn("THREE.FBXLoader: skeleton attached to more than one geometry is not supported."), c.geometryID = s.parents[0].ID, r[o] = c } else if ("BlendShape" === a.attrType) { var l = { id: o }; l.rawTargets = this.parseMorphTargets(s, i), l.id = o, s.parents.length > 1 && console.warn("THREE.FBXLoader: morph target attached to more than one geometry is not supported."), n[o] = l } } } return { skeletons: r, morphTargets: n } }, parseSkeleton: function (t, e) { var r = []; return t.children.forEach((function (t) { var i = e[t.ID]; if ("Cluster" === i.attrType) { var o = { ID: t.ID, indices: [], weights: [], transformLink: (new n.y).fromArray(i.TransformLink.a) }; "Indexes" in i && (o.indices = i.Indexes.a, o.weights = i.Weights.a), r.push(o) } })), { rawBones: r, bones: [] } }, parseMorphTargets: function (t, r) { for (var n = [], i = 0; i < t.children.length; i++) { var o = t.children[i], a = r[o.ID], s = { name: a.attrName, initialWeight: a.DeformPercent, id: a.id, fullWeights: a.FullWeights.a }; if ("BlendShapeChannel" !== a.attrType) return; s.geoID = e.get(parseInt(o.ID)).children.filter((function (t) { return void 0 === t.relationship }))[0].ID, n.push(s) } return n }, parseScene: function (i, o, a) { r = new n.q; var c = this.parseModels(i.skeletons, o, a), l = t.Objects.Model, h = this; c.forEach((function (t) { var n = l[t.ID]; h.setLookAtProperties(t, n), e.get(t.ID).parents.forEach((function (e) { var r = c.get(e.ID); void 0 !== r && r.add(t) })), null === t.parent && r.add(t) })), this.bindSkeleton(i.skeletons, o, c), this.createAmbientLight(), this.setupMorphMaterials(), r.traverse((function (t) { if (t.userData.transformData) { t.parent && (t.userData.transformData.parentMatrixWorld = t.parent.matrix); var e = y(t.userData.transformData); t.applyMatrix(e) } })); var u = (new s).parse(); 1 === r.children.length && r.children[0].isGroup && (r.children[0].animations = u, r = r.children[0]), r.animations = u }, parseModels: function (r, i, o) { var a = new Map, s = t.Objects.Model; for (var c in s) { var l = parseInt(c), h = s[c], u = e.get(l), p = this.buildSkeleton(u, r, l, h.attrName); if (!p) { switch (h.attrType) { case "Camera": p = this.createCamera(u); break; case "Light": p = this.createLight(u); break; case "Mesh": p = this.createMesh(u, i, o); break; case "NurbsCurve": p = this.createCurve(u, i); break; case "LimbNode": case "Root": p = new n.c; break; case "Null": default: p = new n.q }p.name = h.attrName ? n.J.sanitizeNodeName(h.attrName) : "", p.ID = l } this.getTransformData(p, h), a.set(l, p) } return a }, buildSkeleton: function (t, e, r, i) { var o = null; return t.parents.forEach((function (t) { for (var a in e) { var s = e[a]; s.rawBones.forEach((function (e, a) { if (e.ID === t.ID) { var c = o; (o = new n.c).matrixWorld.copy(e.transformLink), o.name = i ? n.J.sanitizeNodeName(i) : "", o.ID = r, s.bones[a] = o, null !== c && o.add(c) } })) } })), o }, createCamera: function (e) { var r, i; if (e.children.forEach((function (e) { var r = t.Objects.NodeAttribute[e.ID]; void 0 !== r && (i = r) })), void 0 === i) r = new n.D; else { var o = 0; void 0 !== i.CameraProjectionType && 1 === i.CameraProjectionType.value && (o = 1); var a = 1; void 0 !== i.NearPlane && (a = i.NearPlane.value / 1e3); var s = 1e3; void 0 !== i.FarPlane && (s = i.FarPlane.value / 1e3); var c = window.innerWidth, l = window.innerHeight; void 0 !== i.AspectWidth && void 0 !== i.AspectHeight && (c = i.AspectWidth.value, l = i.AspectHeight.value); var h = c / l, u = 45; void 0 !== i.FieldOfView && (u = i.FieldOfView.value); var p = i.FocalLength ? i.FocalLength.value : null; switch (o) { case 0: r = new n.F(u, h, a, s), null !== p && r.setFocalLength(p); break; case 1: r = new n.E(-c / 2, c / 2, l / 2, -l / 2, a, s); break; default: console.warn("THREE.FBXLoader: Unknown camera type " + o + "."), r = new n.D } } return r }, createLight: function (e) { var r, i; if (e.children.forEach((function (e) { var r = t.Objects.NodeAttribute[e.ID]; void 0 !== r && (i = r) })), void 0 === i) r = new n.D; else { var o; o = void 0 === i.LightType ? 0 : i.LightType.value; var a = 16777215; void 0 !== i.Color && (a = (new n.i).fromArray(i.Color.value)); var s = void 0 === i.Intensity ? 1 : i.Intensity.value / 100; void 0 !== i.CastLightOnObject && 0 === i.CastLightOnObject.value && (s = 0); var c = 0; void 0 !== i.FarAttenuationEnd && (c = void 0 !== i.EnableFarAttenuation && 0 === i.EnableFarAttenuation.value ? 0 : i.FarAttenuationEnd.value); switch (o) { case 0: r = new n.I(a, s, c, 1); break; case 1: r = new n.k(a, s); break; case 2: var l = Math.PI / 3; void 0 !== i.InnerAngle && (l = n.w.degToRad(i.InnerAngle.value)); var h = 0; void 0 !== i.OuterAngle && (h = n.w.degToRad(i.OuterAngle.value), h = Math.max(h, 1)), r = new n.S(a, s, c, l, h, 1); break; default: console.warn("THREE.FBXLoader: Unknown light type " + i.LightType.value + ", defaulting to a PointLight."), r = new n.I(a, s) }void 0 !== i.CastShadows && 1 === i.CastShadows.value && (r.castShadow = !0) } return r }, createMesh: function (t, e, r) { var i, o = null, a = null, s = []; return t.children.forEach((function (t) { e.has(t.ID) && (o = e.get(t.ID)), r.has(t.ID) && s.push(r.get(t.ID)) })), s.length > 1 ? a = s : s.length > 0 ? a = s[0] : (a = new n.B({ color: 13421772 }), s.push(a)), "color" in o.attributes && s.forEach((function (t) { t.vertexColors = n.Z })), o.FBX_Deformer ? (s.forEach((function (t) { t.skinning = !0 })), (i = new n.R(o, a)).normalizeSkinWeights()) : i = new n.z(o, a), i }, createCurve: function (t, e) { var r = t.children.reduce((function (t, r) { return e.has(r.ID) && (t = e.get(r.ID)), t }), null), i = new n.s({ color: 3342591, linewidth: 1 }); return new n.r(r, i) }, getTransformData: function (t, e) { var r = {}; "InheritType" in e && (r.inheritType = parseInt(e.InheritType.value)), r.eulerOrder = "RotationOrder" in e ? x(e.RotationOrder.value) : "ZYX", "Lcl_Translation" in e && (r.translation = e.Lcl_Translation.value), "PreRotation" in e && (r.preRotation = e.PreRotation.value), "Lcl_Rotation" in e && (r.rotation = e.Lcl_Rotation.value), "PostRotation" in e && (r.postRotation = e.PostRotation.value), "Lcl_Scaling" in e && (r.scale = e.Lcl_Scaling.value), "ScalingOffset" in e && (r.scalingOffset = e.ScalingOffset.value), "ScalingPivot" in e && (r.scalingPivot = e.ScalingPivot.value), "RotationOffset" in e && (r.rotationOffset = e.RotationOffset.value), "RotationPivot" in e && (r.rotationPivot = e.RotationPivot.value), t.userData.transformData = r }, setLookAtProperties: function (i, o) { "LookAtProperty" in o && e.get(i.ID).children.forEach((function (e) { if ("LookAtProperty" === e.relationship) { var o = t.Objects.Model[e.ID]; if ("Lcl_Translation" in o) { var a = o.Lcl_Translation.value; void 0 !== i.target ? (i.target.position.fromArray(a), r.add(i.target)) : i.lookAt((new n.W).fromArray(a)) } } })) }, bindSkeleton: function (t, r, i) { var o = this.parsePoseNodes(); for (var a in t) { var s = t[a]; e.get(parseInt(s.ID)).parents.forEach((function (t) { if (r.has(t.ID)) { var a = t.ID; e.get(a).parents.forEach((function (t) { i.has(t.ID) && i.get(t.ID).bind(new n.Q(s.bones), o[t.ID]) })) } })) } }, parsePoseNodes: function () { var e = {}; if ("Pose" in t.Objects) { var r = t.Objects.Pose; for (var i in r) if ("BindPose" === r[i].attrType) { var o = r[i].PoseNode; Array.isArray(o) ? o.forEach((function (t) { e[t.Node] = (new n.y).fromArray(t.Matrix.a) })) : e[o.Node] = (new n.y).fromArray(o.Matrix.a) } } return e }, createAmbientLight: function () { if ("GlobalSettings" in t && "AmbientColor" in t.GlobalSettings) { var e = t.GlobalSettings.AmbientColor.value, i = e[0], o = e[1], a = e[2]; if (0 !== i || 0 !== o || 0 !== a) { var s = new n.i(i, o, a); r.add(new n.a(s, 1)) } } }, setupMorphMaterials: function () { var t = this; r.traverse((function (e) { e.isMesh && e.geometry.morphAttributes.position && e.geometry.morphAttributes.position.length && (Array.isArray(e.material) ? e.material.forEach((function (r, n) { t.setupMorphMaterial(e, r, n) })) : t.setupMorphMaterial(e, e.material)) })) }, setupMorphMaterial: function (t, e, n) { var i = t.uuid, o = e.uuid, a = !1; if (r.traverse((function (t) { t.isMesh && (Array.isArray(t.material) ? t.material.forEach((function (e) { e.uuid === o && t.uuid !== i && (a = !0) })) : t.material.uuid === o && t.uuid !== i && (a = !0)) })), !0 === a) { var s = e.clone(); s.morphTargets = !0, void 0 === n ? t.material = s : t.material[n] = s } else e.morphTargets = !0 } }, a.prototype = { constructor: a, parse: function (r) { var n = new Map; if ("Geometry" in t.Objects) { var i = t.Objects.Geometry; for (var o in i) { var a = e.get(parseInt(o)), s = this.parseGeometry(a, i[o], r); n.set(parseInt(o), s) } } return n }, parseGeometry: function (t, e, r) { switch (e.attrType) { case "Mesh": return this.parseMeshGeometry(t, e, r); case "NurbsCurve": return this.parseNurbsGeometry(e) } }, parseMeshGeometry: function (e, r, n) { var i = n.skeletons, o = [], a = e.parents.map((function (e) { return t.Objects.Model[e.ID] })); if (0 !== a.length) { var s = e.children.reduce((function (t, e) { return void 0 !== i[e.ID] && (t = i[e.ID]), t }), null); e.children.forEach((function (t) { void 0 !== n.morphTargets[t.ID] && o.push(n.morphTargets[t.ID]) })); var c = a[0], l = {}; "RotationOrder" in c && (l.eulerOrder = x(c.RotationOrder.value)), "InheritType" in c && (l.inheritType = parseInt(c.InheritType.value)), "GeometricTranslation" in c && (l.translation = c.GeometricTranslation.value), "GeometricRotation" in c && (l.rotation = c.GeometricRotation.value), "GeometricScaling" in c && (l.scale = c.GeometricScaling.value); var h = y(l); return this.genGeometry(r, s, o, h) } }, genGeometry: function (t, e, r, i) { var o = new n.f; t.attrName && (o.name = t.attrName); var a = this.parseGeoNode(t, e), s = this.genBuffers(a), c = new n.p(s.vertex, 3); if (i.applyToBufferAttribute(c), o.setAttribute("position", c), s.colors.length > 0 && o.setAttribute("color", new n.p(s.colors, 3)), e && (o.setAttribute("skinIndex", new n.V(s.weightsIndices, 4)), o.setAttribute("skinWeight", new n.p(s.vertexWeights, 4)), o.FBX_Deformer = e), s.normal.length > 0) { var l = new n.p(s.normal, 3); (new n.x).getNormalMatrix(i).applyToBufferAttribute(l), o.setAttribute("normal", l) } if (s.uvs.forEach((function (t, e) { var r = "uv" + (e + 1).toString(); 0 === e && (r = "uv"), o.setAttribute(r, new n.p(s.uvs[e], 2)) })), a.material && "AllSame" !== a.material.mappingType) { var h = s.materialIndex[0], u = 0; if (s.materialIndex.forEach((function (t, e) { t !== h && (o.addGroup(u, e - u, h), h = t, u = e) })), o.groups.length > 0) { var p = o.groups[o.groups.length - 1], d = p.start + p.count; d !== s.materialIndex.length && o.addGroup(d, s.materialIndex.length - d, h) } 0 === o.groups.length && o.addGroup(0, s.materialIndex.length, s.materialIndex[0]) } return this.addMorphTargets(o, t, r, i), o }, parseGeoNode: function (t, e) { var r = {}; if (r.vertexPositions = void 0 !== t.Vertices ? t.Vertices.a : [], r.vertexIndices = void 0 !== t.PolygonVertexIndex ? t.PolygonVertexIndex.a : [], t.LayerElementColor && (r.color = this.parseVertexColors(t.LayerElementColor[0])), t.LayerElementMaterial && (r.material = this.parseMaterialIndices(t.LayerElementMaterial[0])), t.LayerElementNormal && (r.normal = this.parseNormals(t.LayerElementNormal[0])), t.LayerElementUV) { r.uv = []; for (var n = 0; t.LayerElementUV[n];)r.uv.push(this.parseUVs(t.LayerElementUV[n])), n++ } return r.weightTable = {}, null !== e && (r.skeleton = e, e.rawBones.forEach((function (t, e) { t.indices.forEach((function (n, i) { void 0 === r.weightTable[n] && (r.weightTable[n] = []), r.weightTable[n].push({ id: e, weight: t.weights[i] }) })) }))), r }, genBuffers: function (t) { var e = { vertex: [], normal: [], colors: [], uvs: [], materialIndex: [], vertexWeights: [], weightsIndices: [] }, r = 0, n = 0, i = !1, o = [], a = [], s = [], c = [], l = [], h = [], u = this; return t.vertexIndices.forEach((function (p, d) { var f = !1; p < 0 && (p ^= -1, f = !0); var v = [], g = []; if (o.push(3 * p, 3 * p + 1, 3 * p + 2), t.color) { var y = m(d, r, p, t.color); s.push(y[0], y[1], y[2]) } if (t.skeleton) { if (void 0 !== t.weightTable[p] && t.weightTable[p].forEach((function (t) { g.push(t.weight), v.push(t.id) })), g.length > 4) { i || (console.warn("THREE.FBXLoader: Vertex has more than 4 skinning weights assigned to vertex. Deleting additional weights."), i = !0); var x = [0, 0, 0, 0], b = [0, 0, 0, 0]; g.forEach((function (t, e) { var r = t, n = v[e]; b.forEach((function (t, e, i) { if (r > t) { i[e] = r, r = t; var o = x[e]; x[e] = n, n = o } })) })), v = x, g = b } for (; g.length < 4;)g.push(0), v.push(0); for (var w = 0; w < 4; ++w)l.push(g[w]), h.push(v[w]) } if (t.normal) { y = m(d, r, p, t.normal); a.push(y[0], y[1], y[2]) } if (t.material && "AllSame" !== t.material.mappingType) var _ = m(d, r, p, t.material)[0]; t.uv && t.uv.forEach((function (t, e) { var n = m(d, r, p, t); void 0 === c[e] && (c[e] = []), c[e].push(n[0]), c[e].push(n[1]) })), n++, f && (u.genFace(e, t, o, _, a, s, c, l, h, n), r++, n = 0, o = [], a = [], s = [], c = [], l = [], h = []) })), e }, genFace: function (t, e, r, n, i, o, a, s, c, l) { for (var h = 2; h < l; h++)t.vertex.push(e.vertexPositions[r[0]]), t.vertex.push(e.vertexPositions[r[1]]), t.vertex.push(e.vertexPositions[r[2]]), t.vertex.push(e.vertexPositions[r[3 * (h - 1)]]), t.vertex.push(e.vertexPositions[r[3 * (h - 1) + 1]]), t.vertex.push(e.vertexPositions[r[3 * (h - 1) + 2]]), t.vertex.push(e.vertexPositions[r[3 * h]]), t.vertex.push(e.vertexPositions[r[3 * h + 1]]), t.vertex.push(e.vertexPositions[r[3 * h + 2]]), e.skeleton && (t.vertexWeights.push(s[0]), t.vertexWeights.push(s[1]), t.vertexWeights.push(s[2]), t.vertexWeights.push(s[3]), t.vertexWeights.push(s[4 * (h - 1)]), t.vertexWeights.push(s[4 * (h - 1) + 1]), t.vertexWeights.push(s[4 * (h - 1) + 2]), t.vertexWeights.push(s[4 * (h - 1) + 3]), t.vertexWeights.push(s[4 * h]), t.vertexWeights.push(s[4 * h + 1]), t.vertexWeights.push(s[4 * h + 2]), t.vertexWeights.push(s[4 * h + 3]), t.weightsIndices.push(c[0]), t.weightsIndices.push(c[1]), t.weightsIndices.push(c[2]), t.weightsIndices.push(c[3]), t.weightsIndices.push(c[4 * (h - 1)]), t.weightsIndices.push(c[4 * (h - 1) + 1]), t.weightsIndices.push(c[4 * (h - 1) + 2]), t.weightsIndices.push(c[4 * (h - 1) + 3]), t.weightsIndices.push(c[4 * h]), t.weightsIndices.push(c[4 * h + 1]), t.weightsIndices.push(c[4 * h + 2]), t.weightsIndices.push(c[4 * h + 3])), e.color && (t.colors.push(o[0]), t.colors.push(o[1]), t.colors.push(o[2]), t.colors.push(o[3 * (h - 1)]), t.colors.push(o[3 * (h - 1) + 1]), t.colors.push(o[3 * (h - 1) + 2]), t.colors.push(o[3 * h]), t.colors.push(o[3 * h + 1]), t.colors.push(o[3 * h + 2])), e.material && "AllSame" !== e.material.mappingType && (t.materialIndex.push(n), t.materialIndex.push(n), t.materialIndex.push(n)), e.normal && (t.normal.push(i[0]), t.normal.push(i[1]), t.normal.push(i[2]), t.normal.push(i[3 * (h - 1)]), t.normal.push(i[3 * (h - 1) + 1]), t.normal.push(i[3 * (h - 1) + 2]), t.normal.push(i[3 * h]), t.normal.push(i[3 * h + 1]), t.normal.push(i[3 * h + 2])), e.uv && e.uv.forEach((function (e, r) { void 0 === t.uvs[r] && (t.uvs[r] = []), t.uvs[r].push(a[r][0]), t.uvs[r].push(a[r][1]), t.uvs[r].push(a[r][2 * (h - 1)]), t.uvs[r].push(a[r][2 * (h - 1) + 1]), t.uvs[r].push(a[r][2 * h]), t.uvs[r].push(a[r][2 * h + 1]) })) }, addMorphTargets: function (e, r, n, i) { if (0 !== n.length) { e.morphTargetsRelative = !0, e.morphAttributes.position = []; var o = this; n.forEach((function (n) { n.rawTargets.forEach((function (n) { var a = t.Objects.Geometry[n.geoID]; void 0 !== a && o.genMorphGeometry(e, r, a, i, n.name) })) })) } }, genMorphGeometry: function (t, e, r, i, o) { for (var a = void 0 !== e.PolygonVertexIndex ? e.PolygonVertexIndex.a : [], s = void 0 !== r.Vertices ? r.Vertices.a : [], c = void 0 !== r.Indexes ? r.Indexes.a : [], l = 3 * t.attributes.position.count, h = new Float32Array(l), u = 0; u < c.length; u++) { var p = 3 * c[u]; h[p] = s[3 * u], h[p + 1] = s[3 * u + 1], h[p + 2] = s[3 * u + 2] } var d = { vertexIndices: a, vertexPositions: h }, f = this.genBuffers(d), m = new n.p(f.vertex, 3); m.name = o || r.attrName, i.applyToBufferAttribute(m), t.morphAttributes.position.push(m) }, parseNormals: function (t) { var e = t.MappingInformationType, r = t.ReferenceInformationType, n = t.Normals.a, i = []; return "IndexToDirect" === r && ("NormalIndex" in t ? i = t.NormalIndex.a : "NormalsIndex" in t && (i = t.NormalsIndex.a)), { dataSize: 3, buffer: n, indices: i, mappingType: e, referenceType: r } }, parseUVs: function (t) { var e = t.MappingInformationType, r = t.ReferenceInformationType, n = t.UV.a, i = []; return "IndexToDirect" === r && (i = t.UVIndex.a), { dataSize: 2, buffer: n, indices: i, mappingType: e, referenceType: r } }, parseVertexColors: function (t) { var e = t.MappingInformationType, r = t.ReferenceInformationType, n = t.Colors.a, i = []; return "IndexToDirect" === r && (i = t.ColorIndex.a), { dataSize: 4, buffer: n, indices: i, mappingType: e, referenceType: r } }, parseMaterialIndices: function (t) { var e = t.MappingInformationType, r = t.ReferenceInformationType; if ("NoMappingInformation" === e) return { dataSize: 1, buffer: [0], indices: [0], mappingType: "AllSame", referenceType: r }; for (var n = t.Materials.a, i = [], o = 0; o < n.length; ++o)i.push(o); return { dataSize: 1, buffer: n, indices: i, mappingType: e, referenceType: r } }, parseNurbsGeometry: function (t) { if (void 0 === V) return console.error("THREE.FBXLoader: The loader relies on NURBSCurve for any nurbs present in the model. Nurbs will show up as empty geometry."), new n.f; var e = parseInt(t.Order); if (isNaN(e)) return console.error("THREE.FBXLoader: Invalid Order %s given for geometry ID: %s", t.Order, t.id), new n.f; for (var r, i, o = e - 1, a = t.KnotVector.a, s = [], c = t.Points.a, l = 0, h = c.length; l < h; l += 4)s.push((new n.X).fromArray(c, l)); if ("Closed" === t.Form) s.push(s[0]); else if ("Periodic" === t.Form) { r = o, i = a.length - 1 - r; for (l = 0; l < o; ++l)s.push(s[l]) } var u = new V(o, a, s, r, i).getPoints(7 * s.length), p = new Float32Array(3 * u.length); u.forEach((function (t, e) { t.toArray(p, 3 * e) })); var d = new n.f; return d.setAttribute("position", new n.e(p, 3)), d } }, s.prototype = { constructor: s, parse: function () { var t = [], e = this.parseClips(); if (void 0 !== e) for (var r in e) { var n = e[r], i = this.addClip(n); t.push(i) } return t }, parseClips: function () { if (void 0 !== t.Objects.AnimationCurve) { var e = this.parseAnimationCurveNodes(); this.parseAnimationCurves(e); var r = this.parseAnimationLayers(e); return this.parseAnimStacks(r) } }, parseAnimationCurveNodes: function () { var e = t.Objects.AnimationCurveNode, r = new Map; for (var n in e) { var i = e[n]; if (null !== i.attrName.match(/S|R|T|DeformPercent/)) { var o = { id: i.id, attr: i.attrName, curves: {} }; r.set(o.id, o) } } return r }, parseAnimationCurves: function (r) { var n = t.Objects.AnimationCurve; for (var i in n) { var o = { id: n[i].id, times: n[i].KeyTime.a.map(d), values: n[i].KeyValueFloat.a }, a = e.get(o.id); if (void 0 !== a) { var s = a.parents[0].ID, c = a.parents[0].relationship; c.match(/X/) ? r.get(s).curves.x = o : c.match(/Y/) ? r.get(s).curves.y = o : c.match(/Z/) ? r.get(s).curves.z = o : c.match(/d|DeformPercent/) && r.has(s) && (r.get(s).curves.morph = o) } } }, parseAnimationLayers: function (i) { var o = t.Objects.AnimationLayer, a = new Map; for (var s in o) { var c = [], l = e.get(parseInt(s)); if (void 0 !== l) l.children.forEach((function (o, a) { if (i.has(o.ID)) { var s = i.get(o.ID); if (void 0 !== s.curves.x || void 0 !== s.curves.y || void 0 !== s.curves.z) { if (void 0 === c[a]) if (void 0 !== (f = e.get(o.ID).parents.filter((function (t) { return void 0 !== t.relationship }))[0].ID)) { var l = { modelName: (h = t.Objects.Model[f.toString()]).attrName ? n.J.sanitizeNodeName(h.attrName) : "", ID: h.id, initialPosition: [0, 0, 0], initialRotation: [0, 0, 0], initialScale: [1, 1, 1] }; r.traverse((function (t) { t.ID === h.id && (l.transform = t.matrix, t.userData.transformData && (l.eulerOrder = t.userData.transformData.eulerOrder)) })), l.transform || (l.transform = new n.y), "PreRotation" in h && (l.preRotation = h.PreRotation.value), "PostRotation" in h && (l.postRotation = h.PostRotation.value), c[a] = l } c[a] && (c[a][s.attr] = s) } else if (void 0 !== s.curves.morph) { if (void 0 === c[a]) { var h, u = e.get(o.ID).parents.filter((function (t) { return void 0 !== t.relationship }))[0].ID, p = e.get(u).parents[0].ID, d = e.get(p).parents[0].ID, f = e.get(d).parents[0].ID; l = { modelName: (h = t.Objects.Model[f]).attrName ? n.J.sanitizeNodeName(h.attrName) : "", morphName: t.Objects.Deformer[u].attrName }; c[a] = l } c[a][s.attr] = s } } })), a.set(parseInt(s), c) } return a }, parseAnimStacks: function (r) { var n = t.Objects.AnimationStack, i = {}; for (var o in n) { var a = e.get(parseInt(o)).children; a.length > 1 && console.warn("THREE.FBXLoader: Encountered an animation stack with multiple layers, this is currently not supported. Ignoring subsequent layers."); var s = r.get(a[0].ID); i[o] = { name: n[o].attrName, layer: s } } return i }, addClip: function (t) { var e = [], r = this; return t.layer.forEach((function (t) { e = e.concat(r.generateTracks(t)) })), new n.b(t.name, -1, e) }, generateTracks: function (t) { var e = [], r = new n.W, i = new n.K, o = new n.W; if (t.transform && t.transform.decompose(r, i, o), r = r.toArray(), i = (new n.n).setFromQuaternion(i, t.eulerOrder).toArray(), o = o.toArray(), void 0 !== t.T && Object.keys(t.T.curves).length > 0) { var a = this.generateVectorTrack(t.modelName, t.T.curves, r, "position"); void 0 !== a && e.push(a) } if (void 0 !== t.R && Object.keys(t.R.curves).length > 0) { var s = this.generateRotationTrack(t.modelName, t.R.curves, i, t.preRotation, t.postRotation, t.eulerOrder); void 0 !== s && e.push(s) } if (void 0 !== t.S && Object.keys(t.S.curves).length > 0) { var c = this.generateVectorTrack(t.modelName, t.S.curves, o, "scale"); void 0 !== c && e.push(c) } if (void 0 !== t.DeformPercent) { var l = this.generateMorphTrack(t); void 0 !== l && e.push(l) } return e }, generateVectorTrack: function (t, e, r, i) { var o = this.getTimesForAllAxes(e), a = this.getKeyframeTrackValues(o, e, r); return new n.Y(t + "." + i, o, a) }, generateRotationTrack: function (t, e, r, i, o, a) { void 0 !== e.x && (this.interpolateRotations(e.x), e.x.values = e.x.values.map(n.w.degToRad)), void 0 !== e.y && (this.interpolateRotations(e.y), e.y.values = e.y.values.map(n.w.degToRad)), void 0 !== e.z && (this.interpolateRotations(e.z), e.z.values = e.z.values.map(n.w.degToRad)); var s = this.getTimesForAllAxes(e), c = this.getKeyframeTrackValues(s, e, r); void 0 !== i && ((i = i.map(n.w.degToRad)).push(a), i = (new n.n).fromArray(i), i = (new n.K).setFromEuler(i)), void 0 !== o && ((o = o.map(n.w.degToRad)).push(a), o = (new n.n).fromArray(o), o = (new n.K).setFromEuler(o).inverse()); for (var l = new n.K, h = new n.n, u = [], p = 0; p < c.length; p += 3)h.set(c[p], c[p + 1], c[p + 2], a), l.setFromEuler(h), void 0 !== i && l.premultiply(i), void 0 !== o && l.multiply(o), l.toArray(u, p / 3 * 4); return new n.L(t + ".quaternion", s, u) }, generateMorphTrack: function (t) { var e = t.DeformPercent.curves.morph, i = e.values.map((function (t) { return t / 100 })), o = r.getObjectByName(t.modelName).morphTargetDictionary[t.morphName]; return new n.C(t.modelName + ".morphTargetInfluences[" + o + "]", e.times, i) }, getTimesForAllAxes: function (t) { var e = []; return void 0 !== t.x && (e = e.concat(t.x.times)), void 0 !== t.y && (e = e.concat(t.y.times)), void 0 !== t.z && (e = e.concat(t.z.times)), e = e.sort((function (t, e) { return t - e })).filter((function (t, e, r) { return r.indexOf(t) == e })) }, getKeyframeTrackValues: function (t, e, r) { var n = r, i = [], o = -1, a = -1, s = -1; return t.forEach((function (t) { if (e.x && (o = e.x.times.indexOf(t)), e.y && (a = e.y.times.indexOf(t)), e.z && (s = e.z.times.indexOf(t)), -1 !== o) { var r = e.x.values[o]; i.push(r), n[0] = r } else i.push(n[0]); if (-1 !== a) { var c = e.y.values[a]; i.push(c), n[1] = c } else i.push(n[1]); if (-1 !== s) { var l = e.z.values[s]; i.push(l), n[2] = l } else i.push(n[2]) })), i }, interpolateRotations: function (t) { for (var e = 1; e < t.values.length; e++) { var r = t.values[e - 1], n = t.values[e] - r, i = Math.abs(n); if (i >= 180) { for (var o = i / 180, a = n / o, s = r + a, c = t.times[e - 1], l = (t.times[e] - c) / o, h = c + l, u = [], p = []; h < t.times[e];)u.push(h), h += l, p.push(s), s += a; t.times = _(t.times, e, u), t.values = _(t.values, e, p) } } } }, c.prototype = { constructor: c, getPrevNode: function () { return this.nodeStack[this.currentIndent - 2] }, getCurrentNode: function () { return this.nodeStack[this.currentIndent - 1] }, getCurrentProp: function () { return this.currentProp }, pushStack: function (t) { this.nodeStack.push(t), this.currentIndent += 1 }, popStack: function () { this.nodeStack.pop(), this.currentIndent -= 1 }, setCurrentProp: function (t, e) { this.currentProp = t, this.currentPropName = e }, parse: function (t) { this.currentIndent = 0, this.allNodes = new u, this.nodeStack = [], this.currentProp = [], this.currentPropName = ""; var e = this, r = t.split(/[\r\n]+/); return r.forEach((function (t, n) { var i = t.match(/^[\s\t]*;/), o = t.match(/^[\s\t]*$/); if (!i && !o) { var a = t.match("^\\t{" + e.currentIndent + "}(\\w+):(.*){", ""), s = t.match("^\\t{" + e.currentIndent + "}(\\w+):[\\s\\t\\r\\n](.*)"), c = t.match("^\\t{" + (e.currentIndent - 1) + "}}"); a ? e.parseNodeBegin(t, a) : s ? e.parseNodeProperty(t, s, r[++n]) : c ? e.popStack() : t.match(/^[^\s\t}]/) && e.parseNodePropertyContinued(t) } })), this.allNodes }, parseNodeBegin: function (t, e) { var r = e[1].trim().replace(/^"/, "").replace(/"$/, ""), n = e[2].split(",").map((function (t) { return t.trim().replace(/^"/, "").replace(/"$/, "") })), i = { name: r }, o = this.parseNodeAttr(n), a = this.getCurrentNode(); 0 === this.currentIndent ? this.allNodes.add(r, i) : r in a ? ("PoseNode" === r ? a.PoseNode.push(i) : void 0 !== a[r].id && (a[r] = {}, a[r][a[r].id] = a[r]), "" !== o.id && (a[r][o.id] = i)) : "number" == typeof o.id ? (a[r] = {}, a[r][o.id] = i) : "Properties70" !== r && (a[r] = "PoseNode" === r ? [i] : i), "number" == typeof o.id && (i.id = o.id), "" !== o.name && (i.attrName = o.name), "" !== o.type && (i.attrType = o.type), this.pushStack(i) }, parseNodeAttr: function (t) { var e = t[0]; "" !== t[0] && (e = parseInt(t[0]), isNaN(e) && (e = t[0])); var r = "", n = ""; return t.length > 1 && (r = t[1].replace(/^(\w+)::/, ""), n = t[2]), { id: e, name: r, type: n } }, parseNodeProperty: function (t, e, r) { var n = e[1].replace(/^"/, "").replace(/"$/, "").trim(), i = e[2].replace(/^"/, "").replace(/"$/, "").trim(); "Content" === n && "," === i && (i = r.replace(/"/g, "").replace(/,$/, "").trim()); var o = this.getCurrentNode(); if ("Properties70" !== o.name) { if ("C" === n) { var a = i.split(",").slice(1), s = parseInt(a[0]), c = parseInt(a[1]), l = i.split(",").slice(3); n = "connections", function (t, e) { for (var r = 0, n = t.length, i = e.length; r < i; r++, n++)t[n] = e[r] }(i = [s, c], l = l.map((function (t) { return t.trim().replace(/^"/, "") }))), void 0 === o[n] && (o[n] = []) } "Node" === n && (o.id = i), n in o && Array.isArray(o[n]) ? o[n].push(i) : "a" !== n ? o[n] = i : o.a = i, this.setCurrentProp(o, n), "a" === n && "," !== i.slice(-1) && (o.a = b(i)) } else this.parseNodeSpecialProperty(t, n, i) }, parseNodePropertyContinued: function (t) { var e = this.getCurrentNode(); e.a += t, "," !== t.slice(-1) && (e.a = b(e.a)) }, parseNodeSpecialProperty: function (t, e, r) { var n = r.split('",').map((function (t) { return t.trim().replace(/^\"/, "").replace(/\s/, "_") })), i = n[0], o = n[1], a = n[2], s = n[3], c = n[4]; switch (o) { case "int": case "enum": case "bool": case "ULongLong": case "double": case "Number": case "FieldOfView": c = parseFloat(c); break; case "Color": case "ColorRGB": case "Vector3D": case "Lcl_Translation": case "Lcl_Rotation": case "Lcl_Scaling": c = b(c) }this.getPrevNode()[i] = { type: o, type2: a, flag: s, value: c }, this.setCurrentProp(this.getPrevNode(), i) } }, l.prototype = { constructor: l, parse: function (t) { var e = new h(t); e.skip(23); var r = e.getUint32(); console.log("THREE.FBXLoader: FBX binary version: " + r); for (var n = new u; !this.endOfContent(e);) { var i = this.parseNode(e, r); null !== i && n.add(i.name, i) } return n }, endOfContent: function (t) { return t.size() % 16 == 0 ? (t.getOffset() + 160 + 16 & -16) >= t.size() : t.getOffset() + 160 + 16 >= t.size() }, parseNode: function (t, e) { var r = {}, n = e >= 7500 ? t.getUint64() : t.getUint32(), i = e >= 7500 ? t.getUint64() : t.getUint32(), o = (e >= 7500 ? t.getUint64() : t.getUint32(), t.getUint8()), a = t.getString(o); if (0 === n) return null; for (var s = [], c = 0; c < i; c++)s.push(this.parseProperty(t)); var l = s.length > 0 ? s[0] : "", h = s.length > 1 ? s[1] : "", u = s.length > 2 ? s[2] : ""; for (r.singleProperty = 1 === i && t.getOffset() === n; n > t.getOffset();) { var p = this.parseNode(t, e); null !== p && this.parseSubNode(a, r, p) } return r.propertyList = s, "number" == typeof l && (r.id = l), "" !== h && (r.attrName = h), "" !== u && (r.attrType = u), "" !== a && (r.name = a), r }, parseSubNode: function (t, e, r) { if (!0 === r.singleProperty) { var n = r.propertyList[0]; Array.isArray(n) ? (e[r.name] = r, r.a = n) : e[r.name] = n } else if ("Connections" === t && "C" === r.name) { var i = []; r.propertyList.forEach((function (t, e) { 0 !== e && i.push(t) })), void 0 === e.connections && (e.connections = []), e.connections.push(i) } else if ("Properties70" === r.name) { Object.keys(r).forEach((function (t) { e[t] = r[t] })) } else if ("Properties70" === t && "P" === r.name) { var o, a = r.propertyList[0], s = r.propertyList[1], c = r.propertyList[2], l = r.propertyList[3]; 0 === a.indexOf("Lcl ") && (a = a.replace("Lcl ", "Lcl_")), 0 === s.indexOf("Lcl ") && (s = s.replace("Lcl ", "Lcl_")), o = "Color" === s || "ColorRGB" === s || "Vector" === s || "Vector3D" === s || 0 === s.indexOf("Lcl_") ? [r.propertyList[4], r.propertyList[5], r.propertyList[6]] : r.propertyList[4], e[a] = { type: s, type2: c, flag: l, value: o } } else void 0 === e[r.name] ? "number" == typeof r.id ? (e[r.name] = {}, e[r.name][r.id] = r) : e[r.name] = r : "PoseNode" === r.name ? (Array.isArray(e[r.name]) || (e[r.name] = [e[r.name]]), e[r.name].push(r)) : void 0 === e[r.name][r.id] && (e[r.name][r.id] = r) }, parseProperty: function (t) { var e = t.getString(1); switch (e) { case "C": return t.getBoolean(); case "D": return t.getFloat64(); case "F": return t.getFloat32(); case "I": return t.getInt32(); case "L": return t.getInt64(); case "R": var r = t.getUint32(); return t.getArrayBuffer(r); case "S": r = t.getUint32(); return t.getString(r); case "Y": return t.getInt16(); case "b": case "c": case "d": case "f": case "i": case "l": var n = t.getUint32(), i = t.getUint32(), o = t.getUint32(); if (0 === i) switch (e) { case "b": case "c": return t.getBooleanArray(n); case "d": return t.getFloat64Array(n); case "f": return t.getFloat32Array(n); case "i": return t.getInt32Array(n); case "l": return t.getInt64Array(n) }void 0 === j && console.error("THREE.FBXLoader: External library Inflate.min.js required, obtain or import from https://github.com/imaya/zlib.js"); var a = new h(new j.Inflate(new Uint8Array(t.getArrayBuffer(o))).decompress().buffer); switch (e) { case "b": case "c": return a.getBooleanArray(n); case "d": return a.getFloat64Array(n); case "f": return a.getFloat32Array(n); case "i": return a.getInt32Array(n); case "l": return a.getInt64Array(n) }default: throw new Error("THREE.FBXLoader: Unknown property type " + e) } } }, h.prototype = { constructor: h, getOffset: function () { return this.offset }, size: function () { return this.dv.buffer.byteLength }, skip: function (t) { this.offset += t }, getBoolean: function () { return 1 == (1 & this.getUint8()) }, getBooleanArray: function (t) { for (var e = [], r = 0; r < t; r++)e.push(this.getBoolean()); return e }, getUint8: function () { var t = this.dv.getUint8(this.offset); return this.offset += 1, t }, getInt16: function () { var t = this.dv.getInt16(this.offset, this.littleEndian); return this.offset += 2, t }, getInt32: function () { var t = this.dv.getInt32(this.offset, this.littleEndian); return this.offset += 4, t }, getInt32Array: function (t) { for (var e = [], r = 0; r < t; r++)e.push(this.getInt32()); return e }, getUint32: function () { var t = this.dv.getUint32(this.offset, this.littleEndian); return this.offset += 4, t }, getInt64: function () { var t, e; return this.littleEndian ? (t = this.getUint32(), e = this.getUint32()) : (e = this.getUint32(), t = this.getUint32()), 2147483648 & e ? (e = 4294967295 & ~e, 4294967295 === (t = 4294967295 & ~t) && (e = e + 1 & 4294967295), -(4294967296 * e + (t = t + 1 & 4294967295))) : 4294967296 * e + t }, getInt64Array: function (t) { for (var e = [], r = 0; r < t; r++)e.push(this.getInt64()); return e }, getUint64: function () { var t, e; return this.littleEndian ? (t = this.getUint32(), e = this.getUint32()) : (e = this.getUint32(), t = this.getUint32()), 4294967296 * e + t }, getFloat32: function () { var t = this.dv.getFloat32(this.offset, this.littleEndian); return this.offset += 4, t }, getFloat32Array: function (t) { for (var e = [], r = 0; r < t; r++)e.push(this.getFloat32()); return e }, getFloat64: function () { var t = this.dv.getFloat64(this.offset, this.littleEndian); return this.offset += 8, t }, getFloat64Array: function (t) { for (var e = [], r = 0; r < t; r++)e.push(this.getFloat64()); return e }, getArrayBuffer: function (t) { var e = this.dv.buffer.slice(this.offset, this.offset + t); return this.offset += t, e }, getString: function (t) { for (var e = [], r = 0; r < t; r++)e[r] = this.getUint8(); var i = e.indexOf(0); return i >= 0 && (e = e.slice(0, i)), n.v.decodeText(new Uint8Array(e)) } }, u.prototype = { constructor: u, add: function (t, e) { this[t] = e } }; var f = []; function m(t, e, r, n) { var i; switch (n.mappingType) { case "ByPolygonVertex": i = t; break; case "ByPolygon": i = e; break; case "ByVertice": i = r; break; case "AllSame": i = n.indices[0]; break; default: console.warn("THREE.FBXLoader: unknown attribute mapping type " + n.mappingType) }"IndexToDirect" === n.referenceType && (i = n.indices[i]); var o = i * n.dataSize, a = o + n.dataSize; return function (t, e, r, n) { for (var i = r, o = 0; i < n; i++, o++)t[o] = e[i]; return t }(f, n.buffer, o, a) } var v = new n.n, g = new n.W; function y(t) { var e, r = new n.y, i = new n.y, o = new n.y, a = new n.y, s = new n.y, c = new n.y, l = new n.y, h = new n.y, u = new n.y, p = new n.y, d = new n.y, f = t.inheritType ? t.inheritType : 0; (t.translation && r.setPosition(g.fromArray(t.translation)), t.preRotation) && ((e = t.preRotation.map(n.w.degToRad)).push(t.eulerOrder), i.makeRotationFromEuler(v.fromArray(e))); t.rotation && ((e = t.rotation.map(n.w.degToRad)).push(t.eulerOrder), o.makeRotationFromEuler(v.fromArray(e))); t.postRotation && ((e = t.postRotation.map(n.w.degToRad)).push(t.eulerOrder), a.makeRotationFromEuler(v.fromArray(e))); t.scale && s.scale(g.fromArray(t.scale)), t.scalingOffset && l.setPosition(g.fromArray(t.scalingOffset)), t.scalingPivot && c.setPosition(g.fromArray(t.scalingPivot)), t.rotationOffset && h.setPosition(g.fromArray(t.rotationOffset)), t.rotationPivot && u.setPosition(g.fromArray(t.rotationPivot)), t.parentMatrixWorld && (p = t.parentMatrixWorld); var m = i.multiply(o).multiply(a), y = new n.y; p.extractRotation(y); var x, b, w, _, M = new n.y; if (M.copyPosition(p), w = M.getInverse(M).multiply(p), b = y.getInverse(y).multiply(w), x = s, 0 === f) _ = y.multiply(m).multiply(b).multiply(x); else if (1 === f) _ = y.multiply(b).multiply(m).multiply(x); else { var S = (new n.y).copy(s), T = b.multiply(S.getInverse(S)); _ = y.multiply(m).multiply(T).multiply(x) } var E = r.multiply(h).multiply(u).multiply(i).multiply(o).multiply(a).multiply(u.getInverse(u)).multiply(l).multiply(c).multiply(s).multiply(c.getInverse(c)), A = (new n.y).copyPosition(E), L = p.multiply(A); return d.copyPosition(L), E = d.multiply(_) } function x(t) { var e = ["ZYX", "YZX", "XZY", "ZXY", "YXZ", "XYZ"]; return 6 === (t = t || 0) ? (console.warn("THREE.FBXLoader: unsupported Euler Order: Spherical XYZ. Animations and rotations may be incorrect."), e[0]) : e[t] } function b(t) { return t.split(",").map((function (t) { return parseFloat(t) })) } function w(t, e, r) { return void 0 === e && (e = 0), void 0 === r && (r = t.byteLength), n.v.decodeText(new Uint8Array(t, e, r)) } function _(t, e, r) { return t.slice(0, e).concat(r).concat(t.slice(e)) } return i }() }, mNyV: function (t, e, r) { "use strict"; t.exports = function (t) { if ("string" != typeof t) throw new TypeError("expected a string"); return (t = (t = (t = t.replace(/([a-z])([A-Z])/g, "$1-$2")).replace(/[ \t\W]/g, "-")).replace(/^-+|-+$/g, "")).toLowerCase() } }, p46w: function (t, e, r) { var n, i; !function (o) { if (void 0 === (i = "function" == typeof (n = o) ? n.call(e, r, e, t) : n) || (t.exports = i), !0, t.exports = o(), !!0) { var a = window.Cookies, s = window.Cookies = o(); s.noConflict = function () { return window.Cookies = a, s } } }((function () { function t() { for (var t = 0, e = {}; t < arguments.length; t++) { var r = arguments[t]; for (var n in r) e[n] = r[n] } return e } function e(t) { return t.replace(/(%[0-9A-Z]{2})+/g, decodeURIComponent) } return function r(n) { function i() { } function o(e, r, o) { if ("undefined" != typeof document) { "number" == typeof (o = t({ path: "/" }, i.defaults, o)).expires && (o.expires = new Date(1 * new Date + 864e5 * o.expires)), o.expires = o.expires ? o.expires.toUTCString() : ""; try { var a = JSON.stringify(r); /^[\{\[]/.test(a) && (r = a) } catch (t) { } r = n.write ? n.write(r, e) : encodeURIComponent(String(r)).replace(/%(23|24|26|2B|3A|3C|3E|3D|2F|3F|40|5B|5D|5E|60|7B|7D|7C)/g, decodeURIComponent), e = encodeURIComponent(String(e)).replace(/%(23|24|26|2B|5E|60|7C)/g, decodeURIComponent).replace(/[\(\)]/g, escape); var s = ""; for (var c in o) o[c] && (s += "; " + c, !0 !== o[c] && (s += "=" + o[c].split(";")[0])); return document.cookie = e + "=" + r + s } } function a(t, r) { if ("undefined" != typeof document) { for (var i = {}, o = document.cookie ? document.cookie.split("; ") : [], a = 0; a < o.length; a++) { var s = o[a].split("="), c = s.slice(1).join("="); r || '"' !== c.charAt(0) || (c = c.slice(1, -1)); try { var l = e(s[0]); if (c = (n.read || n)(c, l) || e(c), r) try { c = JSON.parse(c) } catch (t) { } if (i[l] = c, t === l) break } catch (t) { } } return t ? i[t] : i } } return i.set = o, i.get = function (t) { return a(t, !1) }, i.getJSON = function (t) { return a(t, !0) }, i.remove = function (e, r) { o(e, "", t(r, { expires: -1 })) }, i.defaults = {}, i.withConverter = r, i }((function () { })) })) }, "pc+1": function (t, e, r) { "use strict"; function n(t) { if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return t } function i(t, e) { t.prototype = Object.create(e.prototype), t.prototype.constructor = t, t.__proto__ = e } r.d(e, "a", (function () { return Pe })), r.d(e, "b", (function () { return tr })), r.d(e, "w", (function () { return ir })), r.d(e, "u", (function () { return ir })), r.d(e, "v", (function () { return Xt })), r.d(e, "h", (function () { return gt })), r.d(e, "m", (function () { return Z })), r.d(e, "j", (function () { return B })), r.d(e, "k", (function () { return G })), r.d(e, "p", (function () { return Ye })), r.d(e, "o", (function () { return Q })), r.d(e, "f", (function () { return yt })), r.d(e, "s", (function () { return $e })), r.d(e, "d", (function () { return ve })), r.d(e, "q", (function () { return ie })), r.d(e, "c", (function () { return De })), r.d(e, "n", (function () { return ht })), r.d(e, "t", (function () { return ge })), r.d(e, "e", (function () { return R })), r.d(e, "r", (function () { return xt })), r.d(e, "l", (function () { return nt })), r.d(e, "i", (function () { return We })), r.d(e, "g", (function () { return vt })); var o, a, s, c, l, h, u, p, d, f, m, v, g, y, x, b, w, _, M, S, T, E, A, L, P, R = { autoSleep: 120, force3D: "auto", nullTargetWarn: 1, units: { lineHeight: "" } }, C = { duration: .5, overwrite: !1, delay: 0 }, O = 1e-8, I = 2 * Math.PI, N = I / 4, D = 0, z = Math.sqrt, F = Math.cos, U = Math.sin, B = function (t) { return "string" == typeof t }, k = function (t) { return "function" == typeof t }, j = function (t) { return "number" == typeof t }, G = function (t) { return void 0 === t }, V = function (t) { return "object" == typeof t }, H = function (t) { return !1 !== t }, W = function () { return "undefined" != typeof window }, q = function (t) { return k(t) || B(t) }, X = Array.isArray, Y = /(?:-?\.?\d|\.)+/gi, Z = /[-+=\.]*\d+[\.e\-\+]*\d*[e\-\+]*\d*/g, J = /[-+=\.]*\d+(?:\.|e-|e)*\d*/gi, K = /\(([^()]+)\)/i, Q = /[\+-]=-?[\.\d]+/, $ = /[#\-+\.]*\b[a-z\d-=+%.]+/gi, tt = {}, et = {}, rt = function (t) { return (et = Lt(t, tt)) && ir }, nt = function (t, e) { return console.warn("Invalid property", t, "set to", e, "Missing plugin? gsap.registerPlugin()") }, it = function (t, e) { return !e && console.warn(t) }, ot = function (t, e) { return t && (tt[t] = e) && et && (et[t] = e) || tt }, at = function () { return 0 }, st = {}, ct = [], lt = {}, ht = {}, ut = {}, pt = 30, dt = [], ft = "onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt", mt = function (t) { var e, r, n = t[0]; if (V(n) || k(n) || (t = [t]), !(e = (n._gsap || {}).harness)) { for (r = dt.length; r-- && !dt[r].targetTest(n);); e = dt[r] } for (r = t.length; r--;)t[r] && (t[r]._gsap || (t[r]._gsap = new Pe(t[r], e))) || t.splice(r, 1); return t }, vt = function (t) { return t._gsap || mt(Kt(t))[0]._gsap }, gt = function (t, e) { var r = t[e]; return k(r) ? t[e]() : G(r) && t.getAttribute(e) || r }, yt = function (t, e) { return (t = t.split(",")).forEach(e) || t }, xt = function (t) { return Math.round(1e4 * t) / 1e4 }, bt = function (t, e) { for (var r = e.length, n = 0; t.indexOf(e[n]) < 0 && ++n < r;); return n < r }, wt = function (t, e, r) { var n, i = j(t[1]), o = (i ? 2 : 1) + (e < 2 ? 0 : 1), a = t[o]; if (i && (a.duration = t[1]), a.parent = r, e) { for (n = a; r && !("immediateRender" in n);)n = r.vars.defaults || {}, r = H(r.vars.inherit) && r.parent; a.immediateRender = H(n.immediateRender), e < 2 ? a.runBackwards = 1 : a.startAt = t[o - 1] } return a }, _t = function () { var t, e, r = ct.length, n = ct.slice(0); for (lt = {}, ct.length = 0, t = 0; t < r; t++)(e = n[t]) && e._lazy && (e.render(e._lazy[0], e._lazy[1], !0)._lazy = 0) }, Mt = function (t, e, r, n) { ct.length && _t(), t.render(e, r, n), ct.length && _t() }, St = function (t) { var e = parseFloat(t); return (e || 0 === e) && (t + "").match($).length < 2 ? e : t }, Tt = function (t) { return t }, Et = function (t, e) { for (var r in e) r in t || (t[r] = e[r]); return t }, At = function (t, e) { for (var r in e) r in t || "duration" === r || "ease" === r || (t[r] = e[r]) }, Lt = function (t, e) { for (var r in e) t[r] = e[r]; return t }, Pt = function t(e, r) { for (var n in r) e[n] = V(r[n]) ? t(e[n] || (e[n] = {}), r[n]) : r[n]; return e }, Rt = function (t, e) { var r, n = {}; for (r in t) r in e || (n[r] = t[r]); return n }, Ct = function (t) { var e = t.parent || o, r = t.keyframes ? At : Et; if (H(t.inherit)) for (; e;)r(t, e.vars.defaults), e = e.parent; return t }, Ot = function (t, e, r, n) { void 0 === r && (r = "_first"), void 0 === n && (n = "_last"); var i = e._prev, o = e._next; i ? i._next = o : t[r] === e && (t[r] = o), o ? o._prev = i : t[n] === e && (t[n] = i), e._dp = t, e._next = e._prev = e.parent = null }, It = function (t, e) { !t.parent || e && !t.parent.autoRemoveChildren || t.parent.remove(t), t._act = 0 }, Nt = function (t) { for (var e = t; e;)e._dirty = 1, e = e.parent; return t }, Dt = function (t) { for (var e = t.parent; e && e.parent;)e._dirty = 1, e.totalDuration(), e = e.parent; return t }, zt = function t(e) { return !e || e._ts && t(e.parent) }, Ft = function (t) { return t._repeat ? Ut(t._tTime, t = t.duration() + t._rDelay) * t : 0 }, Ut = function (t, e) { return (t /= e) && ~~t === t ? ~~t - 1 : ~~t }, Bt = function (t, e) { return (t - e._start) * e._ts + (e._ts >= 0 ? 0 : e._dirty ? e.totalDuration() : e._tDur) }, kt = function (t, e, r) { if (e.parent && It(e), e._start = r + e._delay, e._end = e._start + (e.totalDuration() / Math.abs(e.timeScale()) || 0), function (t, e, r, n, i) { void 0 === r && (r = "_first"), void 0 === n && (n = "_last"); var o, a = t[n]; if (i) for (o = e[i]; a && a[i] > o;)a = a._prev; a ? (e._next = a._next, a._next = e) : (e._next = t[r], t[r] = e), e._next ? e._next._prev = e : t[n] = e, e._prev = a, e.parent = t }(t, e, "_first", "_last", t._sort ? "_start" : 0), t._recent = e, e._time || !e._dur && e._initted) { var n = (t.rawTime() - e._start) * e._ts; (!e._dur || qt(0, e.totalDuration(), n) - e._tTime > O) && e.render(n, !0) } if (Nt(t), t._dp && t._time >= t._dur && t._ts && t._dur < t.duration()) for (var i = t; i._dp;)i.totalTime(i._tTime, !0), i = i._dp; return t }, jt = function (t, e, r, n) { return ze(t, e), t._initted ? !r && t._pt && (t._dur && !1 !== t.vars.lazy || !t._dur && t.vars.lazy) && h !== ge.frame ? (ct.push(t), t._lazy = [e, n], 1) : void 0 : 1 }, Gt = function (t) { if (t instanceof Ce) return Nt(t); var e = t._repeat; return t._tDur = e ? e < 0 ? 1e12 : xt(t._dur * (e + 1) + t._rDelay * e) : t._dur, Nt(t.parent), t }, Vt = { _start: 0, endTime: at }, Ht = function t(e, r, n) { var i, o, a = e.labels, s = e._recent || Vt, c = e.duration() >= 1e8 ? s.endTime(!1) : e._dur; return B(r) && (isNaN(r) || r in a) ? "<" === (i = r.charAt(0)) || ">" === i ? ("<" === i ? s._start : s.endTime(s._repeat >= 0)) + (parseFloat(r.substr(1)) || 0) : (i = r.indexOf("=")) < 0 ? (r in a || (a[r] = c), a[r]) : (o = +(r.charAt(i - 1) + r.substr(i + 1)), i > 1 ? t(e, r.substr(0, i - 1)) + o : c + o) : null == r ? c : +r }, Wt = function (t, e) { return t || 0 === t ? e(t) : e }, qt = function (t, e, r) { return r < t ? t : r > e ? e : r }, Xt = function (t) { return (t + "").substr((parseFloat(t) + "").length) }, Yt = [].slice, Zt = function (t, e) { return t && V(t) && "length" in t && (!e && !t.length || t.length - 1 in t && V(t[0])) && !t.nodeType && t !== a }, Jt = function (t, e, r) { return void 0 === r && (r = []), t.forEach((function (t) { var n; return B(t) && !e || Zt(t, 1) ? (n = r).push.apply(n, Kt(t)) : r.push(t) })) || r }, Kt = function (t, e) { return !B(t) || e || !s && ye() ? X(t) ? Jt(t, e) : Zt(t) ? Yt.call(t, 0) : t ? [t] : [] : Yt.call(c.querySelectorAll(t), 0) }, Qt = function (t) { return t.sort((function () { return .5 - Math.random() })) }, $t = function (t) { if (k(t)) return t; var e = V(t) ? t : { each: t }, r = Se(e.ease), n = e.from || 0, i = parseFloat(e.base) || 0, o = {}, a = n > 0 && n < 1, s = isNaN(n) || a, c = e.axis, l = n, h = n; return B(n) ? l = h = { center: .5, edges: .5, end: 1 }[n] || 0 : !a && s && (l = n[0], h = n[1]), function (t, a, u) { var p, d, f, m, v, g, y, x, b, w = (u || e).length, _ = o[w]; if (!_) { if (!(b = "auto" === e.grid ? 0 : (e.grid || [1, 1e8])[1])) { for (y = -1e8; y < (y = u[b++].getBoundingClientRect().left) && b < w;); b-- } for (_ = o[w] = [], p = s ? Math.min(b, w) * l - .5 : n % b, d = s ? w * h / b - .5 : n / b | 0, y = 0, x = 1e8, g = 0; g < w; g++)f = g % b - p, m = d - (g / b | 0), _[g] = v = c ? Math.abs("y" === c ? m : f) : z(f * f + m * m), v > y && (y = v), v < x && (x = v); "random" === n && Qt(_), _.max = y - x, _.min = x, _.v = w = (parseFloat(e.amount) || parseFloat(e.each) * (b > w ? w - 1 : c ? "y" === c ? w / b : b : Math.max(b, w / b)) || 0) * ("edges" === n ? -1 : 1), _.b = w < 0 ? i - w : i, _.u = Xt(e.amount || e.each) || 0, r = r && w < 0 ? Me(r) : r } return w = (_[t] - _.min) / _.max || 0, xt(_.b + (r ? r(w) : w) * _.v) + _.u } }, te = function (t) { var e = t < 1 ? Math.pow(10, (t + "").length - 2) : 1; return function (r) { return ~~(Math.round(parseFloat(r) / t) * t * e) / e + (j(r) ? 0 : Xt(r)) } }, ee = function (t, e) { var r, n, i = X(t); return !i && V(t) && (r = i = t.radius || 1e8, t.values ? (t = Kt(t.values), (n = !j(t[0])) && (r *= r)) : t = te(t.increment)), Wt(e, i ? k(t) ? function (e) { return n = t(e), Math.abs(n - e) <= r ? n : e } : function (e) { for (var i, o, a = parseFloat(n ? e.x : e), s = parseFloat(n ? e.y : 0), c = 1e8, l = 0, h = t.length; h--;)(i = n ? (i = t[h].x - a) * i + (o = t[h].y - s) * o : Math.abs(t[h] - a)) < c && (c = i, l = h); return l = !r || c <= r ? t[l] : e, n || l === e || j(e) ? l : l + Xt(e) } : te(t)) }, re = function (t, e, r, n) { return Wt(X(t) ? !e : !0 === r ? !!(r = 0) : !n, (function () { return X(t) ? t[~~(Math.random() * t.length)] : (r = r || 1e-5) && (n = r < 1 ? Math.pow(10, (r + "").length - 2) : 1) && ~~(Math.round((t + Math.random() * (e - t)) / r) * r * n) / n })) }, ne = function (t, e, r) { return Wt(r, (function (r) { return t[~~e(r)] })) }, ie = function (t) { for (var e, r, n, i, o = 0, a = ""; ~(e = t.indexOf("random(", o));)n = t.indexOf(")", e), i = "[" === t.charAt(e + 7), r = t.substr(e + 7, n - e - 7).match(i ? $ : Y), a += t.substr(o, e - o) + re(i ? r : +r[0], +r[1], +r[2] || 1e-5), o = n + 1; return a + t.substr(o, t.length - o) }, oe = function (t, e, r, n, i) { var o = e - t, a = n - r; return Wt(i, (function (e) { return r + (e - t) / o * a })) }, ae = function (t, e, r) { var n, i, o, a = t.labels, s = 1e8; for (n in a) (i = a[n] - e) < 0 == !!r && i && s > (i = Math.abs(i)) && (o = n, s = i); return o }, se = function (t, e, r) { var n, i, o = t.vars, a = o[e]; if (a) return n = o[e + "Params"], i = o.callbackScope || t, r && ct.length && _t(), n ? a.apply(i, n) : a.call(i) }, ce = function (t) { return It(t), t.progress() < 1 && se(t, "onInterrupt"), t }, le = function (t) { var e = (t = !t.name && t.default || t).name, r = k(t), n = e && !r && t.init ? function () { this._props = [] } : t, i = { init: at, render: Ze, add: Ne, kill: Ke, modifier: Je, rawVars: 0 }, o = { targetTest: 0, get: 0, getSetter: We, aliases: {}, register: 0 }; if (ye(), t !== n) { if (ht[e]) return; Et(n, Et(Rt(t, i), o)), Lt(n.prototype, Lt(i, Rt(t, o))), ht[n.prop = e] = n, t.targetTest && (dt.push(n), st[e] = 1), e = ("css" === e ? "CSS" : e.charAt(0).toUpperCase() + e.substr(1)) + "Plugin" } ot(e, n), t.register && t.register(ir, n, tr) }, he = { aqua: [0, 255, 255], lime: [0, 255, 0], silver: [192, 192, 192], black: [0, 0, 0], maroon: [128, 0, 0], teal: [0, 128, 128], blue: [0, 0, 255], navy: [0, 0, 128], white: [255, 255, 255], olive: [128, 128, 0], yellow: [255, 255, 0], orange: [255, 165, 0], gray: [128, 128, 128], purple: [128, 0, 128], green: [0, 128, 0], red: [255, 0, 0], pink: [255, 192, 203], cyan: [0, 255, 255], transparent: [255, 255, 255, 0] }, ue = function (t, e, r) { return 255 * (6 * (t = t < 0 ? t + 1 : t > 1 ? t - 1 : t) < 1 ? e + (r - e) * t * 6 : t < .5 ? r : 3 * t < 2 ? e + (r - e) * (2 / 3 - t) * 6 : e) + .5 | 0 }, pe = function (t, e) { var r, n, i, o, a, s, c, l, h, u, p = t ? j(t) ? [t >> 16, t >> 8 & 255, 255 & t] : 0 : he.black; if (!p) { if ("," === t.substr(-1) && (t = t.substr(0, t.length - 1)), he[t]) p = he[t]; else if ("#" === t.charAt(0)) 4 === t.length && (r = t.charAt(1), n = t.charAt(2), i = t.charAt(3), t = "#" + r + r + n + n + i + i), p = [(t = parseInt(t.substr(1), 16)) >> 16, t >> 8 & 255, 255 & t]; else if ("hsl" === t.substr(0, 3)) if (p = u = t.match(Y), e) { if (~t.indexOf("=")) return t.match(Z) } else o = +p[0] % 360 / 360, a = +p[1] / 100, r = 2 * (s = +p[2] / 100) - (n = s <= .5 ? s * (a + 1) : s + a - s * a), p.length > 3 && (p[3] *= 1), p[0] = ue(o + 1 / 3, r, n), p[1] = ue(o, r, n), p[2] = ue(o - 1 / 3, r, n); else p = t.match(Y) || he.transparent; p = p.map(Number) } return e && !u && (r = p[0] / 255, n = p[1] / 255, i = p[2] / 255, s = ((c = Math.max(r, n, i)) + (l = Math.min(r, n, i))) / 2, c === l ? o = a = 0 : (h = c - l, a = s > .5 ? h / (2 - c - l) : h / (c + l), o = c === r ? (n - i) / h + (n < i ? 6 : 0) : c === n ? (i - r) / h + 2 : (r - n) / h + 4, o *= 60), p[0] = o + .5 | 0, p[1] = 100 * a + .5 | 0, p[2] = 100 * s + .5 | 0), p }, de = function (t, e) { var r, n, i, o = (t + "").match(fe), a = 0, s = ""; if (!o) return t; for (r = 0; r < o.length; r++)n = o[r], a += (i = t.substr(a, t.indexOf(n, a) - a)).length + n.length, 3 === (n = pe(n, e)).length && n.push(1), s += i + (e ? "hsla(" + n[0] + "," + n[1] + "%," + n[2] + "%," + n[3] : "rgba(" + n.join(",")) + ")"; return s + t.substr(a) }, fe = function () { var t, e = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3}){1,2}\\b"; for (t in he) e += "|" + t + "\\b"; return new RegExp(e + ")", "gi") }(), me = /hsl[a]?\(/, ve = function (t) { var e, r = t.join(" "); fe.lastIndex = 0, fe.test(r) && (e = me.test(r), t[0] = de(t[0], e), t[1] = de(t[1], e)) }, ge = (g = Date.now, y = 500, x = 33, b = g(), w = b, M = _ = 1 / 60, T = function t(e) { var r, n, i = g() - w, o = !0 === e; i > y && (b += i - x), w += i, v.time = (w - b) / 1e3, ((r = v.time - M) > 0 || o) && (v.frame++, M += r + (r >= _ ? .004 : _ - r), n = 1), o || (d = f(t)), n && S.forEach((function (t) { return t(v.time, i, v.frame, e) })) }, v = { time: 0, frame: 0, tick: function () { T(!0) }, wake: function () { l && (!s && W() && (a = s = window, c = a.document || {}, tt.gsap = ir, (a.gsapVersions || (a.gsapVersions = [])).push(ir.version), rt(et || a.GreenSockGlobals || !a.gsap && a || {}), m = a.requestAnimationFrame), d && v.sleep(), f = m || function (t) { return setTimeout(t, 1e3 * (M - v.time) + 1 | 0) }, p = 1, T(2)) }, sleep: function () { (m ? a.cancelAnimationFrame : clearTimeout)(d), p = 0, f = at }, lagSmoothing: function (t, e) { y = t || 1 / O, x = Math.min(e, y, 0) }, fps: function (t) { _ = 1 / (t || 60), M = v.time + _ }, add: function (t) { S.indexOf(t) < 0 && S.push(t), ye() }, remove: function (t) { var e; ~(e = S.indexOf(t)) && S.splice(e, 1) }, _listeners: S = [] }), ye = function () { return !p && ge.wake() }, xe = {}, be = /^[\d.\-M][\d.\-,\s]/, we = /["']/g, _e = function (t) { for (var e, r, n, i = {}, o = t.substr(1, t.length - 3).split(":"), a = o[0], s = 1, c = o.length; s < c; s++)r = o[s], e = s !== c - 1 ? r.lastIndexOf(",") : r.length, n = r.substr(0, e), i[a] = isNaN(n) ? n.replace(we, "").trim() : +n, a = r.substr(e + 1).trim(); return i }, Me = function (t) { return function (e) { return 1 - t(1 - e) } }, Se = function (t, e) { return t && (k(t) ? t : xe[t] || function (t) { var e = (t + "").split("("), r = xe[e[0]]; return r && e.length > 1 && r.config ? r.config.apply(null, ~t.indexOf("{") ? [_e(e[1])] : K.exec(t)[1].split(",").map(St)) : xe._CE && be.test(t) ? xe._CE("", t) : r }(t)) || e }, Te = function (t, e, r, n) { void 0 === r && (r = function (t) { return 1 - e(1 - t) }), void 0 === n && (n = function (t) { return t < .5 ? e(2 * t) / 2 : 1 - e(2 * (1 - t)) / 2 }); var i, o = { easeIn: e, easeOut: r, easeInOut: n }; return yt(t, (function (t) { for (var e in xe[t] = tt[t] = o, xe[i = t.toLowerCase()] = r, o) xe[i + ("easeIn" === e ? ".in" : "easeOut" === e ? ".out" : ".inOut")] = xe[t + "." + e] = o[e] })), o }, Ee = function (t) { return function (e) { return e < .5 ? (1 - t(1 - 2 * e)) / 2 : .5 + t(2 * (e - .5)) / 2 } }, Ae = function t(e, r, n) { var i = r >= 1 ? r : 1, o = (n || (e ? .3 : .45)) / (r < 1 ? r : 1), a = o / I * (Math.asin(1 / i) || 0), s = function (t) { return 1 === t ? 1 : i * Math.pow(2, -10 * t) * U((t - a) * o) + 1 }, c = "out" === e ? s : "in" === e ? function (t) { return 1 - s(1 - t) } : Ee(s); return o = I / o, c.config = function (r, n) { return t(e, r, n) }, c }, Le = function t(e, r) { void 0 === r && (r = 1.70158); var n = function (t) { return --t * t * ((r + 1) * t + r) + 1 }, i = "out" === e ? n : "in" === e ? function (t) { return 1 - n(1 - t) } : Ee(n); return i.config = function (r) { return t(e, r) }, i }; yt("Linear,Quad,Cubic,Quart,Quint,Strong", (function (t, e) { var r = e < 5 ? e + 1 : e; Te(t + ",Power" + (r - 1), e ? function (t) { return Math.pow(t, r) } : function (t) { return t }, (function (t) { return 1 - Math.pow(1 - t, r) }), (function (t) { return t < .5 ? Math.pow(2 * t, r) / 2 : 1 - Math.pow(2 * (1 - t), r) / 2 })) })), xe.Linear.easeNone = xe.none = xe.Linear.easeIn, Te("Elastic", Ae("in"), Ae("out"), Ae()), E = 7.5625, L = 1 / (A = 2.75), Te("Bounce", (function (t) { return 1 - P(1 - t) }), P = function (t) { return t < L ? E * t * t : t < .7272727272727273 ? E * Math.pow(t - 1.5 / A, 2) + .75 : t < .9090909090909092 ? E * (t -= 2.25 / A) * t + .9375 : E * Math.pow(t - 2.625 / A, 2) + .984375 }), Te("Expo", (function (t) { return t ? Math.pow(2, 10 * (t - 1)) : 0 })), Te("Circ", (function (t) { return -(z(1 - t * t) - 1) })), Te("Sine", (function (t) { return 1 - F(t * N) })), Te("Back", Le("in"), Le("out"), Le()), xe.SteppedEase = xe.steps = tt.SteppedEase = { config: function (t, e) { void 0 === t && (t = 1); var r = 1 / t, n = t + (e ? 0 : 1), i = e ? 1 : 0, o = 1 - O; return function (t) { return ((n * qt(0, o, t) | 0) + i) * r } } }, C.ease = xe["quad.out"]; var Pe = function (t, e) { this.id = D++, t._gsap = this, this.target = t, this.harness = e, this.get = e ? e.get : gt, this.set = e ? e.getSetter : We }, Re = function () { function t(t, e) { var r = t.parent || o; this.vars = t, this._dur = this._tDur = +t.duration || 0, this._delay = +t.delay || 0, (this._repeat = t.repeat || 0) && (this._rDelay = t.repeatDelay || 0, this._yoyo = !!t.yoyo || !!t.yoyoEase, Gt(this)), this._ts = 1, this.data = t.data, p || ge.wake(), r && kt(r, this, e || 0 === e ? e : r._time), t.reversed && this.reversed(!0), t.paused && this.paused(!0) } var e = t.prototype; return e.delay = function (t) { return t || 0 === t ? (this._delay = t, this) : this._delay }, e.duration = function (t) { var e = arguments.length, r = this._repeat, n = r > 0 ? r * ((e ? t : this._dur) + this._rDelay) : 0; return e ? this.totalDuration(r < 0 ? t : t + n) : this.totalDuration() && this._dur }, e.totalDuration = function (t) { if (!arguments.length) return this._tDur; var e = this._repeat, r = (t || this._rDelay) && e < 0; return this._tDur = r ? 1e12 : t, this._dur = r ? t : (t - e * this._rDelay) / (e + 1), this._dirty = 0, Nt(this.parent), this }, e.totalTime = function (t, e) { if (ye(), !arguments.length) return this._tTime; var r, n = this.parent || this._dp; if (n && n.smoothChildTiming && this._ts) { for (r = this._start, this._start = n._time - (this._ts > 0 ? t / this._ts : ((this._dirty ? this.totalDuration() : this._tDur) - t) / -this._ts), this._end += this._start - r, n._dirty || Nt(n); n.parent;)n.parent._time !== n._start + (n._ts > 0 ? n._tTime / n._ts : (n.totalDuration() - n._tTime) / -n._ts) && n.totalTime(n._tTime, !0), n = n.parent; !this.parent && n.autoRemoveChildren && kt(n, this, this._start - this._delay) } return this._tTime === t && (this._dur || e) || (this._ts || (this._pTime = t), Mt(this, t, e)), this }, e.time = function (t, e) { return arguments.length ? this.totalTime(Math.min(this.totalDuration(), t + Ft(this)) % this._dur || (t ? this._dur : 0), e) : this._time }, e.totalProgress = function (t, e) { return arguments.length ? this.totalTime(this.totalDuration() * t, e) : this._tTime / this.totalDuration() }, e.progress = function (t, e) { return arguments.length ? this.totalTime(this.duration() * (!this._yoyo || 1 & this.iteration() ? t : 1 - t) + Ft(this), e) : this.duration() ? this._time / this._dur : this.ratio }, e.iteration = function (t, e) { var r = this.duration() + this._rDelay; return arguments.length ? this.totalTime(this._time + (t - 1) * r, e) : this._repeat ? Ut(this._tTime, r) + 1 : 1 }, e.timeScale = function (t) { if (!arguments.length) return this._ts || this._pauseTS || 0; if (null !== this._pauseTS) return this._pauseTS = t, this; var e = this.parent && this._ts ? Bt(this.parent._time, this) : this._tTime; return this._ts = t, Dt(this.totalTime(e, !0)) }, e.paused = function (t) { var e = !this._ts; return arguments.length ? (e !== t && (t ? (this._pauseTS = this._ts, this._pTime = this._tTime || Math.max(-this._delay, this.rawTime()), this._ts = this._act = 0) : (this._ts = this._pauseTS || 1, this._pauseTS = null, t = this._tTime || this._pTime, 1 === this.progress() && (this._tTime -= O), this.totalTime(t, !0))), this) : e }, e.startTime = function (t) { return arguments.length ? (this.parent && this.parent._sort && kt(this.parent, this, t - this._delay), this) : this._start }, e.endTime = function (t) { return this._start + (H(t) ? this.totalDuration() : this.duration()) / Math.abs(this._ts) }, e.rawTime = function (t) { var e = this.parent || this._dp; return e ? t && (!this._ts || this._repeat && this._time && this.totalProgress() < 1) ? this._tTime % (this._dur + this._rDelay) : this._ts ? Bt(e.rawTime(t), this) : this._tTime : this._tTime }, e.repeat = function (t) { return arguments.length ? (this._repeat = t, Gt(this)) : this._repeat }, e.repeatDelay = function (t) { return arguments.length ? (this._rDelay = t, Gt(this)) : this._rDelay }, e.yoyo = function (t) { return arguments.length ? (this._yoyo = t, this) : this._yoyo }, e.seek = function (t, e) { return this.totalTime(Ht(this, t), H(e)) }, e.restart = function (t, e) { return this.play().totalTime(t ? -this._delay : 0, H(e)) }, e.play = function (t, e) { return null != t && this.seek(t, e), this.reversed(!1).paused(!1) }, e.reverse = function (t, e) { return null != t && this.seek(t || this.totalDuration(), e), this.reversed(!0).paused(!1) }, e.pause = function (t, e) { return null != t && this.seek(t, e), this.paused(!0) }, e.resume = function () { return this.paused(!1) }, e.reversed = function (t) { var e = this._ts || this._pauseTS || 0; return arguments.length ? (t !== this.reversed() && (this[null === this._pauseTS ? "_ts" : "_pauseTS"] = Math.abs(e) * (t ? -1 : 1), this.totalTime(this._tTime, !0)), this) : e < 0 }, e.invalidate = function () { return this._initted = 0, this }, e.isActive = function (t) { var e, r = this.parent || this._dp, n = this._start; return !(r && !(this._ts && (this._initted || !t) && r.isActive(t) && (e = r.rawTime(!0)) >= n && e < this.endTime(!0) - O)) }, e.eventCallback = function (t, e, r) { var n = this.vars; return arguments.length > 1 ? (e ? (n[t] = e, r && (n[t + "Params"] = r), "onUpdate" === t && (this._onUpdate = e)) : delete n[t], this) : n[t] }, e.then = function (t) { var e = this; return new Promise((function (r) { var n = k(t) ? t : Tt, i = function () { var t = e.then; e.then = null, (n = n(e)) && (n.then || n === e ? e.then = t : k(n) || (n = Tt)), r(n), e.then = t }; e._initted && 1 === e.totalProgress() && e._ts >= 0 || !e._tTime && e._ts < 0 ? i() : e._prom = i })) }, e.kill = function () { ce(this) }, t }(); Et(Re.prototype, { _time: 0, _start: 0, _end: 0, _tTime: 0, _tDur: 0, _dirty: 0, _repeat: 0, _yoyo: !1, parent: 0, _initted: !1, _rDelay: 0, _ts: 1, _dp: 0, ratio: 0, _zTime: -O, _prom: 0, _pauseTS: null }); var Ce = function (t) { function e(e, r) { var n; return void 0 === e && (e = {}), (n = t.call(this, e, r) || this).labels = {}, n.smoothChildTiming = H(e.smoothChildTiming), n.autoRemoveChildren = !!e.autoRemoveChildren, n._sort = H(e.sortChildren), n } i(e, t); var r = e.prototype; return r.to = function (t, e, r) { return new ke(t, wt(arguments, 0, this), Ht(this, j(e) ? arguments[3] : r)), this }, r.from = function (t, e, r) { return new ke(t, wt(arguments, 1, this), Ht(this, j(e) ? arguments[3] : r)), this }, r.fromTo = function (t, e, r, n) { return new ke(t, wt(arguments, 2, this), Ht(this, j(e) ? arguments[4] : n)), this }, r.set = function (t, e, r) { return e.duration = 0, e.parent = this, e.repeatDelay || (e.repeat = 0), e.immediateRender = !!e.immediateRender, new ke(t, e, Ht(this, r)), this }, r.call = function (t, e, r) { return kt(this, ke.delayedCall(0, t, e), Ht(this, r)) }, r.staggerTo = function (t, e, r, n, i, o, a) { return r.duration = e, r.stagger = r.stagger || n, r.onComplete = o, r.onCompleteParams = a, r.parent = this, new ke(t, r, Ht(this, i)), this }, r.staggerFrom = function (t, e, r, n, i, o, a) { return r.runBackwards = 1, r.immediateRender = H(r.immediateRender), this.staggerTo(t, e, r, n, i, o, a) }, r.staggerFromTo = function (t, e, r, n, i, o, a, s) { return n.startAt = r, n.immediateRender = H(n.immediateRender), this.staggerTo(t, e, n, i, o, a, s) }, r.render = function (t, e, r) { var n, i, a, s, c, l, h, u, p, d, f, m, v = this._time, g = this._dirty ? this.totalDuration() : this._tDur, y = this._dur, x = t > g - O && t >= 0 && this !== o ? g : t < O ? 0 : t, b = this._zTime < 0 != t < 0 && (this._initted || !y); if (x !== this._tTime || r || b) { if (b && (y || (v = this._zTime), !t && e || (this._zTime = t)), n = x, p = this._start, l = 0 === (u = this._ts), v !== this._time && y && (n += this._time - v), this._repeat && (f = this._yoyo, c = y + this._rDelay, ((n = xt(x % c)) > y || g === x) && (n = y), (s = ~~(x / c)) && s === x / c && (n = y, s--), f && 1 & s && (n = y - n, m = 1), s !== (d = Ut(this._tTime, c)) && !this._lock)) { var w = f && 1 & d, _ = w === (f && 1 & s); if (s < d && (w = !w), v = w ? 0 : y, this._lock = 1, this.render(v, e, !y)._lock = 0, !e && this.parent && se(this, "onRepeat"), this.vars.repeatRefresh && !m && this.getChildren().forEach((function (t) { return t.invalidate() })), v !== this._time || l !== !this._ts) return this; if (_ && (this._lock = 2, v = w ? y + 1e-4 : -1e-4, this.render(v, !0)), this._lock = 0, !this._ts && !l) return this } if (this._hasPause && !this._forcing && this._lock < 2 && (h = function (t, e, r) { var n; if (r > e) for (n = t._first; n && n._start <= r;) { if (!n._dur && "isPause" === n.data && n._start > e) return n; n = n._next } else for (n = t._last; n && n._start >= r;) { if (!n._dur && "isPause" === n.data && n._start < e) return n; n = n._prev } }(this, xt(v), xt(n))) && (x -= n - (n = h._start)), this._tTime = x, this._time = n, this._act = !u, this._initted || (this._onUpdate = this.vars.onUpdate, this._initted = 1), v || !n || e || se(this, "onStart"), n >= v && t >= 0) for (i = this._first; i;) { if (a = i._next, (i._act || n >= i._start) && i._ts && h !== i) { if (i.parent !== this) return this.render(t, e, r); if (i.render(i._ts > 0 ? (n - i._start) * i._ts : (i._dirty ? i.totalDuration() : i._tDur) + (n - i._start) * i._ts, e, r), n !== this._time || !this._ts && !l) { h = 0; break } } i = a } else { i = this._last; for (var M = t < 0 ? t : n; i;) { if (a = i._prev, (i._act || M <= i._end) && i._ts && h !== i) { if (i.parent !== this) return this.render(t, e, r); if (i.render(i._ts > 0 ? (M - i._start) * i._ts : (i._dirty ? i.totalDuration() : i._tDur) + (M - i._start) * i._ts, e, r), n !== this._time || !this._ts && !l) { h = 0; break } } i = a } } if (h && !e && (this.pause(), h.render(n >= v ? 0 : -O)._zTime = n >= v ? 1 : -1, this._ts)) return this._start = p, this.render(t, e, r); this._onUpdate && !e && se(this, "onUpdate", !0), (x === g && g >= this.totalDuration() || !x && this._ts < 0) && (p !== this._start && Math.abs(u) === Math.abs(this._ts) || ((t || !y) && (t && this._ts > 0 || !x && this._ts < 0) && It(this, 1), e || t < 0 && !v || (se(this, x === g ? "onComplete" : "onReverseComplete", !0), this._prom && this._prom()))) } return this }, r.add = function (t, e) { var r = this; if (j(e) || (e = Ht(this, e)), !(t instanceof Re)) { if (X(t)) return t.forEach((function (t) { return r.add(t, e) })), Nt(this); if (B(t)) return this.addLabel(t, e); if (!k(t)) return this; t = ke.delayedCall(0, t) } return this !== t ? kt(this, t, e) : this }, r.getChildren = function (t, e, r, n) { void 0 === t && (t = !0), void 0 === e && (e = !0), void 0 === r && (r = !0), void 0 === n && (n = -1e8); for (var i = [], o = this._first; o;)o._start >= n && (o instanceof ke ? e && i.push(o) : (r && i.push(o), t && i.push.apply(i, o.getChildren(!0, e, r)))), o = o._next; return i }, r.getById = function (t) { for (var e = this.getChildren(1, 1, 1), r = e.length; r--;)if (e[r].vars.id === t) return e[r] }, r.remove = function (t) { return B(t) ? this.removeLabel(t) : k(t) ? this.killTweensOf(t) : (Ot(this, t), t === this._recent && (this._recent = this._last), Nt(this)) }, r.totalTime = function (e, r) { return arguments.length ? (this._forcing = 1, this.parent || this._dp || !this._ts || (this._start = ge.time - (this._ts > 0 ? e / this._ts : (this.totalDuration() - e) / -this._ts)), t.prototype.totalTime.call(this, e, r), this._forcing = 0, this) : this._tTime }, r.addLabel = function (t, e) { return this.labels[t] = Ht(this, e), this }, r.removeLabel = function (t) { return delete this.labels[t], this }, r.addPause = function (t, e, r) { var n = ke.delayedCall(0, e || at, r); return n.data = "isPause", this._hasPause = 1, kt(this, n, Ht(this, t)) }, r.removePause = function (t) { var e = this._first; for (t = Ht(this, t); e;)e._start === t && "isPause" === e.data && It(e), e = e._next }, r.killTweensOf = function (t, e, r) { for (var n = this.getTweensOf(t, r), i = n.length; i--;)Oe !== n[i] && n[i].kill(t, e); return this }, r.getTweensOf = function (t, e) { for (var r, n = [], i = Kt(t), o = this._first; o;)o instanceof ke ? !bt(o._targets, i) || e && !o.isActive("started" === e) || n.push(o) : (r = o.getTweensOf(i, e)).length && n.push.apply(n, r), o = o._next; return n }, r.tweenTo = function (t, e) { var r = this, n = Ht(r, t), i = e && e.startAt, o = ke.to(r, Et({ ease: "none", lazy: !1, time: n, duration: Math.abs(n - (i && "time" in i ? i.time : r._time)) / r.timeScale() || O, onStart: function () { r.pause(); var t = Math.abs(n - r._time) / r.timeScale(); o._dur !== t && (o._dur = t, o.render(o._time, !0, !0)), e && e.onStart && e.onStart.apply(o, e.onStartParams || []) } }, e)); return o }, r.tweenFromTo = function (t, e, r) { return this.tweenTo(e, Et({ startAt: { time: Ht(this, t) } }, r)) }, r.recent = function () { return this._recent }, r.nextLabel = function (t) { return void 0 === t && (t = this._time), ae(this, Ht(this, t)) }, r.previousLabel = function (t) { return void 0 === t && (t = this._time), ae(this, Ht(this, t), 1) }, r.currentLabel = function (t) { return arguments.length ? this.seek(t, !0) : this.previousLabel(this._time + O) }, r.shiftChildren = function (t, e, r) { void 0 === r && (r = 0); for (var n, i = this._first, o = this.labels; i;)i._start >= r && (i._start += t), i = i._next; if (e) for (n in o) o[n] >= r && (o[n] += t); return Nt(this) }, r.invalidate = function () { var e = this._first; for (this._lock = 0; e;)e.invalidate(), e = e._next; return t.prototype.invalidate.call(this) }, r.clear = function (t) { void 0 === t && (t = !0); for (var e, r = this._first; r;)e = r._next, this.remove(r), r = e; return this._time = this._tTime = 0, t && (this.labels = {}), Nt(this) }, r.totalDuration = function (t) { var e, r, n = 0, i = this, a = i._last, s = 1e8, c = i._repeat, l = c * i._rDelay || 0, h = c < 0; if (!arguments.length) { if (i._dirty) { for (; a;)e = a._prev, a._dirty && a.totalDuration(), a._start > s && i._sort && a._ts && !i._lock ? (i._lock = 1, kt(i, a, a._start - a._delay), i._lock = 0) : s = a._start, a._start < 0 && a._ts && (n -= a._start, (!i.parent && !i._dp || i.parent && i.parent.smoothChildTiming) && (i._start += a._start / i._ts, i._time -= a._start, i._tTime -= a._start), i.shiftChildren(-a._start, !1, -1e20), s = 0), (r = a._end = a._start + a._tDur / Math.abs(a._ts || a._pauseTS || O)) > n && a._ts && (n = xt(r)), a = e; i._dur = i === o && i._time > n ? i._time : Math.min(1e8, n), i._tDur = h && (i._dur || l) ? 1e12 : Math.min(1e8, n * (c + 1) + l), i._end = i._start + (i._tDur / Math.abs(i._ts || i._pauseTS || O) || 0), i._dirty = 0 } return i._tDur } return h ? i : i.timeScale(i.totalDuration() / t) }, e.updateRoot = function (t) { if (o._ts && (Mt(o, Bt(t, o)), h = ge.frame), ge.frame >= pt) { pt += R.autoSleep || 120; var e = o._first; if ((!e || !e._ts) && R.autoSleep && ge._listeners.length < 2) { for (; e && !e._ts;)e = e._next; e || ge.sleep() } } }, e }(Re); Et(Ce.prototype, { _lock: 0, _hasPause: 0, _forcing: 0 }); var Oe, Ie = function (t, e, r, n, i, o, a) { var s, c, l, h, u, p, d, f, m = new tr(this._pt, t, e, 0, 1, Ye, null, i), v = 0, g = 0; for (m.b = r, m.e = n, r += "", (d = ~(n += "").indexOf("random(")) && (n = ie(n)), o && (o(f = [r, n], t, e), r = f[0], n = f[1]), c = r.match(J) || []; s = J.exec(n);)h = s[0], u = n.substring(v, s.index), l ? l = (l + 1) % 5 : "rgba(" === u.substr(-5) && (l = 1), h !== c[g++] && (p = parseFloat(c[g - 1]) || 0, m._pt = { _next: m._pt, p: u || 1 === g ? u : ",", s: p, c: "=" === h.charAt(1) ? parseFloat(h.substr(2)) * ("-" === h.charAt(0) ? -1 : 1) : parseFloat(h) - p, m: l && l < 4 ? Math.round : 0 }, v = J.lastIndex); return m.c = v < n.length ? n.substring(v, n.length) : "", m.fp = a, (Q.test(n) || d) && (m.e = 0), this._pt = m, m }, Ne = function (t, e, r, n, i, o, a, s, c) { k(n) && (n = n(i || 0, t, o)); var l, h = t[e], u = "get" !== r ? r : k(h) ? c ? t[e.indexOf("set") || !k(t["get" + e.substr(3)]) ? e : "get" + e.substr(3)](c) : t[e]() : h, p = k(h) ? c ? Ve : Ge : je; if (B(n) && (~n.indexOf("random(") && (n = ie(n)), "=" === n.charAt(1) && (n = parseFloat(u) + parseFloat(n.substr(2)) * ("-" === n.charAt(0) ? -1 : 1) + (Xt(u) || 0))), u !== n) return isNaN(u + n) ? (!h && !(e in t) && nt(e, n), Ie.call(this, t, e, u, n, p, s || R.stringFilter, c)) : (l = new tr(this._pt, t, e, +u || 0, n - (u || 0), "boolean" == typeof h ? Xe : qe, 0, p), c && (l.fp = c), a && l.modifier(a, this, t), this._pt = l) }, De = function (t, e, r, n, i, o) { var a, s, c, l; if (ht[t] && !1 !== (a = new ht[t]).init(i, a.rawVars ? e[t] : function (t, e, r, n, i) { if (k(t) && (t = Fe(t, i, e, r, n)), !V(t) || t.style && t.nodeType || X(t)) return B(t) ? Fe(t, i, e, r, n) : t; var o, a = {}; for (o in t) a[o] = Fe(t[o], i, e, r, n); return a }(e[t], n, i, o, r), r, n, o) && (r._pt = s = new tr(r._pt, i, t, 0, 1, a.render, a, 0, a.priority), r !== u)) for (c = r._ptLookup[r._targets.indexOf(i)], l = a._props.length; l--;)c[a._props[l]] = s; return a }, ze = function t(e, r) { var n, i, a, s, c, l, h, u, p, d, f, m, v = e.vars, g = v.ease, y = v.startAt, x = v.immediateRender, b = v.lazy, w = v.onUpdate, _ = v.onUpdateParams, M = v.callbackScope, S = v.runBackwards, T = v.yoyoEase, E = v.keyframes, A = v.autoRevert, L = e._dur, P = e._startAt, R = e._targets, I = e.parent, N = I && "nested" === I.data ? I.parent._targets : R, D = "auto" === e._overwrite, z = e.timeline; if (!z || E && g || (g = "none"), e._ease = Se(g, C.ease), e._yEase = T ? Me(Se(!0 === T ? g : T, C.ease)) : 0, T && e._yoyo && !e._repeat && (T = e._yEase, e._yEase = e._ease, e._ease = T), !z) { if (P && P.render(-1, !0).kill(), y) { if (It(e._startAt = ke.set(R, Et({ data: "isStart", overwrite: !1, parent: I, immediateRender: !0, lazy: H(b), startAt: null, delay: 0, onUpdate: w, onUpdateParams: _, callbackScope: M, stagger: 0 }, y))), x) if (r > 0) !A && (e._startAt = 0); else if (L) return } else if (S && L) if (P) !A && (e._startAt = 0); else if (r && (x = !1), It(e._startAt = ke.set(R, Lt(Rt(v, st), { overwrite: !1, data: "isFromStart", lazy: x && H(b), immediateRender: x, stagger: 0, parent: I }))), x) { if (!r) return } else t(e._startAt, O); for (n = Rt(v, st), e._pt = 0, m = (u = R[0] ? vt(R[0]).harness : 0) && v[u.prop], b = L && H(b) || b && !L, i = 0; i < R.length; i++) { if (h = (c = R[i])._gsap || mt(R)[i]._gsap, e._ptLookup[i] = d = {}, lt[h.id] && _t(), f = N === R ? i : N.indexOf(c), u && !1 !== (p = new u).init(c, m || n, e, f, N) && (e._pt = s = new tr(e._pt, c, p.name, 0, 1, p.render, p, 0, p.priority), p._props.forEach((function (t) { d[t] = s })), p.priority && (l = 1)), !u || m) for (a in n) ht[a] && (p = De(a, n, e, f, c, N)) ? p.priority && (l = 1) : d[a] = s = Ne.call(e, c, a, "get", n[a], f, N, 0, v.stringFilter); e._op && e._op[i] && e.kill(c, e._op[i]), D && e._pt && (Oe = e, o.killTweensOf(c, d, "started"), Oe = 0), e._pt && b && (lt[h.id] = 1) } l && $e(e), e._onInit && e._onInit(e) } e._from = !z && !!v.runBackwards, e._onUpdate = w, e._initted = 1 }, Fe = function (t, e, r, n, i) { return k(t) ? t.call(e, r, n, i) : B(t) && ~t.indexOf("random(") ? ie(t) : t }, Ue = ft + ",repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase", Be = (Ue + ",id,stagger,delay,duration,paused").split(","), ke = function (t) { function e(e, r, i) { var a; "number" == typeof r && (i.duration = r, r = i, i = null); var s, c, l, h, u, p, d, f, m = (a = t.call(this, Ct(r), i) || this).vars, v = m.duration, g = m.delay, y = m.immediateRender, x = m.stagger, b = m.overwrite, w = m.keyframes, _ = m.defaults, M = X(e) && j(e[0]) ? [e] : Kt(e); if (a._targets = M.length ? mt(M) : it("GSAP target " + e + " not found. https://greensock.com", !R.nullTargetWarn) || [], a._ptLookup = [], a._overwrite = b, w || x || q(v) || q(g)) { if (r = a.vars, (s = a.timeline = new Ce({ data: "nested", defaults: _ || {} })).kill(), s.parent = n(a), w) Et(s.vars.defaults, { ease: "none" }), w.forEach((function (t) { return s.to(M, t, ">") })); else { if (h = M.length, d = x ? $t(x) : at, V(x)) for (u in x) ~Ue.indexOf(u) && (f || (f = {}), f[u] = x[u]); for (c = 0; c < h; c++) { for (u in l = {}, r) Be.indexOf(u) < 0 && (l[u] = r[u]); l.stagger = 0, f && Lt(l, f), r.yoyoEase && !r.repeat && (l.yoyoEase = r.yoyoEase), p = M[c], l.duration = +Fe(v, n(a), c, p, M), l.delay = (+Fe(g, n(a), c, p, M) || 0) - a._delay, !x && 1 === h && l.delay && (a._delay = g = l.delay, a._start += g, l.delay = 0), s.to(p, l, d(c, p, M)) } v = g = 0 } v || a.duration(v = s.duration()) } else a.timeline = 0; return !0 === b && (Oe = n(a), o.killTweensOf(M), Oe = 0), (y || !v && !w && a._start === a.parent._time && H(y) && zt(n(a)) && "nested" !== a.parent.data) && (a._tTime = -O, a.render(Math.max(0, -g))), a } i(e, t); var r = e.prototype; return r.render = function (t, e, r) { var n, i, o, a, s, c, l, h, u, p = this._time, d = this._tDur, f = this._dur, m = t > d - O && t >= 0 ? d : t < O ? 0 : t; if (f) { if (m !== this._tTime || !t || r || this._startAt && this._zTime < 0 != t < 0) { if (n = m, h = this.timeline, this._repeat) { if (a = f + this._rDelay, (n = xt(m % a)) > f && (n = f), (o = ~~(m / a)) && o === m / a && (n = f, o--), (c = this._yoyo && 1 & o) && (u = this._yEase, n = f - n), s = Ut(this._tTime, a), n === p && !r && this._initted) return this; o !== s && (!this.vars.repeatRefresh || c || this._lock || (this._lock = r = 1, this.render(a * o, !0).invalidate()._lock = 0)) } if (!this._initted && jt(this, n, r, e)) return this._tTime = 0, this; for (this._tTime = m, this._time = n, !this._act && this._ts && (this._act = 1, this._lazy = 0), this.ratio = l = (u || this._ease)(n / f), this._from && (this.ratio = l = 1 - l), p || !n || e || se(this, "onStart"), i = this._pt; i;)i.r(l, i.d), i = i._next; h && h.render(t < 0 ? t : !n && c ? -O : h._dur * l, e, r) || this._startAt && (this._zTime = t), this._onUpdate && !e && (t < 0 && this._startAt && this._startAt.render(t, !0, r), se(this, "onUpdate")), this._repeat && o !== s && this.vars.onRepeat && !e && this.parent && se(this, "onRepeat"), m !== this._tDur && m || this._tTime !== m || (t < 0 && this._startAt && !this._onUpdate && this._startAt.render(t, !0, r), (t || !f) && (t && this._ts > 0 || !m && this._ts < 0) && It(this, 1), e || t < 0 && !p || (se(this, m === d ? "onComplete" : "onReverseComplete", !0), this._prom && this._prom())) } } else !function (t, e, r, n) { var i, o = t._zTime < 0 ? 0 : 1, a = e < 0 ? 0 : 1, s = t._rDelay, c = 0; if (s && t._repeat && (c = qt(0, t._tDur, e), Ut(c, s) !== Ut(t._tTime, s) && (o = 1 - a, t.vars.repeatRefresh && t._initted && t.invalidate())), (t._initted || !jt(t, e, n, r)) && (a !== o || n || t._zTime === O || !e && t._zTime)) { for (t._zTime = e || (r ? O : 0), t.ratio = a, t._from && (a = 1 - a), t._time = 0, t._tTime = c, r || se(t, "onStart"), i = t._pt; i;)i.r(a, i.d), i = i._next; !a && t._startAt && !t._onUpdate && t._start && t._startAt.render(e, !0, n), t._onUpdate && !r && se(t, "onUpdate"), c && t._repeat && !r && t.parent && se(t, "onRepeat"), (e >= t._tDur || e < 0) && t.ratio === a && (t.ratio && It(t, 1), r || (se(t, t.ratio ? "onComplete" : "onReverseComplete", !0), t._prom && t._prom())) } }(this, t, e, r); return this }, r.targets = function () { return this._targets }, r.invalidate = function () { return this._pt = this._op = this._startAt = this._onUpdate = this._act = this._lazy = 0, this._ptLookup = [], this.timeline && this.timeline.invalidate(), t.prototype.invalidate.call(this) }, r.kill = function (t, e) { if (void 0 === e && (e = "all"), !(t || e && "all" !== e) && (this._lazy = 0, this.parent)) return ce(this); if (this.timeline) return this.timeline.killTweensOf(t, e, Oe && !0 !== Oe.vars.overwrite), this; var r, n, i, o, a, s, c, l = this._targets, h = t ? Kt(t) : l, u = this._ptLookup, p = this._pt; if ((!e || "all" === e) && function (t, e) { for (var r = t.length, n = r === e.length; n && r-- && t[r] === e[r];); return r < 0 }(l, h)) return ce(this); for (r = this._op = this._op || [], "all" !== e && (B(e) && (a = {}, yt(e, (function (t) { return a[t] = 1 })), e = a), e = function (t, e) { var r, n, i, o, a = t[0] ? vt(t[0]).harness : 0, s = a && a.aliases; if (!s) return e; for (n in r = Lt({}, e), s) if (n in r) for (i = (o = s[n].split(",")).length; i--;)r[o[i]] = r[n]; return r }(l, e)), c = l.length; c--;)if (~h.indexOf(l[c])) for (a in n = u[c], "all" === e ? (r[c] = e, o = n, i = {}) : (i = r[c] = r[c] || {}, o = e), o) (s = n && n[a]) && ("kill" in s.d && !0 !== s.d.kill(a) || Ot(this, s, "_pt"), delete n[a]), "all" !== i && (i[a] = 1); return this._initted && !this._pt && p && ce(this), this }, e.to = function (t, r) { return new e(t, r, arguments[2]) }, e.from = function (t, r) { return new e(t, wt(arguments, 1)) }, e.delayedCall = function (t, r, n, i) { return new e(r, 0, { immediateRender: !1, lazy: !1, overwrite: !1, delay: t, onComplete: r, onReverseComplete: r, onCompleteParams: n, onReverseCompleteParams: n, callbackScope: i }) }, e.fromTo = function (t, r, n) { return new e(t, wt(arguments, 2)) }, e.set = function (t, r) { return r.duration = 0, r.repeatDelay || (r.repeat = 0), new e(t, r) }, e.killTweensOf = function (t, e, r) { return o.killTweensOf(t, e, r) }, e }(Re); Et(ke.prototype, { _targets: [], _lazy: 0, _startAt: 0, _op: 0, _onInit: 0 }), yt("staggerTo,staggerFrom,staggerFromTo", (function (t) { ke[t] = function () { var e = new Ce, r = Yt.call(arguments, 0); return r.splice("staggerFromTo" === t ? 5 : 4, 0, 0), e[t].apply(e, r) } })); var je = function (t, e, r) { return t[e] = r }, Ge = function (t, e, r) { return t[e](r) }, Ve = function (t, e, r, n) { return t[e](n.fp, r) }, He = function (t, e, r) { return t.setAttribute(e, r) }, We = function (t, e) { return k(t[e]) ? Ge : G(t[e]) && t.setAttribute ? He : je }, qe = function (t, e) { return e.set(e.t, e.p, Math.round(1e4 * (e.s + e.c * t)) / 1e4, e) }, Xe = function (t, e) { return e.set(e.t, e.p, !!(e.s + e.c * t), e) }, Ye = function (t, e) { var r = e._pt, n = ""; if (!t && e.b) n = e.b; else if (1 === t && e.e) n = e.e; else { for (; r;)n = r.p + (r.m ? r.m(r.s + r.c * t) : Math.round(1e4 * (r.s + r.c * t)) / 1e4) + n, r = r._next; n += e.c } e.set(e.t, e.p, n, e) }, Ze = function (t, e) { for (var r = e._pt; r;)r.r(t, r.d), r = r._next }, Je = function (t, e, r, n) { for (var i, o = this._pt; o;)i = o._next, o.p === n && o.modifier(t, e, r), o = i }, Ke = function (t) { for (var e, r, n = this._pt; n;)r = n._next, n.p === t && !n.op || n.op === t ? Ot(this, n, "_pt") : n.dep || (e = 1), n = r; return !e }, Qe = function (t, e, r, n) { n.mSet(t, e, n.m.call(n.tween, r, n.mt), n) }, $e = function (t) { for (var e, r, n, i, o = t._pt; o;) { for (e = o._next, r = n; r && r.pr > o.pr;)r = r._next; (o._prev = r ? r._prev : i) ? o._prev._next = o : n = o, (o._next = r) ? r._prev = o : i = o, o = e } t._pt = n }, tr = function () { function t(t, e, r, n, i, o, a, s, c) { this.t = e, this.s = n, this.c = i, this.p = r, this.r = o || qe, this.d = a || this, this.set = s || je, this.pr = c || 0, this._next = t, t && (t._prev = this) } return t.prototype.modifier = function (t, e, r) { this.mSet = this.mSet || this.set, this.set = Qe, this.m = t, this.mt = r, this.tween = e }, t }(); yt(ft + ",parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert", (function (t) { st[t] = 1, "on" === t.substr(0, 2) && (st[t + "Params"] = 1) })), tt.TweenMax = tt.TweenLite = ke, tt.TimelineLite = tt.TimelineMax = Ce, o = new Ce({ sortChildren: !1, defaults: C, autoRemoveChildren: !0, id: "root" }), R.stringFilter = ve; var er = { registerPlugin: function () { for (var t = arguments.length, e = new Array(t), r = 0; r < t; r++)e[r] = arguments[r]; e.forEach((function (t) { return le(t) })) }, timeline: function (t) { return new Ce(t) }, getTweensOf: function (t, e) { return o.getTweensOf(t, e) }, getProperty: function (t, e, r, n) { B(t) && (t = Kt(t)[0]); var i = vt(t || {}).get, o = r ? Tt : St; return "native" === r && (r = ""), t ? e ? o((ht[e] && ht[e].get || i)(t, e, r, n)) : function (e, r, n) { return o((ht[e] && ht[e].get || i)(t, e, r, n)) } : t }, quickSetter: function (t, e, r) { if ((t = Kt(t)).length > 1) { var n = t.map((function (t) { return ir.quickSetter(t, e, r) })), i = n.length; return function (t) { for (var e = i; e--;)n[e](t) } } t = t[0] || {}; var o = ht[e], a = vt(t), s = o ? function (e) { var n = new o; u._pt = 0, n.init(t, r ? e + r : e, u, 0, [t]), n.render(1, n), u._pt && Ze(1, u) } : a.set(t, e); return o ? s : function (n) { return s(t, e, r ? n + r : n, a, 1) } }, isTweening: function (t) { return o.getTweensOf(t, !0).length > 0 }, defaults: function (t) { return t && t.ease && (t.ease = Se(t.ease, C.ease)), Pt(C, t || {}) }, config: function (t) { return Pt(R, t || {}) }, registerEffect: function (t) { var e = t.name, r = t.effect, n = t.plugins, i = t.defaults, o = t.extendTimeline; (n || "").split(",").forEach((function (t) { return t && !ht[t] && !tt[t] && it(e + " effect requires " + t + " plugin.") })), ut[e] = function (t, e) { return r(Kt(t), Et(e || {}, i)) }, o && (Ce.prototype[e] = function (t, r, n) { return this.add(ut[e](t, V(r) ? r : (n = r) && {}), n) }) }, registerEase: function (t, e) { xe[t] = Se(e) }, parseEase: function (t, e) { return arguments.length ? Se(t, e) : xe }, getById: function (t) { return o.getById(t) }, exportRoot: function (t, e) { void 0 === t && (t = {}); var r, n, i = new Ce(t); for (i.smoothChildTiming = H(t.smoothChildTiming), o.remove(i), i._dp = 0, i._time = i._tTime = o._time, r = o._first; r;)n = r._next, !e && !r._dur && r instanceof ke && r.vars.onComplete === r._targets[0] || kt(i, r, r._start - r._delay), r = n; return kt(o, i, 0), i }, utils: { wrap: function t(e, r, n) { var i = r - e; return X(e) ? ne(e, t(0, e.length), r) : Wt(n, (function (t) { return (i + (t - e) % i) % i + e })) }, wrapYoyo: function t(e, r, n) { var i = r - e, o = 2 * i; return X(e) ? ne(e, t(0, e.length - 1), r) : Wt(n, (function (t) { return e + ((t = (o + (t - e) % o) % o) > i ? o - t : t) })) }, distribute: $t, random: re, snap: ee, normalize: function (t, e, r) { return oe(t, e, 0, 1, r) }, getUnit: Xt, clamp: function (t, e, r) { return Wt(r, (function (r) { return qt(t, e, r) })) }, splitColor: pe, toArray: Kt, mapRange: oe, pipe: function () { for (var t = arguments.length, e = new Array(t), r = 0; r < t; r++)e[r] = arguments[r]; return function (t) { return e.reduce((function (t, e) { return e(t) }), t) } }, unitize: function (t, e) { return function (r) { return t(parseFloat(r)) + (e || Xt(r)) } }, interpolate: function t(e, r, n, i) { var o = isNaN(e + r) ? 0 : function (t) { return (1 - t) * e + t * r }; if (!o) { var a, s, c, l, h, u = B(e), p = {}; if (!0 === n && (i = 1) && (n = null), u) e = { p: e }, r = { p: r }; else if (X(e) && !X(r)) { for (c = [], l = e.length, h = l - 2, s = 1; s < l; s++)c.push(t(e[s - 1], e[s])); l--, o = function (t) { t *= l; var e = Math.min(h, ~~t); return c[e](t - e) }, n = r } else i || (e = Lt(X(e) ? [] : {}, e)); if (!c) { for (a in r) Ne.call(p, e, a, "get", r[a]); o = function (t) { return Ze(t, p) || (u ? e.p : e) } } } return Wt(n, o) }, shuffle: Qt }, install: rt, effects: ut, ticker: ge, updateRoot: Ce.updateRoot, plugins: ht, globalTimeline: o, core: { PropTween: tr, globals: ot, Tween: ke, Timeline: Ce, Animation: Re, getCache: vt } }; yt("to,from,fromTo,delayedCall,set,killTweensOf", (function (t) { return er[t] = ke[t] })), ge.add(Ce.updateRoot), u = er.to({}, { duration: 0 }); var rr = function (t, e) { for (var r = t._pt; r && r.p !== e && r.op !== e && r.fp !== e;)r = r._next; return r }, nr = function (t, e) { return { name: t, rawVars: 1, init: function (t, r, n) { n._onInit = function (t) { var n, i; if (B(r) && (n = {}, yt(r, (function (t) { return n[t] = 1 })), r = n), e) { for (i in n = {}, r) n[i] = e(r[i]); r = n } !function (t, e) { var r, n, i, o = t._targets; for (r in e) for (n = o.length; n--;)(i = t._ptLookup[n][r]) && (i = i.d) && (i._pt && (i = rr(i, r)), i && i.modifier && i.modifier(e[r], t, o[n], r)) }(t, r) } } } }, ir = er.registerPlugin({ name: "attr", init: function (t, e, r, n, i) { for (var o in e) this.add(t, "setAttribute", (t.getAttribute(o) || 0) + "", e[o], n, i, 0, 0, o), this._props.push(o) } }, { name: "endArray", init: function (t, e) { for (var r = e.length; r--;)this.add(t, r, t[r] || 0, e[r]) } }, nr("roundProps", te), nr("modifiers"), nr("snap", ee)) || er; ke.version = Ce.version = ir.version = "3.1.1", l = 1, W() && ye(); xe.Power0, xe.Power1, xe.Power2, xe.Power3, xe.Power4, xe.Linear, xe.Quad, xe.Cubic, xe.Quart, xe.Quint, xe.Strong, xe.Elastic, xe.Back, xe.SteppedEase, xe.Bounce, xe.Sine, xe.Expo, xe.Circ }, yLpj: function (t, e) { var r; r = function () { return this }(); try { r = r || new Function("return this")() } catch (t) { "object" == typeof window && (r = window) } t.exports = r }, "z/o8": function (t, e, r) { "use strict"; var n, i, o, a, s, c, l, h, u = r("pc+1"), p = {}, d = 180 / Math.PI, f = Math.PI / 180, m = Math.atan2, v = /([A-Z])/g, g = /[-+=\.]*\d+[\.e-]*\d*[a-z%]*/g, y = /(?:left|right|width|margin|padding|x)/i, x = /[\s,\(]\S/, b = { autoAlpha: "opacity,visibility", scale: "scaleX,scaleY", alpha: "opacity" }, w = function (t, e) { return e.set(e.t, e.p, ~~(1e3 * (e.s + e.c * t)) / 1e3 + e.u, e) }, _ = function (t, e) { return e.set(e.t, e.p, 1 === t ? e.e : ~~(1e3 * (e.s + e.c * t)) / 1e3 + e.u, e) }, M = function (t, e) { return e.set(e.t, e.p, t ? ~~(1e3 * (e.s + e.c * t)) / 1e3 + e.u : e.b, e) }, S = function (t, e) { var r = e.s + e.c * t; e.set(e.t, e.p, ~~(r + (r < 0 ? -.5 : .5)) + e.u, e) }, T = function (t, e) { return e.set(e.t, e.p, t ? e.e : e.b, e) }, E = function (t, e) { return e.set(e.t, e.p, 1 !== t ? e.b : e.e, e) }, A = function (t, e, r) { return t.style[e] = r }, L = function (t, e, r) { return t.style.setProperty(e, r) }, P = function (t, e, r) { return t._gsap[e] = r }, R = function (t, e, r) { return t._gsap.scaleX = t._gsap.scaleY = r }, C = function (t, e, r, n, i) { var o = t._gsap; o.scaleX = o.scaleY = r, o.renderTransform(i, o) }, O = function (t, e, r, n, i) { var o = t._gsap; o[e] = r, o.renderTransform(i, o) }, I = "transform", N = I + "Origin", D = function (t, e) { var r = i.createElementNS ? i.createElementNS((e || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"), t) : i.createElement(t); return r.style ? r : i.createElement(t) }, z = function t(e, r, n) { var i = getComputedStyle(e); return i[r] || i.getPropertyValue(r.replace(v, "-$1").toLowerCase()) || i.getPropertyValue(r) || !n && t(e, U(r) || r, 1) || "" }, F = "O,Moz,ms,Ms,Webkit".split(","), U = function (t, e) { var r = (e || s).style, n = 5; if (t in r) return t; for (t = t.charAt(0).toUpperCase() + t.substr(1); n-- && !(F[n] + t in r);); return n < 0 ? null : (3 === n ? "ms" : n >= 0 ? F[n] : "") + t }, B = function () { "undefined" != typeof window && (n = window, i = n.document, o = i.documentElement, s = D("div") || { style: {} }, c = D("div"), I = U(I), N = U(N), s.style.cssText = "border-width:0;line-height:0;position:absolute;padding:0", h = !!U("perspective"), a = 1) }, k = function t(e) { var r, n = D("svg", this.ownerSVGElement && this.ownerSVGElement.getAttribute("xmlns") || "http://www.w3.org/2000/svg"), i = this.parentNode, a = this.nextSibling, s = this.style.cssText; if (o.appendChild(n), n.appendChild(this), this.style.display = "block", e) try { r = this.getBBox(), this._gsapBBox = this.getBBox, this.getBBox = t } catch (t) { } else this._gsapBBox && (r = this._gsapBBox()); return a ? i.insertBefore(this, a) : i.appendChild(this), o.removeChild(n), this.style.cssText = s, r }, j = function (t, e) { for (var r = e.length; r--;)if (t.hasAttribute(e[r])) return t.getAttribute(e[r]) }, G = function (t) { var e; try { e = t.getBBox() } catch (r) { e = k.call(t, !0) } return !e || e.width || e.x || e.y ? e : { x: +j(t, ["x", "cx", "x1"]) || 0, y: +j(t, ["y", "cy", "y1"]) || 0, width: 0, height: 0 } }, V = function (t) { return !(!t.getCTM || t.parentNode && !t.ownerSVGElement || !G(t)) }, H = function (t, e) { if (e) { var r = t.style; e in p && (e = I), r.removeProperty ? ("ms" !== e.substr(0, 2) && "webkit" !== e.substr(0, 6) || (e = "-" + e), r.removeProperty(e.replace(v, "-$1").toLowerCase())) : r.removeAttribute(e) } }, W = function (t, e, r, n, i, o) { var a = new u.b(t._pt, e, r, 0, 1, o ? E : T); return t._pt = a, a.b = n, a.e = i, t._props.push(r), a }, q = { deg: 1, rad: 1, turn: 1 }, X = function (t, e, r, n) { var o, a, c, l, h = parseFloat(r) || 0, d = (r + "").trim().substr((h + "").length) || "px", f = s.style, m = y.test(e), v = "svg" === t.tagName.toLowerCase(), g = (v ? "client" : "offset") + (m ? "Width" : "Height"), x = "px" === n; return n === d || !h || q[n] || q[d] ? h : (l = t.getCTM && V(t), "%" === n && (p[e] || ~e.indexOf("adius")) ? Object(u.r)(h / (l ? t.getBBox()[m ? "width" : "height"] : t[g]) * 100) : (f[m ? "width" : "height"] = 100 + (x ? d : n), a = ~e.indexOf("adius") || "em" === n && t.appendChild && !v ? t : t.parentNode, l && (a = (t.ownerSVGElement || {}).parentNode), a && a !== i && a.appendChild || (a = i.body), (c = a._gsap) && "%" === n && c.width && m && c.time === u.t.time ? Object(u.r)(h / c.width * 100) : (a === t && (f.position = "static"), a.appendChild(s), o = s[g], a.removeChild(s), f.position = "absolute", m && "%" === n && ((c = Object(u.g)(a)).time = u.t.time, c.width = a[g]), Object(u.r)(x ? o * h / 100 : 100 / o * h)))) }, Y = function (t, e, r, n) { var i; return a || B(), e in b && "transform" !== e && ~(e = b[e]).indexOf(",") && (e = e.split(",")[0]), p[e] && "transform" !== e ? (i = ot(t, n), i = "transformOrigin" !== e ? i[e] : at(z(t, N)) + i.zOrigin + "px") : (!(i = t.style[e]) || "auto" === i || n || ~(i + "").indexOf("calc(")) && (i = Q[e] && Q[e](t, e, r) || z(t, e) || Object(u.h)(t, e) || ("opacity" === e ? 1 : 0)), r && !~(i + "").indexOf(" ") ? X(t, e, i, r) + r : i }, Z = function (t, e, r, n) { var i, o, a, s, c, l, h, p, d, f, m, v, y = new u.b(this._pt, t.style, e, 0, 1, u.p), x = 0, b = 0; if (y.b = r, y.e = n, r += "", "auto" === (n += "") && (t.style[e] = n, n = z(t, e) || n, t.style[e] = r), i = [r, n], Object(u.d)(i), n = i[1], !!(l = (r = i[0]).indexOf("rgba(")) != !!(h = n.indexOf("rgba(")) && (l ? r = r.substr(l) + " " + r.substr(0, l - 1) : n = n.substr(h) + " " + n.substr(0, h - 1)), a = r.match(g) || [], (n.match(g) || []).length) { for (; o = g.exec(n);)h = o[0], d = n.substring(x, o.index), c ? c = (c + 1) % 5 : "rgba(" !== d.substr(-5) && "hsla(" !== d.substr(-5) || (c = 1), h !== (l = a[b++] || "") && (s = parseFloat(l) || 0, m = l.substr((s + "").length), (v = "=" === h.charAt(1) ? +(h.charAt(0) + "1") : 0) && (h = h.substr(2)), p = parseFloat(h), f = h.substr((p + "").length), x = g.lastIndex - f.length, f || (f = f || u.e.units[e] || m, x === n.length && (n += f, y.e += f)), m !== f && (s = X(t, e, l, f) || 0), y._pt = { _next: y._pt, p: d || 1 === b ? d : ",", s: s, c: v ? v * p : p - s, m: c && c < 4 ? Math.round : 0 }); y.c = x < n.length ? n.substring(x, n.length) : "" } else y.r = "display" === e && "none" === n ? E : T; return u.o.test(n) && (y.e = 0), this._pt = y, y }, J = { top: "0%", bottom: "100%", left: "0%", right: "100%", center: "50%" }, K = function (t, e) { if (e.tween && e.tween._time === e.tween._dur) { var r, n, i, o = e.t, a = o.style, s = e.u; if ("all" === s || !0 === s) a.cssText = "", n = 1; else for (i = (s = s.split(",")).length; --i > -1;)r = s[i], p[r] && (n = 1, r = "transformOrigin" === r ? N : I), H(o, r); n && (H(o, I), (n = o._gsap) && (n.svg && o.removeAttribute("transform"), ot(o, 1))) } }, Q = { clearProps: function (t, e, r, n, i) { if ("isFromStart" !== i.data) { var o = t._pt = new u.b(t._pt, e, r, 0, 0, K); return o.u = n, o.pr = -10, o.tween = i, t._props.push(r), 1 } } }, $ = [1, 0, 0, 1, 0, 0], tt = {}, et = function (t) { return "matrix(1, 0, 0, 1, 0, 0)" === t || "none" === t || !t }, rt = function (t) { var e = z(t, I); return et(e) ? $ : e.substr(7).match(u.m).map(u.r) }, nt = function (t, e) { var r, n, i, a, s = t._gsap, c = t.style, l = rt(t); return s.svg && t.getAttribute("transform") ? "1,0,0,1,0,0" === (l = [(i = t.transform.baseVal.consolidate().matrix).a, i.b, i.c, i.d, i.e, i.f]).join(",") ? $ : l : (l !== $ || t.offsetParent || t === o || s.svg || (i = c.display, c.display = "block", (r = t.parentNode) && t.offsetParent || (a = 1, n = t.nextSibling, o.appendChild(t)), l = rt(t), i ? c.display = i : H(t, "display"), a && (n ? r.insertBefore(t, n) : r ? r.appendChild(t) : o.removeChild(t))), e && l.length > 6 ? [l[0], l[1], l[4], l[5], l[12], l[13]] : l) }, it = function (t, e, r, n, i, o) { var a, s, c, l = t._gsap, h = i || nt(t, !0), u = l.xOrigin || 0, p = l.yOrigin || 0, d = l.xOffset || 0, f = l.yOffset || 0, m = h[0], v = h[1], g = h[2], y = h[3], x = h[4], b = h[5], w = e.split(" "), _ = parseFloat(w[0]) || 0, M = parseFloat(w[1]) || 0; r ? h !== $ && (s = m * y - v * g) && (c = _ * (-v / s) + M * (m / s) - (m * b - v * x) / s, _ = _ * (y / s) + M * (-g / s) + (g * b - y * x) / s, M = c) : (_ = (a = G(t)).x + (~w[0].indexOf("%") ? _ / 100 * a.width : _), M = a.y + (~(w[1] || w[0]).indexOf("%") ? M / 100 * a.height : M)), n || !1 !== n && l.smooth ? (x = _ - u, b = M - p, l.xOffset = d + (x * m + b * g) - x, l.yOffset = f + (x * v + b * y) - b) : l.xOffset = l.yOffset = 0, l.xOrigin = _, l.yOrigin = M, l.smooth = !!n, l.origin = e, l.originIsAbsolute = !!r, t.style[N] = "0px 0px", o && (W(o, l, "xOrigin", u, _), W(o, l, "yOrigin", p, M), W(o, l, "xOffset", d, l.xOffset), W(o, l, "yOffset", f, l.yOffset)) }, ot = function (t, e) { var r = t._gsap || new u.a(t); if ("x" in r && !e && !r.uncache) return r; var n, i, o, a, s, c, l, p, f, v, g, y, x, b, w, _, M, S, T, E, A, L, P, R, C, O, D, F, U, B, k = t.style, j = r.scaleX < 0, G = r.xOrigin || 0, H = r.yOrigin || 0, W = z(t, N) || "0"; return n = i = o = c = l = p = f = v = g = 0, a = s = 1, r.svg = !(!t.getCTM || !V(t)), y = nt(t, r.svg), r.svg && it(t, W, r.originIsAbsolute, !1 !== r.smooth, y), y !== $ && (_ = y[0], M = y[1], S = y[2], T = y[3], n = E = y[4], i = A = y[5], 6 === y.length ? (a = Math.sqrt(_ * _ + M * M), s = Math.sqrt(T * T + S * S), c = _ || M ? m(M, _) * d : 0, f = S || T ? m(S, T) * d + c : 0, r.svg && (n -= G - (G * _ + H * S), i -= H - (G * M + H * T))) : (B = y[6], F = y[7], C = y[8], O = y[9], D = y[10], U = y[11], n = y[12], i = y[13], o = y[14], l = (x = m(B, D)) * d, x && (L = E * (b = Math.cos(-x)) + C * (w = Math.sin(-x)), P = A * b + O * w, R = B * b + D * w, C = E * -w + C * b, O = A * -w + O * b, D = B * -w + D * b, U = F * -w + U * b, E = L, A = P, B = R), p = (x = m(-S, D)) * d, x && (b = Math.cos(-x), U = T * (w = Math.sin(-x)) + U * b, _ = L = _ * b - C * w, M = P = M * b - O * w, S = R = S * b - D * w), c = (x = m(M, _)) * d, x && (L = _ * (b = Math.cos(x)) + M * (w = Math.sin(x)), P = E * b + A * w, M = M * b - _ * w, A = A * b - E * w, _ = L, E = P), l && Math.abs(l) + Math.abs(c) > 359.9 && (l = c = 0, p = 180 - p), a = Object(u.r)(Math.sqrt(_ * _ + M * M + S * S)), s = Object(u.r)(Math.sqrt(A * A + B * B)), x = m(E, A), f = Math.abs(x) > 2e-4 ? x * d : 0, g = U ? 1 / (U < 0 ? -U : U) : 0), r.svg && (y = t.getAttribute("transform"), r.forceCSS = t.setAttribute("transform", "") || !et(z(t, I)), y && t.setAttribute("transform", y))), Math.abs(f) > 90 && Math.abs(f) < 270 && (j ? (a *= -1, f += c <= 0 ? 180 : -180, c += c <= 0 ? 180 : -180) : (s *= -1, f += f <= 0 ? 180 : -180)), r.x = ((r.xPercent = n && Math.round(t.offsetWidth / 2) === Math.round(-n) ? -50 : 0) ? 0 : n) + "px", r.y = ((r.yPercent = i && Math.round(t.offsetHeight / 2) === Math.round(-i) ? -50 : 0) ? 0 : i) + "px", r.z = o + "px", r.scaleX = Object(u.r)(a), r.scaleY = Object(u.r)(s), r.rotation = Object(u.r)(c) + "deg", r.rotationX = Object(u.r)(l) + "deg", r.rotationY = Object(u.r)(p) + "deg", r.skewX = f + "deg", r.skewY = v + "deg", r.transformPerspective = g + "px", (r.zOrigin = parseFloat(W.split(" ")[2]) || 0) && (k[N] = at(W)), r.xOffset = r.yOffset = 0, r.force3D = u.e.force3D, r.renderTransform = r.svg ? ht : h ? lt : ct, r.uncache = 0, r }, at = function (t) { return (t = t.split(" "))[0] + " " + t[1] }, st = function (t, e, r) { var n = Object(u.v)(e); return Object(u.r)(parseFloat(e) + parseFloat(X(t, "x", r + "px", n))) + n }, ct = function (t, e) { e.z = "0px", e.rotationY = e.rotationX = "0deg", e.force3D = 0, lt(t, e) }, lt = function (t, e) { var r = e || this, n = r.xPercent, i = r.yPercent, o = r.x, a = r.y, s = r.z, c = r.rotation, l = r.rotationY, h = r.rotationX, u = r.skewX, p = r.skewY, d = r.scaleX, m = r.scaleY, v = r.transformPerspective, g = r.force3D, y = r.target, x = r.zOrigin, b = "", w = "auto" === g && t && 1 !== t || !0 === g; if (x && ("0deg" !== h || "0deg" !== l)) { var _, M = parseFloat(l) * f, S = Math.sin(M), T = Math.cos(M); M = parseFloat(h) * f, _ = Math.cos(M), o = st(y, o, S * _ * -x), a = st(y, a, -Math.sin(M) * -x), s = st(y, s, T * _ * -x + x) } "0px" !== v && (b += "perspective(" + v + ") "), (n || i) && (b += "translate(" + n + "%, " + i + "%) "), (w || "0px" !== o || "0px" !== a || "0px" !== s) && (b += "0px" !== s || w ? "translate3d(" + o + ", " + a + ", " + s + ") " : "translate(" + o + ", " + a + ") "), "0deg" !== c && (b += "rotate(" + c + ") "), "0deg" !== l && (b += "rotateY(" + l + ") "), "0deg" !== h && (b += "rotateX(" + h + ") "), "0deg" === u && "0deg" === p || (b += "skew(" + u + ", " + p + ") "), 1 === d && 1 === m || (b += "scale(" + d + ", " + m + ") "), y.style[I] = b || "translate(0, 0)" }, ht = function (t, e) { var r, n, i, o, a, s = e || this, c = s.xPercent, l = s.yPercent, h = s.x, p = s.y, d = s.rotation, m = s.skewX, v = s.skewY, g = s.scaleX, y = s.scaleY, x = s.target, b = s.xOrigin, w = s.yOrigin, _ = s.xOffset, M = s.yOffset, S = s.forceCSS, T = parseFloat(h), E = parseFloat(p); d = parseFloat(d), m = parseFloat(m), (v = parseFloat(v)) && (m += v = parseFloat(v), d += v), d || m ? (d *= f, m *= f, r = Math.cos(d) * g, n = Math.sin(d) * g, i = Math.sin(d - m) * -y, o = Math.cos(d - m) * y, m && (v *= f, a = Math.tan(m - v), i *= a = Math.sqrt(1 + a * a), o *= a, v && (a = Math.tan(v), r *= a = Math.sqrt(1 + a * a), n *= a)), r = Object(u.r)(r), n = Object(u.r)(n), i = Object(u.r)(i), o = Object(u.r)(o)) : (r = g, o = y, n = i = 0), (T && !~(h + "").indexOf("px") || E && !~(p + "").indexOf("px")) && (T = X(x, "x", h, "px"), E = X(x, "y", p, "px")), (b || w || _ || M) && (T = Object(u.r)(T + b - (b * r + w * i) + _), E = Object(u.r)(E + w - (b * n + w * o) + M)), (c || l) && (a = x.getBBox(), T = Object(u.r)(T + c / 100 * a.width), E = Object(u.r)(E + l / 100 * a.height)), a = "matrix(" + r + "," + n + "," + i + "," + o + "," + T + "," + E + ")", x.setAttribute("transform", a), S && (x.style[I] = a) }, ut = function (t, e, r, n, i, o) { var a, s, c = Object(u.j)(i), l = parseFloat(i) * (c && ~i.indexOf("rad") ? d : 1), h = o ? l * o : l - n, p = n + h + "deg"; return c && ("short" === (a = i.split("_")[1]) && (h %= 360) !== h % 180 && (h += h < 0 ? 360 : -360), "cw" === a && h < 0 ? h = (h + 36e9) % 360 - 360 * ~~(h / 360) : "ccw" === a && h > 0 && (h = (h - 36e9) % 360 - 360 * ~~(h / 360))), t._pt = s = new u.b(t._pt, e, r, n, h, _), s.e = p, s.u = "deg", t._props.push(r), s }, pt = function (t, e, r) { var n, o, a, s, l, h, d, f = c.style, m = r._gsap; for (o in f.cssText = getComputedStyle(r).cssText + ";position:absolute;display:block;", f[I] = e, i.body.appendChild(c), n = ot(c, 1), p) (a = m[o]) !== (s = n[o]) && "perspective,force3D,transformOrigin,svgOrigin".indexOf(o) < 0 && (l = Object(u.v)(a) !== (d = Object(u.v)(s)) ? X(r, o, a, d) : parseFloat(a), h = parseFloat(s), t._pt = new u.b(t._pt, m, o, l, h - l, w), t._pt.u = d || 0, t._props.push(o)); i.body.removeChild(c) }; Object(u.f)("padding,margin,Width,Radius", (function (t, e) { var r = "Top", n = "Right", i = "Bottom", o = "Left", a = (e < 3 ? [r, n, i, o] : [r + o, r + n, i + n, i + o]).map((function (r) { return e < 2 ? t + r : "border" + r + t })); Q[e > 1 ? "border" + t : t] = function (t, e, r, n, i) { var o, s; if (arguments.length < 4) return o = a.map((function (e) { return Y(t, e, r) })), 5 === (s = o.join(" ")).split(o[0]).length ? o[0] : s; o = (n + "").split(" "), s = {}, a.forEach((function (t, e) { return s[t] = o[e] = o[e] || o[(e - 1) / 2 | 0] })), t.init(e, s, i) } })); var dt, ft, mt = { name: "css", register: B, targetTest: function (t) { return t.style && t.nodeType }, init: function (t, e, r, n, i) { var o, s, c, l, h, d, f, m, v, g, y, _, T, E, A, L, P, R, C, O = this._props, N = t.style; for (f in a || B(), e) if ("autoRound" !== f && (s = e[f], !u.n[f] || !Object(u.c)(f, e, r, n, t, i))) if (h = typeof s, d = Q[f], "function" === h && (h = typeof (s = s.call(r, n, t, i))), "string" === h && ~s.indexOf("random(") && (s = Object(u.q)(s)), d) d(this, t, f, s, r) && (A = 1); else if ("--" === f.substr(0, 2)) this.add(N, "setProperty", getComputedStyle(t).getPropertyValue(f) + "", s + "", n, i, 0, 0, f); else { if (o = Y(t, f), l = parseFloat(o), (g = "string" === h && "=" === s.charAt(1) ? +(s.charAt(0) + "1") : 0) && (s = s.substr(2)), c = parseFloat(s), f in b && ("autoAlpha" === f && (1 === l && "hidden" === Y(t, "visibility") && c && (l = 0), W(this, N, "visibility", l ? "inherit" : "hidden", c ? "inherit" : "hidden", !c)), "scale" !== f && "transform" !== f && ~(f = b[f]).indexOf(",") && (f = f.split(",")[0])), y = f in p) if (_ || ((T = t._gsap).renderTransform || ot(t), E = !1 !== e.smoothOrigin && T.smooth, (_ = this._pt = new u.b(this._pt, N, I, 0, 1, T.renderTransform, T, 0, -1)).dep = 1), "scale" === f) this._pt = new u.b(this._pt, T, "scaleY", T.scaleY, g ? g * c : c - T.scaleY), O.push("scaleY", f), f += "X"; else { if ("transformOrigin" === f) { P = void 0, R = void 0, C = void 0, P = (L = s).split(" "), R = P[0], C = P[1] || "50%", "top" !== R && "bottom" !== R && "left" !== C && "right" !== C || (L = R, R = C, C = L), P[0] = J[R] || R, P[1] = J[C] || C, s = P.join(" "), T.svg ? it(t, s, 0, E, 0, this) : ((v = parseFloat(s.split(" ")[2])) !== T.zOrigin && W(this, T, "zOrigin", T.zOrigin, v), W(this, N, f, at(o), at(s))); continue } if ("svgOrigin" === f) { it(t, s, 1, E, 0, this); continue } if (f in tt) { ut(this, T, f, l, s, g); continue } if ("smoothOrigin" === f) { W(this, T, "smooth", T.smooth, s); continue } if ("force3D" === f) { T[f] = s; continue } if ("transform" === f) { pt(this, s, t); continue } } else f in N || (f = U(f) || f); if (y || (c || 0 === c) && (l || 0 === l) && !x.test(s) && f in N) (m = (o + "").substr((l + "").length)) !== (v = (s + "").substr((c + "").length) || (f in u.e.units ? u.e.units[f] : m)) && (l = X(t, f, o, v)), this._pt = new u.b(this._pt, y ? T : N, f, l, g ? g * c : c - l, "px" !== v || !1 === e.autoRound || y ? w : S), this._pt.u = v || 0, m !== v && (this._pt.b = o, this._pt.r = M); else if (f in N) Z.call(this, t, f, o, s); else { if (!(f in t)) { Object(u.l)(f, s); continue } this.add(t, f, t[f], s, n, i) } O.push(f) } A && Object(u.s)(this) }, get: Y, aliases: b, getSetter: function (t, e, r) { return (e = b[e] || e) in p && e !== N && (t._gsap.x || Y(t, "x")) ? r && l === r ? "scale" === e ? R : P : (l = r || {}) && ("scale" === e ? C : O) : t.style && !Object(u.k)(t.style[e]) ? A : ~e.indexOf("-") ? L : Object(u.i)(t, e) } }; u.w.utils.checkPrefix = U, dt = "rotation,rotationX,rotationY,skewX,skewY", ft = Object(u.f)("x,y,z,scale,scaleX,scaleY,xPercent,yPercent," + dt + ",transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective", (function (t) { p[t] = 1 })), Object(u.f)(dt, (function (t) { u.e.units[t] = "deg", tt[t] = 1 })), b[ft[13]] = "x,y,z,scale,scaleX,scaleY,xPercent,yPercent," + dt, Object(u.f)("0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY", (function (t) { var e = t.split(":"); b[e[1]] = ft[e[0]] })), Object(u.f)("x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective", (function (t) { u.e.units[t] = "px" })), u.w.registerPlugin(mt), r.d(e, "a", (function () { return vt })); var vt = u.w.registerPlugin(mt) || u.w; vt.core.Tween } }]);